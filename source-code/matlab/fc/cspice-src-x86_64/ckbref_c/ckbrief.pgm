/* ckbrief.f -- translated by f2c (version 19980913).
   You must link the resulting object file with the libraries:
	-lf2c -lm   (in that order)
*/

#include "f2c.h"

/* Table of constant values */

static integer c__1 = 1;
static integer c__2 = 2;
static integer c__6 = 6;
static integer c__99999 = 99999;
static integer c_b284 = 200000;

/* $Program    CKBRIEF ( BRIEF CK summary ) */

/* Main program */ MAIN__(void)
{
    /* System generated locals */
    address a__1[2];
    integer i__1, i__2[2], i__3, i__4, i__5, i__6;
    char ch__1[25013];

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_rnge(char *, integer, 
	    char *, integer);
    /* Subroutine */ int s_stop(char *, ftnlen), s_cat(char *, char **, 
	    integer *, integer *, ftnlen);

    /* Local variables */
    static integer avfa[100000];
    static char arch[3], line[256];
    static logical help;
    static integer nobj, avfo[100000];
    static logical fdsp, gdsp;
    static integer avfs[100000];
    extern /* Subroutine */ int zzckcvr2_(integer *, integer *, integer *, 
	    doublereal *);
    static doublereal wind[200006];
    extern /* Subroutine */ int zzckcvr3_(integer *, integer *, integer *, 
	    doublereal *), zzckcvr4_(integer *, integer *, integer *, 
	    doublereal *), zzckcvr5_(integer *, integer *, integer *, 
	    doublereal *);
    static logical tdsp;
    static char type__[3], text[256*102], strn[256];
    static logical vrsn;
    static char tout[256], pass1[25000], pass2[25000], pass3[25000];
    static integer i__, k, l;
    extern integer cardd_(doublereal *);
    extern /* Subroutine */ int kdata_(integer *, char *, char *, char *, 
	    char *, integer *, logical *, ftnlen, ftnlen, ftnlen, ftnlen), 
	    dafgs_(doublereal *);
    static doublereal tenda[100000];
    static logical obnam;
    extern /* Subroutine */ int chkin_(char *, ftnlen);
    extern logical beint_(char *, ftnlen);
    static logical sfile;
    static integer nobgo;
    extern /* Subroutine */ int rdnbl_(char *, char *, logical *, ftnlen, 
	    ftnlen), repmc_(char *, char *, char *, char *, ftnlen, ftnlen, 
	    ftnlen, ftnlen), errch_(char *, char *, ftnlen, ftnlen);
    static integer nobgs;
    static doublereal tendo[100000], tempe[100000];
    static integer value;
    static doublereal tends[100000];
    static logical idump, found;
    extern /* Subroutine */ int dafus_(doublereal *, integer *, integer *, 
	    doublereal *, integer *);
    static integer typea[100000];
    static char hword[256];
    extern /* Subroutine */ int repmi_(char *, char *, integer *, char *, 
	    ftnlen, ftnlen, ftnlen), movei_(integer *, integer *, integer *), 
	    moved_(doublereal *, integer *, doublereal *);
    static doublereal temps[100000];
    static char error[256];
    extern integer rtrim_(char *, ftnlen);
    static integer start;
    static char utext[256*20];
    static doublereal dc[2];
    static integer ic[6], baddra[100000];
    extern /* Subroutine */ int daffna_(logical *);
    static integer eaddra[100000];
    extern /* Subroutine */ int dafbfs_(integer *);
    static integer handle, framea[100000];
    extern /* Subroutine */ int dafcls_(integer *), scardd_(integer *, 
	    doublereal *);
    static logical havfil;
    static integer frameo[100000];
    extern /* Subroutine */ int getcml_(char *, ftnlen);
    static integer frames[100000], findex;
    extern /* Subroutine */ int inslai_(integer *, integer *, integer *, 
	    integer *, integer *);
    extern integer isrchi_(integer *, integer *, integer *);
    static char srcfil[256];
    static integer iorder[100000], objlis[100];
    static logical fulbuf, nomerg, fndsum;
    static integer numobj;
    static logical mixdav, mixdfr;
    static integer fcount;
    static doublereal segsum[5];
    static char filtyp[256], source[256];
    extern /* Subroutine */ int erract_(char *, char *, ftnlen, ftnlen), 
	    tostdo_(char *, ftnlen), fndnwd_(char *, integer *, integer *, 
	    integer *, ftnlen), suffix_(char *, integer *, char *, ftnlen, 
	    ftnlen), nparsi_(char *, integer *, char *, integer *, ftnlen, 
	    ftnlen), getfat_(char *, char *, char *, ftnlen, ftnlen, ftnlen);
    static doublereal tstrta[100000];
    extern /* Subroutine */ int setmsg_(char *, ftnlen), sigerr_(char *, 
	    ftnlen), furnsh_(char *, ftnlen), ktotal_(char *, integer *, 
	    ftnlen), tkvrsn_(char *, char *, ftnlen, ftnlen), dafopr_(char *, 
	    integer *, ftnlen), ssized_(integer *, doublereal *), dispsm_(
	    integer *, integer *, doublereal *, doublereal *, integer *, 
	    integer *, char *, logical *, logical *, logical *, ftnlen), 
	    wnvald_(integer *, integer *, doublereal *), orderd_(doublereal *,
	     integer *, integer *), reordd_(integer *, integer *, doublereal *
	    ), reordi_(integer *, integer *, integer *);
    static doublereal tstrto[100000];
    extern /* Subroutine */ int chkout_(char *, ftnlen), byebye_(char *, 
	    ftnlen);
    static doublereal tstrts[100000];
    static integer beg, ida[100000], end;
    static logical fnd, eof;
    static integer ido[100000], loc, ids[100000], cnt, ptr;


/* $ Abstract */

/*     CKBRIEF is a utility program that provides brief summaries of */
/*     the contents of one or more CK files. */

/* $ Disclaimer */

/*     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE */
/*     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S. */
/*     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE */
/*     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE */
/*     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS" */
/*     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY */
/*     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A */
/*     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC */
/*     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE */
/*     SOFTWARE AND RELATED MATERIALS, HOWEVER USED. */

/*     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA */
/*     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT */
/*     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND, */
/*     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS, */
/*     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE */
/*     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY. */

/*     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF */
/*     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY */
/*     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE */
/*     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE. */

/* $ Required_Reading */

/*     CKBRIEF User's Guide. */

/* $ Keywords */

/*     FILES */
/*     UTILITY */

/* $ Parameters */

/*     None. */

/* $ Exceptions */

/*     None. */

/* $ Files */

/*     1) All summary tasks performed require name for at least one */
/*        CK file to be provided. */

/*     2) To display time tags in any format (except DP SCLK), LSK */
/*        and appropriate SCLK files must be provided. */

/* $ Particulars */

/*     For usage details see User's Guide. */

/* $ Examples */

/*     None. */

/* $ Restrictions */

/*     None. */

/* $ Literature_References */

/*     None. */

/* $ Author_and_Institution */

/*     Y.K. Zaiko     (BERC) */
/*     B.V. Semenov   (NAIF) */
/*     F.S. Turner    (JPL) */

/* $ Version */

/* -    Toolkit Version 4.0.0, 13-JAN-2008 (BVS) */

/*        Bug fix: GDSP is now initialized to .FALSE. Uninitialized GDSP */
/*        caused spontaneous, unsolicited grouping displays on some C */
/*        environments. */

/*        Updated to summarize CKs provided in meta-kernels. Updated to */
/*        recognize and complain about kernels that should be */
/*        summarized other utility programs. Updated to display shorter */
/*        usage message when ran with a blank command line. */

/*        Changed format of the displayed version string. */

/*        Added CHKIN/CHKOUT and set ERRACT to ABORT (which removed */
/*        "Oh, by the way ..." from the errors). */

/*        Increased MAXBOD to 100,000 (from 10,000) and CMDSIZ to */
/*        25,000 (from 4,000) */

/*        SAVEed all variables. */

/* -    Toolkit Version 3.2.0, 02-NOV-2006 (BVS) */

/*        Replaced LDPOOL with FURNSH. */

/* -    Toolkit Version 3.1.0, 08-NOV-2005 (BVS) */

/*        Updated usage display to describe what kind of summary */
/*        is generated by default. */

/* -    Toolkit Version 3.0.0, 28-AUG-2002 (FST) */

/*        Added support for the -dump option for type 4 and 5 CK */
/*        segments. */

/*        Modified ZZCKCVR3 calling sequence to agree with changes */
/*        as delivered to support. */

/* -    Toolkit Version 2.0.0, 15-MAY-2001 (BVS) */

/*        Added option to dump interpolation interval information */
/*        from type 2 & 3 CK segments. */

/* -    Toolkit Version 1.1.2, 09-APR-2001 (BVS) */

/*        Fixed usage display and User's Guide. */

/* -    Toolkit Version 1.1.1, 03-NOV-2000 (EDW) */

/*        Added a BYEBYE( 'SUCCESS' ) call at program's end. */

/* -    Toolkit Version 1.1.0, 14-OCT-1999 (WLT) */

/*        Commented out EXTERNALS in source code.  See note in the */
/*        code for details. */

/* -    Toolkit Version 1.0.0, 26-Mar-1999 (WLT) */

/*        Added code to skip attempting to load binary kernels into */
/*        the kernel pool. */

/* -    Beta Version 1.0.0,  24-MAR-1999  ( YKZ ) ( BVS ) */

/*        See CKBRIEF.INC for version information. */

/* -& */

/*     User adjustable parameters. */


/*     Passed Functions */

/*     The lines below have been commented out as they do not appear */
/*     to be needed for anything.  BIGGER and INC are not referenced */
/*     anywhere else in this file.  (WLT) 14-OCT-1999 */

/*      EXTERNAL              BIGGER */
/*      EXTERNAL              INC */

/*     SPICELIB Functions */

/* $ Disclaimer */

/*     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE */
/*     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S. */
/*     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE */
/*     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE */
/*     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS" */
/*     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY */
/*     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A */
/*     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC */
/*     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE */
/*     SOFTWARE AND RELATED MATERIALS, HOWEVER USED. */

/*     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA */
/*     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT */
/*     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND, */
/*     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS, */
/*     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE */
/*     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY. */

/*     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF */
/*     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY */
/*     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE */
/*     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE. */

/* $ Author_and_Institution */

/*     Y.K. Zaiko     (BERC) */
/*     B.V. Semenov   (NAIF) */

/* $ Version */

/* -    CKBRIEF Version 4.0.0, 2008-01-13 (BVS) */

/*        Increased MAXBOD to 100,000 (from 10,000). */

/*        Increased CMDSIZ to 25,000 (from 4,000). */

/*        Updated version string and changed its format to */
/*        '#.#.#, Month DD, YYYY' (from '#.#.#, YYYY-MM-DD'). */

/* -    CKBRIEF Version 3.2.0, 2006-11-02 (BVS) */

/*        Updated version string. */

/* -    CKBRIEF Version 3.1.0, 2005-11-08 (BVS) */

/*        Updated version string. */

/* -    CKBRIEF Version 2.0.0, 2001-05-16 (BVS) */

/*        Increased MAXBOD to 10000 (from 4000). Set LRGWIN to be */
/*        MAXBOD*2 (was MAXBOD). Changed version string. */

/* -    CKBRIEF Version 1.1.2, 2001-04-09 (BVS) */

/*        Changed version parameter. */

/* -    CKBRIEF Version 1.0.0 beta, 1999-02-17 (YKZ)(BVS) */

/*        Initial release. */

/* -& */

/*     The Version is stored as a string. */


/*     The maximum number of segments or interpolation intervals */
/*     that can be summarized is stored in the parameter MAXBOD. */
/*     This is THE LIMIT that should be increased in window */
/*     routines called by CKBRIEF fail. */


/*     The largest expected window -- must be twice the size of */
/*     MAXBOD for consistency. */


/*     The longest command line that can be accommodated is */
/*     given by CMDSIZ. */


/*     MAXUSE is the maximum number of objects that can be explicitly */
/*     specified on the command line for ckbrief summaries. */


/*     Generic line size for all modules. */


/*     Time type keys. */


/*     Output time format pictures. */


/*     Local parameters */


/*     Command line options as parameters. */


/*     Lower cell size. */


/*     CK DAF summary component counts. */


/*     SPICE Kernel types as recognized by GETFAT. */


/*     Usage and help message sizes. */


/*     Local variables. */


/*     Help message holder. */


/*     Usage message holder. */


/*     Ancillary line and file names holder line. */


/*     Command line and parsing variables. */


/*     Parsed Control Values. */


/*     Internal flags explanation: FNDSUM is .TRUE. if we have */
/*     something found to display in CK-file we are considering. */


/*     DAF Variables */


/*     Arrays to store segment descriptors data for an objects with */
/*     a single intervals of coverage in a given CK-file */


/*     Arrays to store all segment descriptors data for a given CK-file */


/*     Arrays to store all segment descriptors data for one object in */
/*     a given CK-file */


/*     Utility Variables */


/*     Variable for dealing with FURNSH'ed CKs. */


/*     Save all variables. */


/*     SPICELIB error handling. */

    chkin_("CKBRIEF", (ftnlen)7);
    erract_("SET", "ABORT", (ftnlen)3, (ftnlen)5);

/*     The first thing we do is to display version. */

    s_copy(line, "CKBRIEF -- Version # -- Toolkit Version #", (ftnlen)256, (
	    ftnlen)41);
    tostdo_(" ", (ftnlen)1);
    repmc_(line, "#", "4.0.0, January 13, 2008", line, (ftnlen)256, (ftnlen)1,
	     (ftnlen)23, (ftnlen)256);
    tkvrsn_("TOOLKIT", hword, (ftnlen)7, (ftnlen)256);
    repmc_(line, "#", hword, line, (ftnlen)256, (ftnlen)1, (ftnlen)256, (
	    ftnlen)256);
    tostdo_(line, (ftnlen)256);

/*     Set up the usage text. */

    s_copy(utext, "   CKBRIEF is a command-line utility program that display"
	    "s a summary for", (ftnlen)256, (ftnlen)72);
    s_copy(utext + 256, "   one or more binary CK files. The program usage i"
	    "s:", (ftnlen)256, (ftnlen)53);
    s_copy(utext + 512, " ", (ftnlen)256, (ftnlen)1);
    s_copy(utext + 768, "      % ckbrief [-options] file [file ...]", (ftnlen)
	    256, (ftnlen)42);
    s_copy(utext + 1024, " ", (ftnlen)256, (ftnlen)1);
    s_copy(utext + 1280, "   The most useful options are shown below. For th"
	    "e complete set of", (ftnlen)256, (ftnlen)67);
    s_copy(utext + 1536, "   options, run CKBRIEF with the -h option. The or"
	    "der of options is not", (ftnlen)256, (ftnlen)71);
    s_copy(utext + 1792, "   significant. The case of option keys is signifi"
	    "cant: they must be", (ftnlen)256, (ftnlen)68);
    s_copy(utext + 2048, "   lowercase as shown below.", (ftnlen)256, (ftnlen)
	    28);
    s_copy(utext + 2304, " ", (ftnlen)256, (ftnlen)1);
    s_copy(utext + 2560, "      -dump        display interpolation intervals",
	     (ftnlen)256, (ftnlen)50);
    s_copy(utext + 2816, "      -rel         display relative-to frames (may"
	    " need FK)", (ftnlen)256, (ftnlen)59);
    s_copy(utext + 3072, "      -t           display summary in a tabular fo"
	    "rmat", (ftnlen)256, (ftnlen)54);
    s_copy(utext + 3328, "      -utc         display times in UTC calendar d"
	    "ate format (needs LSK&SCLK)", (ftnlen)256, (ftnlen)77);
    s_copy(utext + 3584, "      -utcdoy      display times in UTC day-of-yea"
	    "r format (needs LSK&SCLK)", (ftnlen)256, (ftnlen)75);
    s_copy(utext + 3840, "      -sclk        display times as SCLK strings ("
	    "needs SCLK)", (ftnlen)256, (ftnlen)61);
    s_copy(utext + 4096, " ", (ftnlen)256, (ftnlen)1);
    s_copy(utext + 4352, "   LSK and SCLK files must be provided on the comm"
	    "and line to display times", (ftnlen)256, (ftnlen)75);
    s_copy(utext + 4608, "   in UTC, ET, or SCLK formats. FK file(s) must be"
	    " provided on the command", (ftnlen)256, (ftnlen)74);
    s_copy(utext + 4864, "   line to display names of any frames that are no"
	    "t built into the Toolkit.", (ftnlen)256, (ftnlen)75);

/*     Set up the help text. */

    s_copy(text, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 256, "     CKBRIEF is a command line program that allows y"
	    "ou to easily summarize", (ftnlen)256, (ftnlen)74);
    s_copy(text + 512, "     the pointing (orientation) data coverage of one"
	    " or more SPICE CK", (ftnlen)256, (ftnlen)69);
    s_copy(text + 768, "     files. ``Coverage'' is used in the sense of spe"
	    "cifying time span(s)", (ftnlen)256, (ftnlen)72);
    s_copy(text + 1024, "     for which orientation data are available.", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 1280, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 1536, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 1792, "Usage", (ftnlen)256, (ftnlen)5);
    s_copy(text + 2048, "---------------------------------------------------"
	    "-----", (ftnlen)256, (ftnlen)56);
    s_copy(text + 2304, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 2560, "     CKBRIEF is run by typing the name of the progr"
	    "am at a shell prompt.", (ftnlen)256, (ftnlen)72);
    s_copy(text + 2816, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 3072, "        ckbrief [-option(s)] ck-file [ck-file ...] "
	    "[sclk-file] [lsk-file]", (ftnlen)256, (ftnlen)73);
    s_copy(text + 3328, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 3584, "     A wide variety of options may be specified on "
	    "the command line giving", (ftnlen)256, (ftnlen)74);
    s_copy(text + 3840, "     you a great deal of flexibility in the operati"
	    "on and summary", (ftnlen)256, (ftnlen)65);
    s_copy(text + 4096, "     capability of the program.", (ftnlen)256, (
	    ftnlen)31);
    s_copy(text + 4352, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 4608, "     A SPICE SCLK file must be provided if time bou"
	    "nds are to be displayed", (ftnlen)256, (ftnlen)74);
    s_copy(text + 4864, "     as SCLK strings. Both an SCLK and an LSK file "
	    "must be provided if time", (ftnlen)256, (ftnlen)75);
    s_copy(text + 5120, "     bounds are to be displayed in UTC, DOY or ET.", 
	    (ftnlen)256, (ftnlen)50);
    s_copy(text + 5376, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 5632, "     The options and CK, SCLK and LSK file names ma"
	    "y appear in any order on", (ftnlen)256, (ftnlen)75);
    s_copy(text + 5888, "     the command line.", (ftnlen)256, (ftnlen)22);
    s_copy(text + 6144, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 6400, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 6656, "Options", (ftnlen)256, (ftnlen)7);
    s_copy(text + 6912, "---------------------------------------------------"
	    "-----", (ftnlen)256, (ftnlen)56);
    s_copy(text + 7168, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 7424, "     Any of the following options may be specified."
	    " Some options may", (ftnlen)256, (ftnlen)68);
    s_copy(text + 7680, "     disable other options in which case the last s"
	    "pecified option will be", (ftnlen)256, (ftnlen)74);
    s_copy(text + 7936, "     used. For example if you request that coverage"
	    " be displayed as", (ftnlen)256, (ftnlen)67);
    s_copy(text + 8192, "     ephemeris time and another option in the same "
	    "command line requests", (ftnlen)256, (ftnlen)72);
    s_copy(text + 8448, "     UTC time then only UTC time will be displayed."
	    " We have not attempted", (ftnlen)256, (ftnlen)73);
    s_copy(text + 8704, "     to spell out all of the possible conflicts her"
	    "e, since for the most", (ftnlen)256, (ftnlen)72);
    s_copy(text + 8960, "     part you'd be unlikely to specify conflicting "
	    "options intentionally.", (ftnlen)256, (ftnlen)73);
    s_copy(text + 9216, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 9472, "           -t        display results in a tabular f"
	    "ormat", (ftnlen)256, (ftnlen)56);
    s_copy(text + 9728, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 9984, "           -g        group together objects having "
	    "the same coverage", (ftnlen)256, (ftnlen)68);
    s_copy(text + 10240, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 10496, "           -rel      display ID code or name of th"
	    "e frame relative to which", (ftnlen)256, (ftnlen)75);
    s_copy(text + 10752, "                     orientation is available", (
	    ftnlen)256, (ftnlen)45);
    s_copy(text + 11008, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 11264, "           -h        display help text", (ftnlen)
	    256, (ftnlen)38);
    s_copy(text + 11520, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 11776, "           -v        display the version number of"
	    " the program", (ftnlen)256, (ftnlen)62);
    s_copy(text + 12032, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 12288, "           -f        provide a text ``list file'' "
	    "containing full path", (ftnlen)256, (ftnlen)70);
    s_copy(text + 12544, "                     name(s) of CK file(s) to summ"
	    "arize and/or the names of", (ftnlen)256, (ftnlen)75);
    s_copy(text + 12800, "                     SPICE SCLK or LSK files to us"
	    "e for doing time", (ftnlen)256, (ftnlen)66);
    s_copy(text + 13056, "                     conversions. This flag is use"
	    "d as shown below", (ftnlen)256, (ftnlen)66);
    s_copy(text + 13312, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 13568, "                        -f list_of_sources.file", (
	    ftnlen)256, (ftnlen)47);
    s_copy(text + 13824, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 14080, "           -sclk     display times in spacecraft c"
	    "lock string format", (ftnlen)256, (ftnlen)68);
    s_copy(text + 14336, "                     (requires SPICE SCLK file)", (
	    ftnlen)256, (ftnlen)47);
    s_copy(text + 14592, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 14848, "           -dpsclk   display times in spacecraft c"
	    "lock double precision", (ftnlen)256, (ftnlen)71);
    s_copy(text + 15104, "                     format (also called \"spacecr"
	    "aft clock ticks\")", (ftnlen)256, (ftnlen)66);
    s_copy(text + 15360, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 15616, "           -utc      display times in UTC Calendar"
	    " Date format (requires", (ftnlen)256, (ftnlen)72);
    s_copy(text + 15872, "                     SPICE SCLK and LSK files)", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 16128, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 16384, "           -utcdoy   display times in UTC Day-Of-Y"
	    "ear format (requires", (ftnlen)256, (ftnlen)70);
    s_copy(text + 16640, "                     SPICE SCLK and LSK files)", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 16896, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 17152, "           [obj]     create a summary for the spec"
	    "ified object. Here \"obj\"", (ftnlen)256, (ftnlen)74);
    s_copy(text + 17408, "                     is the NAIF ID integer code o"
	    "f a spacecraft,", (ftnlen)256, (ftnlen)65);
    s_copy(text + 17664, "                     instrument or structure. Note"
	    " that CKBRIEF assumes", (ftnlen)256, (ftnlen)71);
    s_copy(text + 17920, "                     that NAIF ID codes for a spac"
	    "ecraft, instrument or", (ftnlen)256, (ftnlen)71);
    s_copy(text + 18176, "                     structure are negative intege"
	    "r numbers. (Don't include", (ftnlen)256, (ftnlen)75);
    s_copy(text + 18432, "                     the square brackets)", (ftnlen)
	    256, (ftnlen)41);
    s_copy(text + 18688, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 18944, "           -nm       (\"no merge\") causes the pro"
	    "gram to display a separate", (ftnlen)256, (ftnlen)74);
    s_copy(text + 19200, "                     record for each segment in th"
	    "e CK file, even when", (ftnlen)256, (ftnlen)70);
    s_copy(text + 19456, "                     segments overlap", (ftnlen)256,
	     (ftnlen)37);
    s_copy(text + 19712, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 19968, "           -dump     causes the program to display"
	    " a separate record for", (ftnlen)256, (ftnlen)72);
    s_copy(text + 20224, "                     each interpolation interval i"
	    "n each segment of every", (ftnlen)256, (ftnlen)73);
    s_copy(text + 20480, "                     CK file; overrides options -g"
	    ", [obj] and -nm", (ftnlen)256, (ftnlen)65);
    s_copy(text + 20736, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 20992, "     If neither \"-nm\" nor \"-dump\" option is sp"
	    "ecified the program displays", (ftnlen)256, (ftnlen)74);
    s_copy(text + 21248, "     merged coverage based on the segment descript"
	    "or information.", (ftnlen)256, (ftnlen)65);
    s_copy(text + 21504, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 21760, "     If none of the options specifying output time"
	    " display type (\"-sclk\",", (ftnlen)256, (ftnlen)73);
    s_copy(text + 22016, "     \"-dpsclk\", \"-utc\", \"-utcdoy\") is specif"
	    "ied, the times are displayed as", (ftnlen)256, (ftnlen)75);
    s_copy(text + 22272, "     Ephemeris Time (ET) in calendar date format.", 
	    (ftnlen)256, (ftnlen)49);
    s_copy(text + 22528, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 22784, "     The name(s) of CK file(s) to be summarized an"
	    "d the LSK and SCLK files", (ftnlen)256, (ftnlen)74);
    s_copy(text + 23040, "     required to support time conversions must be "
	    "provided on the command", (ftnlen)256, (ftnlen)73);
    s_copy(text + 23296, "     line, or in a list file, the name of which mu"
	    "st be provided on the", (ftnlen)256, (ftnlen)71);
    s_copy(text + 23552, "     command line following the \"-f\" key. The na"
	    "mes provided in a list file", (ftnlen)256, (ftnlen)75);
    s_copy(text + 23808, "     may each be on a separate line, or multiple n"
	    "ames per line separated", (ftnlen)256, (ftnlen)73);
    s_copy(text + 24064, "     by spaces, or mixture of these two cases.", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 24320, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 24576, "     CKBRIEF will NOT display the time if needed S"
	    "CLK, or SCLK and LSK,", (ftnlen)256, (ftnlen)71);
    s_copy(text + 24832, "     files were not provided.", (ftnlen)256, (
	    ftnlen)29);
    s_copy(text + 25088, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 25344, "     CKBRIEF will inform the user of any incorrect"
	    " option, incorrect file", (ftnlen)256, (ftnlen)73);
    s_copy(text + 25600, "     name, or incorrect file type specified on the"
	    " command line.", (ftnlen)256, (ftnlen)64);
    s_copy(text + 25856, " ", (ftnlen)256, (ftnlen)1);

/*     Next step is to parse the command line. This is done in two */
/*     passes. The first pass determines the options specified. The */
/*     second pass gets file names. */

/*     Pass one.  The defaults are: */

    obnam = FALSE_;
    tdsp = FALSE_;
    gdsp = FALSE_;
    help = FALSE_;
    vrsn = FALSE_;
    havfil = FALSE_;
    fdsp = FALSE_;
    sfile = FALSE_;
    nomerg = FALSE_;
    idump = FALSE_;
    s_copy(tout, "ET", (ftnlen)256, (ftnlen)2);

/*     Reset ancillary strings that will be used in parsing of the */
/*     command line. */

    s_copy(pass1, " ", (ftnlen)25000, (ftnlen)1);
    s_copy(pass2, " ", (ftnlen)25000, (ftnlen)1);
    s_copy(pass3, " ", (ftnlen)25000, (ftnlen)1);

/*     Get command line. */

    getcml_(pass1, (ftnlen)25000);

/*     If command line is blank display brief usage. */

    if (s_cmp(pass1, " ", (ftnlen)25000, (ftnlen)1) == 0) {
	tostdo_(" ", (ftnlen)1);
	for (i__ = 1; i__ <= 20; ++i__) {
	    tostdo_(utext + (((i__1 = i__ - 1) < 20 && 0 <= i__1 ? i__1 : 
		    s_rnge("utext", i__1, "ckbrief_", (ftnlen)664)) << 8), (
		    ftnlen)256);
	}
	tostdo_(" ", (ftnlen)1);
	s_stop("", (ftnlen)0);
    }

/*     Now locate the first word in the command line. */

    numobj = 0;
    start = 1;
    fndnwd_(pass1, &start, &beg, &end, (ftnlen)25000);
    while(beg > 0) {

/*        All options begin with a '-'. */

	if (*(unsigned char *)&pass1[beg - 1] != '-') {

/*           This item doesn't have dash as the first character, so */
/*           it is presumed to be a file name which we will append */
/*           to the string containing only file names. */

	    suffix_(pass1 + (beg - 1), &c__1, pass2, end - (beg - 1), (ftnlen)
		    25000);
	    havfil = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-t", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Display summary in tabular format. */

	    tdsp = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-g", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Group summaries for objects with the same coverage */

	    gdsp = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-rel", end - (beg - 1), (ftnlen)
		4) == 0) {

/*           Display names of reference frames */

	    fdsp = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-h", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Print the help. */

	    help = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-v", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Print the version. */

	    vrsn = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-f", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           We have got a file containing names of the CK, LSK */
/*           or/and SCLK files. */

	    start = end + 1;
	    fndnwd_(pass1, &start, &beg, &end, (ftnlen)25000);
	    if (beg > 0) {
		sfile = TRUE_;
		s_copy(srcfil, pass1 + (beg - 1), (ftnlen)256, end - (beg - 1)
			);
	    }
	} else if (s_cmp(pass1 + (beg - 1), "-utc", end - (beg - 1), (ftnlen)
		4) == 0) {

/*           Display times as UTC times. */

	    s_copy(tout, "UTC", (ftnlen)256, (ftnlen)3);
	} else if (s_cmp(pass1 + (beg - 1), "-sclk", end - (beg - 1), (ftnlen)
		5) == 0) {

/*           Display times as string SCLK times. */

	    s_copy(tout, "SCLK", (ftnlen)256, (ftnlen)4);
	} else if (s_cmp(pass1 + (beg - 1), "-dpsclk", end - (beg - 1), (
		ftnlen)7) == 0) {

/*           Display times as DP SCLK or SCLK ticks. */

	    s_copy(tout, "TICKS", (ftnlen)256, (ftnlen)5);
	} else if (s_cmp(pass1 + (beg - 1), "-utcdoy", end - (beg - 1), (
		ftnlen)7) == 0) {

/*           Display times as UTC/DOY times. */

	    s_copy(tout, "UTC/DOY", (ftnlen)256, (ftnlen)7);
	} else if (s_cmp(pass1 + (beg - 1), "-nm", end - (beg - 1), (ftnlen)3)
		 == 0) {

/*           Set "no-merge" flag. */

	    nomerg = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-dump", end - (beg - 1), (ftnlen)
		5) == 0) {

/*           Set "dump-intervals" flag. */

	    idump = TRUE_;
	} else {

/*           Items that begin with '-' that are not one of the previous */
/*           cases are regarded as a request to summarize only for */
/*           particular items. This item must an integer, so we try to */
/*           parse it as integer. If we were successful, we add to the */
/*           integer array containing IDs "to restrict relative to" :) */

	    if (beint_(pass1 + (beg - 1), end - (beg - 1))) {
		nparsi_(pass1 + (beg - 1), &value, error, &ptr, end - (beg - 
			1), (ftnlen)256);

/*              INSLAI is a great routine but it's our responsibility */
/*              to check whether our ID will fit into OBJLIS array. */

		if (numobj < 100) {

/*                 This ID will fit into our OBJLIS array, lets */
/*                 insert it there. */

		    i__1 = numobj + 1;
		    inslai_(&value, &c__1, &i__1, objlis, &numobj);
		} else {

/*                 There is no space for this ID in our array. Lets */
/*                 report about it. */

		    tostdo_(" Object number ", (ftnlen)15);
		    tostdo_(pass1 + (beg - 1), end - (beg - 1));
		    tostdo_(" doesn't fit into the buffer", (ftnlen)28);
		    tostdo_(" which can hold no more than", (ftnlen)28);
		    tostdo_(" MAXUSE elements.", (ftnlen)17);
		}
	    } else {

/*              Unrecognized option specified. */

		tostdo_(" ", (ftnlen)1);
		s_copy(hword, "'#' is not a recognized option.", (ftnlen)256, 
			(ftnlen)31);
		repmc_(hword, "#", pass1 + (beg - 1), hword, (ftnlen)256, (
			ftnlen)1, end - (beg - 1), (ftnlen)256);
		tostdo_(hword, (ftnlen)256);
		tostdo_(" ", (ftnlen)1);
		help = TRUE_;
	    }
	}

/*        Locate the next word. */

	start = end + 1;
	fndnwd_(pass1, &start, &beg, &end, (ftnlen)25000);
    }

/*     Handle any exceptions that might have been occurred. First, */
/*     display version if version key was the only one on the */
/*     command line. */

    if (vrsn && ! havfil && ! sfile && ! help) {
	tostdo_(" ", (ftnlen)1);
	s_stop("", (ftnlen)0);
    }

/*     Display help only if it was requested or if we didn't get any */
/*     file names on the command line and we didn't get the name of a */
/*     file containing these names. */

    help = help || ! (havfil || sfile);
    if (help) {
	tostdo_(" ", (ftnlen)1);
	for (i__ = 1; i__ <= 102; ++i__) {
	    tostdo_(text + (((i__1 = i__ - 1) < 102 && 0 <= i__1 ? i__1 : 
		    s_rnge("text", i__1, "ckbrief_", (ftnlen)859)) << 8), (
		    ftnlen)256);
	}
	tostdo_(" ", (ftnlen)1);
	s_stop("", (ftnlen)0);
    }

/*     Reset contradicting flags. If interval dump was requested we */
/*     cannot do grouping (-g), filtering by object ID ([obj]) or */
/*     displaying of segment boundaries (-nm). */

    if (idump) {
	nomerg = FALSE_;
	gdsp = FALSE_;
	numobj = 0;
    }

/*     Now finish up determining what the user wants us to do. It is */
/*     necessary to process string PASS2 and file SRCFIL, if it was */
/*     provided, to check files the names of which provided and */
/*     load/process these files correspondingly. */

/*     User can provide 3 types of input files: */

/*      - LSK file(s); */
/*      - SCLK file(s); */
/*      - binary CK file(s). */

/*     First, let check if we have a file name provided using -f */
/*     command line flag */

    if (sfile) {
	eof = FALSE_;
	while(! eof) {
	    rdnbl_(srcfil, strn, &eof, (ftnlen)256, (ftnlen)256);
	    if (! eof) {

/*              We need to check whether we have enough space in our */
/*              string to append another file name to it. If we do, */
/*              we append it. Other wise we report about it. */

		if (rtrim_(strn, (ftnlen)256) + rtrim_(pass2, (ftnlen)25000) <
			 25000) {
		    suffix_(strn, &c__1, pass2, (ftnlen)256, (ftnlen)25000);
		    havfil = TRUE_;
		} else {
		    s_copy(hword, "No space in the file name buffer for the "
			    "name '#' obtained from the input file '#'", (
			    ftnlen)256, (ftnlen)82);
		    repmc_(hword, "#", strn, hword, (ftnlen)256, (ftnlen)1, (
			    ftnlen)256, (ftnlen)256);
		    repmc_(hword, "#", srcfil, hword, (ftnlen)256, (ftnlen)1, 
			    (ftnlen)256, (ftnlen)256);
		    tostdo_(hword, (ftnlen)256);
		}
	    }
	}
    }

/*     Start processing of the file names in string PASS2. */

    if (havfil) {
	start = 1;
	fndnwd_(pass2, &start, &beg, &end, (ftnlen)25000);
	while(beg > 0) {
	    getfat_(pass2 + (beg - 1), arch, type__, end - (beg - 1), (ftnlen)
		    3, (ftnlen)3);
	    if (s_cmp(type__, "CK", (ftnlen)3, (ftnlen)2) == 0 && s_cmp(arch, 
		    "DAF", (ftnlen)3, (ftnlen)3) == 0) {

/*              We don't need to check whether we have enough space */
/*              in the PASS3 because PASS2 and PASS3 are of the same */
/*              size. */

		suffix_(pass2 + (beg - 1), &c__1, pass3, end - (beg - 1), (
			ftnlen)25000);
	    } else if (s_cmp(arch, "DAF", (ftnlen)3, (ftnlen)3) == 0 && s_cmp(
		    type__, "SPK", (ftnlen)3, (ftnlen)3) == 0) {

/*              Signal an error, reporting that this is a SPK file. */

		setmsg_("Kernel '#' is a binary SPK and, therefore, cannot b"
			"e summarized using CKBRIEF. Use BRIEF or SPACIT to s"
			"ummarize this file.", (ftnlen)122);
		errch_("#", pass2 + (beg - 1), (ftnlen)1, end - (beg - 1));
		sigerr_("SPICE(SPKFILE)", (ftnlen)14);
	    } else if (s_cmp(arch, "DAF", (ftnlen)3, (ftnlen)3) == 0 && s_cmp(
		    type__, "PCK", (ftnlen)3, (ftnlen)3) == 0) {

/*              Signal an error, reporting that this is a PCK file. */

		setmsg_("Kernel '#' is a binary PCK and, therefore, cannot b"
			"e summarized using CKBRIEF. Use BRIEF or SPACIT to s"
			"ummarize this file.", (ftnlen)122);
		errch_("#", pass2 + (beg - 1), (ftnlen)1, end - (beg - 1));
		sigerr_("SPICE(PCKFILE)", (ftnlen)14);
	    } else if (s_cmp(arch, "DAS", (ftnlen)3, (ftnlen)3) == 0 && s_cmp(
		    type__, "EK", (ftnlen)3, (ftnlen)2) == 0) {

/*              Signal an error, reporting that this is an EK file. */

		setmsg_("Kernel '#' is a binary EK and, therefore, cannot be"
			" summarized using BRIEF. Use SPACIT or INSPEKT to su"
			"mmarize this file.", (ftnlen)121);
		errch_("#", pass2 + (beg - 1), (ftnlen)1, end - (beg - 1));
		sigerr_("SPICE(EKFILE)", (ftnlen)13);
	    } else if (s_cmp(arch, "XFR", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(
		    arch, "DEC", (ftnlen)3, (ftnlen)3) == 0) {

/*              Signal an error, reporting that this is a transfer file. */

		setmsg_("Kernel '#' is in transfer format. It must be conver"
			"ted to binary format to be summarized using CKBRIEF.",
			 (ftnlen)103);
		errch_("#", pass2 + (beg - 1), (ftnlen)1, end - (beg - 1));
		sigerr_("SPICE(TRANSFERFORMAT)", (ftnlen)21);
	    } else if (s_cmp(arch, "DAS", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(
		    arch, "DAF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(arch, 
		    "TE1", (ftnlen)3, (ftnlen)3) == 0) {

/*              This is a ``catch all'' branch for all other kernels */
/*              that are not binary CKs. Signal an error, reporting that */
/*              this is a file with a wrong architecture and type. */

		setmsg_("Kernel '#' is not a binary CK and, therefore, canno"
			"t be summarized using CKBRIEF. It is a '#/#' file.", (
			ftnlen)101);
		errch_("#", pass2 + (beg - 1), (ftnlen)1, end - (beg - 1));
		errch_("#", arch, (ftnlen)1, (ftnlen)3);
		errch_("#", type__, (ftnlen)1, (ftnlen)3);
		sigerr_("SPICE(BADARCHITECTURE)", (ftnlen)22);
	    } else {

/*              This is probably a text kernel. To simplify our */
/*              lives we load this file into the kernel pool without */
/*              checking of what type this file is. If it's LSK or */
/*              SCLK, it's going to be processed just fine. If it's */
/*              something else, kernel pool subsystem won't find any */
/*              data in it ... it's just going to take a long time to */
/*              load if somebody provided the name of 20MB file :). */

		furnsh_(pass2 + (beg - 1), end - (beg - 1));
	    }
	    start = end + 1;
	    fndnwd_(pass2, &start, &beg, &end, (ftnlen)25000);
	}
    }

/*     See if any CKs were loaded via meta-kernels. If so, add them */
/*     to the list of CK files to be summarized. */

    ktotal_("CK", &fcount, (ftnlen)2);
    if (fcount != 0) {
	i__1 = fcount;
	for (findex = 1; findex <= i__1; ++findex) {
	    kdata_(&findex, "CK", strn, filtyp, source, &handle, &found, (
		    ftnlen)2, (ftnlen)256, (ftnlen)256, (ftnlen)256);
	    if (found) {

/*              We need to check whether we have enough space in our */
/*              string to append another file name to it. If we do, */
/*              we append it. Otherwise we report about it. */

		if (rtrim_(strn, (ftnlen)256) + rtrim_(pass3, (ftnlen)25000) <
			 25000) {
		    suffix_(strn, &c__1, pass3, (ftnlen)256, (ftnlen)25000);
		} else {
		    s_copy(hword, "No space in the file name buffer for the "
			    "name '#' obtained from the meta-kernel(s).", (
			    ftnlen)256, (ftnlen)83);
		    repmc_(hword, "#", strn, hword, (ftnlen)256, (ftnlen)1, (
			    ftnlen)256, (ftnlen)256);
		    tostdo_(hword, (ftnlen)256);
		}
	    }
	}
    }

/*     Check whether at least one CK file was provided. If not, */
/*     complain about it. */

    if (s_cmp(pass3, " ", (ftnlen)25000, (ftnlen)1) == 0) {
	tostdo_("No CK files were provided -- no summary will be displayed.", 
		(ftnlen)58);
	tostdo_(" ", (ftnlen)1);
	tostdo_("Run CKBRIEF without command line options to see program usa"
		"ge.", (ftnlen)62);
	tostdo_(" ", (ftnlen)1);
	s_stop("", (ftnlen)0);
    }

/*     Below is the main loop processing sequentially all CK-files those */
/*     names are stored in string PASS3. */

    start = 1;
    fndnwd_(pass3, &start, &beg, &end, (ftnlen)25000);
    while(beg != 0) {

/*        Open the next file. */

	dafopr_(pass3 + (beg - 1), &handle, end - (beg - 1));
	fndsum = FALSE_;
	dafbfs_(&handle);
	daffna_(&fnd);

/*        Initialize arrays to store summary data from CK-file segments */
/*        descriptors. These arrays will have the same size equal to */
/*        NOBJ: */

/*           IDA      contains IDs of object. */
/*           AVFA     contains AV flags. */
/*           FRAMEA   contains reference frame IDs */
/*           TYPEA    contains segment types */
/*           BADDRA   contains segment begin addresses */
/*           EADDRA   contains segment end addresses */
/*           TSTRTA   contains start time for the */
/*                    objects coverage. */
/*           TENDA    contains end time for the */
/*                    objects coverage. */

	nobj = 1;
	fulbuf = FALSE_;
	while(fnd) {
	    dafgs_(segsum);
	    dafus_(segsum, &c__2, &c__6, dc, ic);

/*           If we are summarizing from a list of input object, */
/*           find out if this object is in the list to summarize. */

	    if (numobj > 0) {
		if (isrchi_(ic, &numobj, objlis) > 0) {

/*                 We need to check whether we have space in the buffer. */
/*                 Note that we check against MAXBOD-1 because we will */
/*                 use the element IDA(MAXBOD) as loop terminator flag */
/*                 further in the program. */

		    if (nobj <= 99999) {
			fndsum = TRUE_;
			ida[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
				s_rnge("ida", i__1, "ckbrief_", (ftnlen)1154)]
				 = ic[0];
			framea[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 
				: s_rnge("framea", i__1, "ckbrief_", (ftnlen)
				1155)] = ic[1];
			typea[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 :
				 s_rnge("typea", i__1, "ckbrief_", (ftnlen)
				1156)] = ic[2];
			avfa[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
				s_rnge("avfa", i__1, "ckbrief_", (ftnlen)1157)
				] = ic[3];
			baddra[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 
				: s_rnge("baddra", i__1, "ckbrief_", (ftnlen)
				1158)] = ic[4];
			eaddra[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 
				: s_rnge("eaddra", i__1, "ckbrief_", (ftnlen)
				1159)] = ic[5];
			tstrta[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 
				: s_rnge("tstrta", i__1, "ckbrief_", (ftnlen)
				1160)] = dc[0];
			tenda[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 :
				 s_rnge("tenda", i__1, "ckbrief_", (ftnlen)
				1161)] = dc[1];
			++nobj;
		    } else {
			fulbuf = TRUE_;
		    }
		}
	    } else {

/*              Same as above -- check whether we have space in the */
/*              buffer. Note that we check against MAXBOD-1 because we */
/*              will use the element IDA(MAXBOD) as loop terminator */
/*              flag further in the program. */

		if (nobj <= 99999) {
		    fndsum = TRUE_;
		    ida[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("ida", i__1, "ckbrief_", (ftnlen)1185)] = 
			    ic[0];
		    framea[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("framea", i__1, "ckbrief_", (ftnlen)1186)] 
			    = ic[1];
		    typea[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("typea", i__1, "ckbrief_", (ftnlen)1187)] =
			     ic[2];
		    avfa[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("avfa", i__1, "ckbrief_", (ftnlen)1188)] = 
			    ic[3];
		    baddra[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("baddra", i__1, "ckbrief_", (ftnlen)1189)] 
			    = ic[4];
		    eaddra[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("eaddra", i__1, "ckbrief_", (ftnlen)1190)] 
			    = ic[5];
		    tstrta[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tstrta", i__1, "ckbrief_", (ftnlen)1191)] 
			    = dc[0];
		    tenda[(i__1 = nobj - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tenda", i__1, "ckbrief_", (ftnlen)1192)] =
			     dc[1];
		    ++nobj;
		} else {
		    fulbuf = TRUE_;
		}
	    }

/*           Go to the next segment */

	    daffna_(&fnd);
	}

/*        The NOBJ is currently greater that the number of collected */
/*        objects by one. We need to fix this. */

	--nobj;

/*        Display name of the file which we are summarizing now. */

	if (nobj != 0) {
	    tostdo_("  ", (ftnlen)2);
	    tostdo_("  ", (ftnlen)2);
/* Writing concatenation */
	    i__2[0] = 13, a__1[0] = "Summary for: ";
	    i__2[1] = end - (beg - 1), a__1[1] = pass3 + (beg - 1);
	    s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)25013);
	    tostdo_(ch__1, end - (beg - 1) + 13);

/*           Check whether we could have had buffer overflow and */
/*           collected only MAXBOD-1 summaries to prevent that. */

	    if (fulbuf) {
		if (numobj > 0) {
		    tostdo_(" ", (ftnlen)1);
		    s_copy(hword, "Number of segments containing data for th"
			    "e specified IDs was greater than", (ftnlen)256, (
			    ftnlen)73);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "the size of the internal buffer that hold"
			    "s segment descriptors. Therefore", (ftnlen)256, (
			    ftnlen)73);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "coverage for only # first segments for th"
			    "ese IDs from the file will be ", (ftnlen)256, (
			    ftnlen)71);
		    repmi_(hword, "#", &c__99999, hword, (ftnlen)256, (ftnlen)
			    1, (ftnlen)256);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "summarized.", (ftnlen)256, (ftnlen)11);
		    tostdo_(hword, (ftnlen)256);
		} else {
		    tostdo_(" ", (ftnlen)1);
		    s_copy(hword, "Number of segments in the file was greate"
			    "r than the size of the internal ", (ftnlen)256, (
			    ftnlen)73);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "buffer that holds segment descriptors. Th"
			    "erefore coverage for only # first ", (ftnlen)256, 
			    (ftnlen)75);
		    repmi_(hword, "#", &c__99999, hword, (ftnlen)256, (ftnlen)
			    1, (ftnlen)256);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "segments from the file will be summarized."
			    , (ftnlen)256, (ftnlen)42);
		    tostdo_(hword, (ftnlen)256);
		}
	    }
	}

/*        If we were asked to dump intervals, we have got everything */
/*        we need for displaying them. Otherwise, we have a lot of work */
/*        do. */

	if (idump) {

/*           All we need to do to dump intervals is to call Bills */
/*           ZZCKCRVs and copy output schedule to the buffers that */
/*           DISPSM expects. (BTW, if NOBJ is 0 this DO will never */
/*           DO :-) */

	    i__1 = nobj;
	    for (i__ = 1; i__ <= i__1; ++i__) {

/*              Diplay segment order number. */

		s_copy(hword, "Segment No.: #", (ftnlen)256, (ftnlen)14);
		repmi_(hword, "#", &i__, hword, (ftnlen)256, (ftnlen)1, (
			ftnlen)256);
		tostdo_("  ", (ftnlen)2);
		tostdo_(hword, (ftnlen)256);

/*              Does looking for interval for a segment of this */
/*              type make sense? */

		if (typea[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? i__3 : 
			s_rnge("typea", i__3, "ckbrief_", (ftnlen)1295)] == 2 
			|| typea[(i__4 = i__ - 1) < 100000 && 0 <= i__4 ? 
			i__4 : s_rnge("typea", i__4, "ckbrief_", (ftnlen)1295)
			] == 3 || typea[(i__5 = i__ - 1) < 100000 && 0 <= 
			i__5 ? i__5 : s_rnge("typea", i__5, "ckbrief_", (
			ftnlen)1295)] == 4 || typea[(i__6 = i__ - 1) < 100000 
			&& 0 <= i__6 ? i__6 : s_rnge("typea", i__6, "ckbrief_"
			, (ftnlen)1295)] == 5) {

/*                 Sure does! Initialize window and call corresponding */
/*                 ZZCKCRVx depending on what type the segment is. */

		    ssized_(&c_b284, wind);
		    if (typea[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? i__3 : 
			    s_rnge("typea", i__3, "ckbrief_", (ftnlen)1306)] 
			    == 2) {
			zzckcvr2_(&handle, &baddra[(i__3 = i__ - 1) < 100000 
				&& 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1308)], &eaddra[(i__4 = 
				i__ - 1) < 100000 && 0 <= i__4 ? i__4 : 
				s_rnge("eaddra", i__4, "ckbrief_", (ftnlen)
				1308)], wind);
		    } else if (typea[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? 
			    i__3 : s_rnge("typea", i__3, "ckbrief_", (ftnlen)
			    1310)] == 3) {
			zzckcvr3_(&handle, &baddra[(i__3 = i__ - 1) < 100000 
				&& 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1312)], &eaddra[(i__4 = 
				i__ - 1) < 100000 && 0 <= i__4 ? i__4 : 
				s_rnge("eaddra", i__4, "ckbrief_", (ftnlen)
				1312)], wind);
		    } else if (typea[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? 
			    i__3 : s_rnge("typea", i__3, "ckbrief_", (ftnlen)
			    1314)] == 4) {
			zzckcvr4_(&handle, &baddra[(i__3 = i__ - 1) < 100000 
				&& 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1316)], &eaddra[(i__4 = 
				i__ - 1) < 100000 && 0 <= i__4 ? i__4 : 
				s_rnge("eaddra", i__4, "ckbrief_", (ftnlen)
				1316)], wind);
		    } else if (typea[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? 
			    i__3 : s_rnge("typea", i__3, "ckbrief_", (ftnlen)
			    1318)] == 5) {
			zzckcvr5_(&handle, &baddra[(i__3 = i__ - 1) < 100000 
				&& 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1320)], &eaddra[(i__4 = 
				i__ - 1) < 100000 && 0 <= i__4 ? i__4 : 
				s_rnge("eaddra", i__4, "ckbrief_", (ftnlen)
				1320)], wind);
		    }

/*                 We fill have got a schedule for this segment. Copy */
/*                 it to buffers and call DISPSM. */

		    if (cardd_(wind) != 0) {
			nobgs = cardd_(wind) / 2;
			i__3 = nobgs - 1;
			for (l = 0; l <= i__3; ++l) {
			    ids[(i__4 = l) < 100000 && 0 <= i__4 ? i__4 : 
				    s_rnge("ids", i__4, "ckbrief_", (ftnlen)
				    1333)] = ida[(i__5 = i__ - 1) < 100000 && 
				    0 <= i__5 ? i__5 : s_rnge("ida", i__5, 
				    "ckbrief_", (ftnlen)1333)];
			    tstrts[(i__4 = l) < 100000 && 0 <= i__4 ? i__4 : 
				    s_rnge("tstrts", i__4, "ckbrief_", (
				    ftnlen)1334)] = wind[(i__5 = (l << 1) + 6)
				     < 200006 && 0 <= i__5 ? i__5 : s_rnge(
				    "wind", i__5, "ckbrief_", (ftnlen)1334)];
			    tends[(i__4 = l) < 100000 && 0 <= i__4 ? i__4 : 
				    s_rnge("tends", i__4, "ckbrief_", (ftnlen)
				    1335)] = wind[(i__5 = (l << 1) + 7) < 
				    200006 && 0 <= i__5 ? i__5 : s_rnge("wind"
				    , i__5, "ckbrief_", (ftnlen)1335)];
			    avfs[(i__4 = l) < 100000 && 0 <= i__4 ? i__4 : 
				    s_rnge("avfs", i__4, "ckbrief_", (ftnlen)
				    1336)] = avfa[(i__5 = i__ - 1) < 100000 &&
				     0 <= i__5 ? i__5 : s_rnge("avfa", i__5, 
				    "ckbrief_", (ftnlen)1336)];
			    frames[(i__4 = l) < 100000 && 0 <= i__4 ? i__4 : 
				    s_rnge("frames", i__4, "ckbrief_", (
				    ftnlen)1337)] = framea[(i__5 = i__ - 1) < 
				    100000 && 0 <= i__5 ? i__5 : s_rnge("fra"
				    "mea", i__5, "ckbrief_", (ftnlen)1337)];
			}
			dispsm_(&nobgs, ids, tstrts, tends, avfs, frames, 
				tout, &fdsp, &tdsp, &gdsp, (ftnlen)256);
		    }
		} else {

/*                 Well, this segment is not eligible for having */
/*                 intervals. Tell user about it. */

		    s_copy(hword, "This segment is a type # segment for whic"
			    "h interpolation is not supported.", (ftnlen)256, (
			    ftnlen)74);
		    repmi_(hword, "#", &typea[(i__3 = i__ - 1) < 100000 && 0 
			    <= i__3 ? i__3 : s_rnge("typea", i__3, "ckbrief_",
			     (ftnlen)1353)], hword, (ftnlen)256, (ftnlen)1, (
			    ftnlen)256);
		    tostdo_("  ", (ftnlen)2);
		    tostdo_(hword, (ftnlen)256);
		}
	    }
	} else {

/*           We are here because we weren't asked to do interval dump */
/*           but were rather asked to do something intelligent (that */
/*           intelligent work is what CKRBIEF was written to do :-) */

/*           Data from all segment descriptors in the current file are */
/*           stored in arrays. Now it will be distributed to two */
/*           different groups of arrays. */

/*           First group - for objects which have multiple coverage */
/*           intervals in current CK-file. */

/*           Second group - for objects which have single coverage */
/*           interval in current CK-file. */

/*           This distribution is done to provide a possibility to merge */
/*           time intervals for a particular object if intervals */
/*           overlap. */

/*           Initialization of array pointers */

	    nobgs = 1;
	    nobgo = 1;
	    i__ = 1;

/*           Now we set IDA(NOBJ+1) to 0 we can safely do that because */
/*           we checked against MAXBOD-1 in the loop filling the */
/*           buffers. */

	    ida[(i__1 = nobj) < 100000 && 0 <= i__1 ? i__1 : s_rnge("ida", 
		    i__1, "ckbrief_", (ftnlen)1393)] = 0;

/*           Here is the cycle to get through all descriptors to */
/*           distribute them to two arrays. */

	    while(fndsum && i__ <= nobj) {

/*              Skip all records with IDs set to zero -- these were */
/*              already taken into account. */

		while(ida[(i__1 = i__ - 1) < 100000 && 0 <= i__1 ? i__1 : 
			s_rnge("ida", i__1, "ckbrief_", (ftnlen)1405)] == 0 &&
			 i__ <= nobj) {
		    ++i__;
		}
		if (i__ <= nobj) {

/*                 Current segment is the first segment found for this */
/*                 ID in the buffer. Set counter of segments for current */
/*                 ID to 1 and copy complete summary for current segment */
/*                 to IDO, etc. buffers. */

		    cnt = 1;
		    ido[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("ido", i__1, "ckbrief_", (ftnlen)1419)] = 
			    ida[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? i__3 
			    : s_rnge("ida", i__3, "ckbrief_", (ftnlen)1419)];
		    avfo[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("avfo", i__1, "ckbrief_", (ftnlen)1420)] = 
			    avfa[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? 
			    i__3 : s_rnge("avfa", i__3, "ckbrief_", (ftnlen)
			    1420)];
		    frameo[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("frameo", i__1, "ckbrief_", (ftnlen)1421)] 
			    = framea[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? 
			    i__3 : s_rnge("framea", i__3, "ckbrief_", (ftnlen)
			    1421)];
		    tstrto[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tstrto", i__1, "ckbrief_", (ftnlen)1422)] 
			    = tstrta[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? 
			    i__3 : s_rnge("tstrta", i__3, "ckbrief_", (ftnlen)
			    1422)];
		    tendo[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tendo", i__1, "ckbrief_", (ftnlen)1423)] =
			     tenda[(i__3 = i__ - 1) < 100000 && 0 <= i__3 ? 
			    i__3 : s_rnge("tenda", i__3, "ckbrief_", (ftnlen)
			    1423)];

/*                 Increase counter of segments for current ID and */
/*                 "mark" current segment as "processed" in IDA buffer */
/*                 by setting its IDA to zero. */

		    ++nobgo;
		    ida[(i__1 = i__ - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("ida", i__1, "ckbrief_", (ftnlen)1431)] = 
			    0;

/*                 Loop to find all segments with the same ID in the IDA */
/*                 buffer. */

		    i__4 = nobj - i__;
		    loc = isrchi_(&ido[(i__1 = nobgo - 2) < 100000 && 0 <= 
			    i__1 ? i__1 : s_rnge("ido", i__1, "ckbrief_", (
			    ftnlen)1437)], &i__4, &ida[(i__3 = i__) < 100000 
			    && 0 <= i__3 ? i__3 : s_rnge("ida", i__3, "ckbri"
			    "ef_", (ftnlen)1437)]);
		    k = loc + i__;
		    while(loc != 0) {

/*                    We found one more -- increase counter, save */
/*                    summary in IDO, etc. array and reset its IDS to 0. */

			++cnt;
			ido[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 : 
				s_rnge("ido", i__1, "ckbrief_", (ftnlen)1448)]
				 = ida[(i__3 = k - 1) < 100000 && 0 <= i__3 ? 
				i__3 : s_rnge("ida", i__3, "ckbrief_", (
				ftnlen)1448)];
			avfo[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 :
				 s_rnge("avfo", i__1, "ckbrief_", (ftnlen)
				1449)] = avfa[(i__3 = k - 1) < 100000 && 0 <= 
				i__3 ? i__3 : s_rnge("avfa", i__3, "ckbrief_",
				 (ftnlen)1449)];
			frameo[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? 
				i__1 : s_rnge("frameo", i__1, "ckbrief_", (
				ftnlen)1450)] = framea[(i__3 = k - 1) < 
				100000 && 0 <= i__3 ? i__3 : s_rnge("framea", 
				i__3, "ckbrief_", (ftnlen)1450)];
			tstrto[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? 
				i__1 : s_rnge("tstrto", i__1, "ckbrief_", (
				ftnlen)1451)] = tstrta[(i__3 = k - 1) < 
				100000 && 0 <= i__3 ? i__3 : s_rnge("tstrta", 
				i__3, "ckbrief_", (ftnlen)1451)];
			tendo[(i__1 = nobgo - 1) < 100000 && 0 <= i__1 ? i__1 
				: s_rnge("tendo", i__1, "ckbrief_", (ftnlen)
				1452)] = tenda[(i__3 = k - 1) < 100000 && 0 <=
				 i__3 ? i__3 : s_rnge("tenda", i__3, "ckbrie"
				"f_", (ftnlen)1452)];
			++nobgo;
			ida[(i__1 = k - 1) < 100000 && 0 <= i__1 ? i__1 : 
				s_rnge("ida", i__1, "ckbrief_", (ftnlen)1455)]
				 = 0;
			i__4 = nobj - k;
			loc = isrchi_(&ido[(i__1 = nobgo - 2) < 100000 && 0 <=
				 i__1 ? i__1 : s_rnge("ido", i__1, "ckbrief_",
				 (ftnlen)1457)], &i__4, &ida[(i__3 = k) < 
				100000 && 0 <= i__3 ? i__3 : s_rnge("ida", 
				i__3, "ckbrief_", (ftnlen)1457)]);
			k += loc;
		    }

/*                 Did we find more than one segment for current ID? */

		    if (cnt == 1) {

/*                    No, we didn't. Then we include this segment into */
/*                    IDS buffer. But first we reset NOBGO back to */
/*                    remove it from IDO buffer. */

			--nobgo;
			ids[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? i__1 : 
				s_rnge("ids", i__1, "ckbrief_", (ftnlen)1473)]
				 = ido[(i__3 = nobgo - 1) < 100000 && 0 <= 
				i__3 ? i__3 : s_rnge("ido", i__3, "ckbrief_", 
				(ftnlen)1473)];
			avfs[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? i__1 :
				 s_rnge("avfs", i__1, "ckbrief_", (ftnlen)
				1474)] = avfo[(i__3 = nobgo - 1) < 100000 && 
				0 <= i__3 ? i__3 : s_rnge("avfo", i__3, "ckb"
				"rief_", (ftnlen)1474)];
			frames[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? 
				i__1 : s_rnge("frames", i__1, "ckbrief_", (
				ftnlen)1475)] = frameo[(i__3 = nobgo - 1) < 
				100000 && 0 <= i__3 ? i__3 : s_rnge("frameo", 
				i__3, "ckbrief_", (ftnlen)1475)];
			tstrts[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? 
				i__1 : s_rnge("tstrts", i__1, "ckbrief_", (
				ftnlen)1476)] = tstrto[(i__3 = nobgo - 1) < 
				100000 && 0 <= i__3 ? i__3 : s_rnge("tstrto", 
				i__3, "ckbrief_", (ftnlen)1476)];
			tends[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? i__1 
				: s_rnge("tends", i__1, "ckbrief_", (ftnlen)
				1477)] = tendo[(i__3 = nobgo - 1) < 100000 && 
				0 <= i__3 ? i__3 : s_rnge("tendo", i__3, 
				"ckbrief_", (ftnlen)1477)];
			++nobgs;
		    }
		}
	    }
	    --nobgo;

/*           At this point we have two buffers -- xxxO and xxxS -- */
/*           filled with appropriate segment descriptors. There is no */
/*           need to do any more processing for xxxS buffer. But there */
/*           is work to be done on xxxO buffer: we need to merge */
/*           overlapping time intervals for each ID. */

	    if (nobgo > 1) {
		i__ = 1;
		k = 1;
		while(i__ <= nobgo - 1) {

/*                 All segments for the same ID are already grouped */
/*                 together. We need to find out what is the first and */
/*                 last of them */

		    while(ido[(i__1 = i__ - 1) < 100000 && 0 <= i__1 ? i__1 : 
			    s_rnge("ido", i__1, "ckbrief_", (ftnlen)1508)] == 
			    ido[(i__3 = k - 1) < 100000 && 0 <= i__3 ? i__3 : 
			    s_rnge("ido", i__3, "ckbrief_", (ftnlen)1508)] && 
			    k <= nobgo) {
			++k;
		    }

/*                 After we know it, we copy start and stop times to */
/*                 a WINDOW array. */

		    ssized_(&c_b284, wind);
		    i__1 = k - i__ << 1;
		    scardd_(&i__1, wind);
		    i__1 = k - i__ - 1;
		    for (l = 0; l <= i__1; ++l) {
			wind[(i__3 = (l << 1) + 6) < 200006 && 0 <= i__3 ? 
				i__3 : s_rnge("wind", i__3, "ckbrief_", (
				ftnlen)1520)] = tstrto[(i__4 = l + i__ - 1) < 
				100000 && 0 <= i__4 ? i__4 : s_rnge("tstrto", 
				i__4, "ckbrief_", (ftnlen)1520)];
			wind[(i__3 = (l << 1) + 7) < 200006 && 0 <= i__3 ? 
				i__3 : s_rnge("wind", i__3, "ckbrief_", (
				ftnlen)1521)] = tendo[(i__4 = l + i__ - 1) < 
				100000 && 0 <= i__4 ? i__4 : s_rnge("tendo", 
				i__4, "ckbrief_", (ftnlen)1521)];
		    }

/*                 Here is important point of algorithm. We'll validate */
/*                 window of time intervals. But we do it only if NOMERG */
/*                 flag is not set. */

		    if (! nomerg) {
			i__1 = k - i__ << 1;
			wnvald_(&c_b284, &i__1, wind);
		    }

/*                 Now we can check whether our window validating */
/*                 brought any results. */

		    if (cardd_(wind) == k - i__ << 1) {

/*                    Nothing happened with our windows. Well, the best */
/*                    we can do then is to order coverages for this ID */
/*                    by start time (and this order in xxxO all arrays.) */

			i__3 = k - i__;
			orderd_(&tstrto[(i__1 = i__ - 1) < 100000 && 0 <= 
				i__1 ? i__1 : s_rnge("tstrto", i__1, "ckbrie"
				"f_", (ftnlen)1544)], &i__3, iorder);
			i__3 = k - i__;
			reordd_(iorder, &i__3, &tstrto[(i__1 = i__ - 1) < 
				100000 && 0 <= i__1 ? i__1 : s_rnge("tstrto", 
				i__1, "ckbrief_", (ftnlen)1546)]);
			i__3 = k - i__;
			reordd_(iorder, &i__3, &tendo[(i__1 = i__ - 1) < 
				100000 && 0 <= i__1 ? i__1 : s_rnge("tendo", 
				i__1, "ckbrief_", (ftnlen)1547)]);
			i__3 = k - i__;
			reordi_(iorder, &i__3, &avfo[(i__1 = i__ - 1) < 
				100000 && 0 <= i__1 ? i__1 : s_rnge("avfo", 
				i__1, "ckbrief_", (ftnlen)1548)]);
			i__3 = k - i__;
			reordi_(iorder, &i__3, &frameo[(i__1 = i__ - 1) < 
				100000 && 0 <= i__1 ? i__1 : s_rnge("frameo", 
				i__1, "ckbrief_", (ftnlen)1549)]);

/*                    Now we can copy sorted data back to xxxS buffer. */

			i__4 = k - i__;
			movei_(&ido[(i__1 = i__ - 1) < 100000 && 0 <= i__1 ? 
				i__1 : s_rnge("ido", i__1, "ckbrief_", (
				ftnlen)1554)], &i__4, &ids[(i__3 = nobgs - 1) 
				< 100000 && 0 <= i__3 ? i__3 : s_rnge("ids", 
				i__3, "ckbrief_", (ftnlen)1554)]);
			i__4 = k - i__;
			moved_(&tstrto[(i__1 = i__ - 1) < 100000 && 0 <= i__1 
				? i__1 : s_rnge("tstrto", i__1, "ckbrief_", (
				ftnlen)1555)], &i__4, &tstrts[(i__3 = nobgs - 
				1) < 100000 && 0 <= i__3 ? i__3 : s_rnge(
				"tstrts", i__3, "ckbrief_", (ftnlen)1555)]);
			i__4 = k - i__;
			moved_(&tendo[(i__1 = i__ - 1) < 100000 && 0 <= i__1 ?
				 i__1 : s_rnge("tendo", i__1, "ckbrief_", (
				ftnlen)1556)], &i__4, &tends[(i__3 = nobgs - 
				1) < 100000 && 0 <= i__3 ? i__3 : s_rnge(
				"tends", i__3, "ckbrief_", (ftnlen)1556)]);
			i__4 = k - i__;
			movei_(&avfo[(i__1 = i__ - 1) < 100000 && 0 <= i__1 ? 
				i__1 : s_rnge("avfo", i__1, "ckbrief_", (
				ftnlen)1557)], &i__4, &avfs[(i__3 = nobgs - 1)
				 < 100000 && 0 <= i__3 ? i__3 : s_rnge("avfs",
				 i__3, "ckbrief_", (ftnlen)1557)]);
			i__4 = k - i__;
			movei_(&frameo[(i__1 = i__ - 1) < 100000 && 0 <= i__1 
				? i__1 : s_rnge("frameo", i__1, "ckbrief_", (
				ftnlen)1558)], &i__4, &frames[(i__3 = nobgs - 
				1) < 100000 && 0 <= i__3 ? i__3 : s_rnge(
				"frames", i__3, "ckbrief_", (ftnlen)1558)]);
			nobgs = nobgs + k - i__;
		    } else {

/*                    Some of the windows got merged. It means that by */
/*                    validating we broke connection between them and */
/*                    AVFS and FRAMES for the original segments. And */
/*                    what if original segments used in window */
/*                    validating had a different AV flags of were */
/*                    relative to different frames? We have to check */
/*                    that and assign right values to indicate this -- */
/*                    set AVS to 2 and FRAMES to 0. */

			mixdav = FALSE_;
			mixdfr = FALSE_;
			l = i__;
			while(l < k - 1) {
			    if (avfo[(i__1 = l - 1) < 100000 && 0 <= i__1 ? 
				    i__1 : s_rnge("avfo", i__1, "ckbrief_", (
				    ftnlen)1579)] != avfo[(i__3 = l) < 100000 
				    && 0 <= i__3 ? i__3 : s_rnge("avfo", i__3,
				     "ckbrief_", (ftnlen)1579)]) {
				mixdav = TRUE_;
			    }
			    if (frameo[(i__1 = l - 1) < 100000 && 0 <= i__1 ? 
				    i__1 : s_rnge("frameo", i__1, "ckbrief_", 
				    (ftnlen)1583)] != frameo[(i__3 = l) < 
				    100000 && 0 <= i__3 ? i__3 : s_rnge("fra"
				    "meo", i__3, "ckbrief_", (ftnlen)1583)]) {
				mixdfr = TRUE_;
			    }
			    ++l;
			}

/*                    If we had mixed AV flags, we set all AVFO to 2. */

			if (mixdav) {
			    i__1 = k - 1;
			    for (l = i__; l <= i__1; ++l) {
				avfo[(i__3 = l - 1) < 100000 && 0 <= i__3 ? 
					i__3 : s_rnge("avfo", i__3, "ckbrief_"
					, (ftnlen)1596)] = 2;
			    }
			}

/*                    If we had mixed reference frames, we set all */
/*                    FRAMEO to 0. */

			if (mixdfr) {
			    i__1 = k - 1;
			    for (l = i__; l <= i__1; ++l) {
				frameo[(i__3 = l - 1) < 100000 && 0 <= i__3 ? 
					i__3 : s_rnge("frameo", i__3, "ckbri"
					"ef_", (ftnlen)1606)] = 0;
			    }
			}

/*                    What if after validation we have only 1 time */
/*                    interval? Then data for the object have to be */
/*                    moved from array for multiple intervals to array */
/*                    for single intervals. */

			if (cardd_(wind) == 2) {

/*                       Copy summaries to IDS, etc. arrays. */

			    ids[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? 
				    i__1 : s_rnge("ids", i__1, "ckbrief_", (
				    ftnlen)1621)] = ido[(i__3 = i__ - 1) < 
				    100000 && 0 <= i__3 ? i__3 : s_rnge("ido",
				     i__3, "ckbrief_", (ftnlen)1621)];
			    avfs[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? 
				    i__1 : s_rnge("avfs", i__1, "ckbrief_", (
				    ftnlen)1622)] = avfo[(i__3 = i__ - 1) < 
				    100000 && 0 <= i__3 ? i__3 : s_rnge("avfo"
				    , i__3, "ckbrief_", (ftnlen)1622)];
			    frames[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? 
				    i__1 : s_rnge("frames", i__1, "ckbrief_", 
				    (ftnlen)1623)] = frameo[(i__3 = i__ - 1) <
				     100000 && 0 <= i__3 ? i__3 : s_rnge(
				    "frameo", i__3, "ckbrief_", (ftnlen)1623)]
				    ;
			    tstrts[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? 
				    i__1 : s_rnge("tstrts", i__1, "ckbrief_", 
				    (ftnlen)1624)] = wind[6];
			    tends[(i__1 = nobgs - 1) < 100000 && 0 <= i__1 ? 
				    i__1 : s_rnge("tends", i__1, "ckbrief_", (
				    ftnlen)1625)] = wind[7];

/*                       Increment number of elements in AVS, etc. */
/*                       arrays. */

			    ++nobgs;
			} else {

/*                       It looks like we have more than one interval. */

			    i__1 = cardd_(wind) / 2 - 1;
			    for (l = 0; l <= i__1; ++l) {
				temps[(i__3 = l) < 100000 && 0 <= i__3 ? i__3 
					: s_rnge("temps", i__3, "ckbrief_", (
					ftnlen)1639)] = wind[(i__4 = (l << 1) 
					+ 6) < 200006 && 0 <= i__4 ? i__4 : 
					s_rnge("wind", i__4, "ckbrief_", (
					ftnlen)1639)];
				tempe[(i__3 = l) < 100000 && 0 <= i__3 ? i__3 
					: s_rnge("tempe", i__3, "ckbrief_", (
					ftnlen)1640)] = wind[(i__4 = (l << 1) 
					+ 7) < 200006 && 0 <= i__4 ? i__4 : 
					s_rnge("wind", i__4, "ckbrief_", (
					ftnlen)1640)];
			    }
			    l = cardd_(wind) / 2;

/*                       Copy objects with multiple time intervals to */
/*                       xxxS buffer. */

			    movei_(&ido[(i__1 = i__ - 1) < 100000 && 0 <= 
				    i__1 ? i__1 : s_rnge("ido", i__1, "ckbri"
				    "ef_", (ftnlen)1648)], &l, &ids[(i__3 = 
				    nobgs - 1) < 100000 && 0 <= i__3 ? i__3 : 
				    s_rnge("ids", i__3, "ckbrief_", (ftnlen)
				    1648)]);
			    moved_(temps, &l, &tstrts[(i__1 = nobgs - 1) < 
				    100000 && 0 <= i__1 ? i__1 : s_rnge("tst"
				    "rts", i__1, "ckbrief_", (ftnlen)1649)]);
			    moved_(tempe, &l, &tends[(i__1 = nobgs - 1) < 
				    100000 && 0 <= i__1 ? i__1 : s_rnge("ten"
				    "ds", i__1, "ckbrief_", (ftnlen)1650)]);
			    movei_(&avfo[(i__1 = i__ - 1) < 100000 && 0 <= 
				    i__1 ? i__1 : s_rnge("avfo", i__1, "ckbr"
				    "ief_", (ftnlen)1651)], &l, &avfs[(i__3 = 
				    nobgs - 1) < 100000 && 0 <= i__3 ? i__3 : 
				    s_rnge("avfs", i__3, "ckbrief_", (ftnlen)
				    1651)]);
			    movei_(&frameo[(i__1 = i__ - 1) < 100000 && 0 <= 
				    i__1 ? i__1 : s_rnge("frameo", i__1, 
				    "ckbrief_", (ftnlen)1652)], &l, &frames[(
				    i__3 = nobgs - 1) < 100000 && 0 <= i__3 ? 
				    i__3 : s_rnge("frames", i__3, "ckbrief_", 
				    (ftnlen)1652)]);
			    nobgs += l;
			}
		    }

/*                 We are done with current ID. Lets move to the next */
/*                 one. */

		    i__ = k;
		}
	    }

/*           OK, we are done with processing of the xxxO buffer. All */
/*           data sorted/merged and stored in a single buffer -- xxxS. */
/*           Lets display summary then .... */

	    --nobgs;
	    if (nobgs != 0) {
		dispsm_(&nobgs, ids, tstrts, tends, avfs, frames, tout, &fdsp,
			 &tdsp, &gdsp, (ftnlen)256);
	    }
	}

/*        Current CK-file processing is over - close it and move on to */
/*        the next file. */

	dafcls_(&handle);
	start = end + 1;
	fndnwd_(pass3, &start, &beg, &end, (ftnlen)25000);
    }

/*     Add one more blank line at the end of the summary report. */

    tostdo_(" ", (ftnlen)1);

/*     Check out. */

    chkout_("CKBRIEF", (ftnlen)7);

/*     Return with success status. */

    byebye_("SUCCESS", (ftnlen)7);
    s_stop("", (ftnlen)0);
    return 0;
} /* MAIN__ */

/* Main program alias */ int ckbrief_ () { MAIN__ (); return 0; }
