/* ckbrief.f -- translated by f2c (version 19980913).
   You must link the resulting object file with the libraries:
	-lf2c -lm   (in that order)
*/

#include "f2c.h"

/* Table of constant values */

static integer c__1 = 1;
static integer c__2 = 2;
static integer c__6 = 6;
static integer c__9999 = 9999;
static integer c__20000 = 20000;

/* $Program    CKBRIEF ( BRIEF CK summary ) */

/* Main program */ MAIN__(void)
{
    /* System generated locals */
    address a__1[2];
    integer i__1, i__2[2], i__3, i__4, i__5, i__6;
    char ch__1[4013];

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer s_rnge(char *, integer, char *, integer);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    integer avfa[10000];
    char arch[3], line[256];
    logical help;
    integer nobj, avfo[10000];
    logical fdsp, gdsp;
    integer avfs[10000];
    extern /* Subroutine */ int zzckcvr2_(integer *, integer *, integer *, 
	    doublereal *);
    doublereal wind[20006];
    extern /* Subroutine */ int zzckcvr3_(integer *, integer *, integer *, 
	    doublereal *), zzckcvr4_(integer *, integer *, integer *, 
	    doublereal *), zzckcvr5_(integer *, integer *, integer *, 
	    doublereal *);
    logical tdsp;
    char type__[3], text[256*102], strn[256];
    logical vrsn;
    char tout[256], pass1[4000], pass2[4000], pass3[4000];
    integer i__, k, l;
    extern integer cardd_(doublereal *);
    extern /* Subroutine */ int dafgs_(doublereal *);
    doublereal tenda[10000];
    logical obnam;
    extern logical beint_(char *, ftnlen);
    logical sfile;
    integer nobgo;
    extern /* Subroutine */ int rdnbl_(char *, char *, logical *, ftnlen, 
	    ftnlen), repmc_(char *, char *, char *, char *, ftnlen, ftnlen, 
	    ftnlen, ftnlen), dafus_(doublereal *, integer *, integer *, 
	    doublereal *, integer *);
    integer nobgs;
    doublereal tendo[10000], tempe[10000];
    integer value;
    doublereal tends[10000];
    logical idump;
    extern /* Subroutine */ int repmi_(char *, char *, integer *, char *, 
	    ftnlen, ftnlen, ftnlen), movei_(integer *, integer *, integer *);
    integer typea[10000];
    char hword[256];
    extern /* Subroutine */ int moved_(doublereal *, integer *, doublereal *);
    doublereal temps[10000];
    char error[256];
    extern integer rtrim_(char *, ftnlen);
    integer start;
    doublereal dc[2];
    integer ic[6], baddra[10000];
    extern /* Subroutine */ int daffna_(logical *);
    integer eaddra[10000];
    extern /* Subroutine */ int dafbfs_(integer *);
    integer handle, framea[10000];
    extern /* Subroutine */ int dafcls_(integer *), scardd_(integer *, 
	    doublereal *);
    logical havfil;
    integer frameo[10000];
    extern /* Subroutine */ int getcml_(char *, ftnlen);
    integer frames[10000];
    extern /* Subroutine */ int getfat_(char *, char *, char *, ftnlen, 
	    ftnlen, ftnlen), inslai_(integer *, integer *, integer *, integer 
	    *, integer *);
    extern integer isrchi_(integer *, integer *, integer *);
    char srcfil[256];
    integer iorder[10000], objlis[100];
    logical fulbuf, nomerg, fndsum;
    integer numobj;
    logical mixdav, mixdfr;
    extern /* Subroutine */ int fndnwd_(char *, integer *, integer *, integer 
	    *, ftnlen);
    doublereal segsum[5];
    extern /* Subroutine */ int suffix_(char *, integer *, char *, ftnlen, 
	    ftnlen), nparsi_(char *, integer *, char *, integer *, ftnlen, 
	    ftnlen), ldpool_(char *, ftnlen), dafopr_(char *, integer *, 
	    ftnlen), tostdo_(char *, ftnlen), ssized_(integer *, doublereal *)
	    , dispsm_(integer *, integer *, doublereal *, doublereal *, 
	    integer *, integer *, char *, logical *, logical *, logical *, 
	    ftnlen), wnvald_(integer *, integer *, doublereal *), orderd_(
	    doublereal *, integer *, integer *);
    doublereal tstrta[10000];
    extern /* Subroutine */ int reordd_(integer *, integer *, doublereal *), 
	    reordi_(integer *, integer *, integer *), byebye_(char *, ftnlen),
	     tkvrsn_(char *, char *, ftnlen, ftnlen);
    doublereal tstrto[10000], tstrts[10000];
    integer beg, ida[10000], end;
    logical fnd, eof;
    integer ido[10000], loc, ids[10000], cnt, ptr;


/* $ Abstract */

/*     CKBRIEF is a utility program that provides brief summaries of */
/*     the contents of one or more CK files. */

/* $ Disclaimer */

/*     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE */
/*     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S. */
/*     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE */
/*     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE */
/*     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS" */
/*     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY */
/*     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A */
/*     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC */
/*     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE */
/*     SOFTWARE AND RELATED MATERIALS, HOWEVER USED. */

/*     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA */
/*     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT */
/*     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND, */
/*     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS, */
/*     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE */
/*     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY. */

/*     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF */
/*     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY */
/*     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE */
/*     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE. */

/* $ Required_Reading */

/*     CKBRIEF User's Guide. */

/* $ Keywords */

/*     FILES */
/*     UTILITY */

/* $ Parameters */

/*     None. */

/* $ Exceptions */

/*     None. */

/* $ Files */

/*     1) All summary tasks performed require name for at least one */
/*        CK file to be provided. */

/*     2) To display time tags in any format (except DP SCLK), LSK */
/*        and appropriate SCLK files must be provided. */

/* $ Particulars */

/*     For usage details see User's Guide. */

/* $ Examples */

/*     None. */

/* $ Restrictions */

/*     None. */

/* $ Literature_References */

/*     None. */

/* $ Author_and_Institution */

/*     Y.K. Zaiko     (BERC) */
/*     B.V. Semenov   (NAIF) */
/*     F.S. Turner    (JPL) */

/* $ Version */

/* -    Toolkit Version 3.1.0, 08-NOV-2005 (BVS) */

/*        Updated usage display to describe what kind of summary */
/*        is generated by default. */

/* -    Toolkit Version 3.0.0, 28-AUG-2002 (FST) */

/*        Added support for the -dump option for type 4 and 5 CK */
/*        segments. */

/*        Modified ZZCKCVR3 calling sequence to agree with changes */
/*        as delivered to support. */

/* -    Toolkit Version 2.0.0, 15-MAY-2001 (BVS) */

/*        Added option to dump interpolation interval information */
/*        from type 2 & 3 CK segments. */

/* -    Toolkit Version 1.1.2, 09-APR-2001 (BVS) */

/*        Fixed usage display and User's Guide. */

/* -    Toolkit Version 1.1.1, 03-NOV-2000 (EDW) */

/*        Added a BYEBYE( 'SUCCESS' ) call at program's end. */

/* -    Toolkit Version 1.1.0, 14-OCT-1999 (WLT) */

/*        Commented out EXTERNALS in source code.  See note in the */
/*        code for details. */

/* -    Toolkit Version 1.0.0, 26-Mar-1999 (WLT) */

/*        Added code to skip attempting to load binary kernels into */
/*        the kernel pool. */

/* -    Beta Version 1.0.0,  24-MAR-1999  ( YKZ ) ( BVS ) */

/*        See CKBRIEF.INC for version information. */

/* -& */

/*     User adjustable parameters. */


/*     Passed Functions */

/*     The lines below have been commented out as they do not appear */
/*     to be needed for anything.  BIGGER and INC are not referenced */
/*     anywhwere else in this file.  (WLT) 14-OCT-1999 */

/*      EXTERNAL              BIGGER */
/*      EXTERNAL              INC */

/*     SPICELIB Functions */

/* $ Disclaimer */

/*     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE */
/*     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S. */
/*     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE */
/*     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE */
/*     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS" */
/*     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY */
/*     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A */
/*     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC */
/*     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE */
/*     SOFTWARE AND RELATED MATERIALS, HOWEVER USED. */

/*     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA */
/*     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT */
/*     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND, */
/*     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS, */
/*     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE */
/*     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY. */

/*     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF */
/*     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY */
/*     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE */
/*     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE. */

/* $ Author_and_Institution */

/*     Y.K. Zaiko     (BERC) */
/*     B.V. Semenov   (NAIF) */

/* $ Version */

/* -    CKBRIEF Version 3.1.0, 2005-11-08 (BVS) */

/*        Updated version string. */

/* -    CKBRIEF Version 2.0.0, 2001-05-16 (BVS) */

/*        Increased MAXBOD to 10000 (from 4000). Set LRGWIN to be */
/*        MAXBOD*2 (was MAXBOD). Changed version string. */

/* -    CKBRIEF Version 1.1.2, 2001-04-09 (BVS) */

/*        Changed version parameter. */

/* -    CKBRIEF Version 1.0.0 beta, 1999-02-17 (YKZ)(BVS) */

/*        Initial release. */

/* -& */

/*     The Version is stored as a string. */


/*     The maximum number of segments or interpolation intervals */
/*     that can be summarized is stored in the parameter MAXBOD. */
/*     This is THE LIMIT that should be increased in window */
/*     routines called by CKBRIEF fail. */


/*     The largest expected window -- must be twice the size of */
/*     MAXBOD for consistency. */


/*     The longest command line that can be accommodated is */
/*     given by CMDSIZ. */


/*     MAXUSE is the maximum number of objects that can be explicitly */
/*     specified on the command line for ckbrief summaries. */


/*     Generic line size for all modules. */


/*     Time type keys. */


/*     Output time format pictures. */


/*     Local parameters */


/*     Command line options as parameters. */


/*     Lower cell size. */


/*     CK DAF summary component counts. */


/*     SPICE Kernel types as recognized by GETFAT. */


/*     Usage message size. */


/*     Local variables. */


/*     Usage message holder. */


/*     Ancillary line and file names holder line. */


/*     Command line and parsing variables. */


/*     Parsed Control Values. */


/*     Internal flags explanation: FNDSUM is .TRUE. if we have */
/*     something found to display in CK-file we are considering. */


/*     DAF Variables */


/*     Arrays to store segment descriptors data for an objects with */
/*     a single intervals of coverage in a given CK-file */


/*     Arrays to store all segment descriptors data for a given CK-file */


/*     Arrays to store all segment descriptors data for one object in */
/*     a given CK-file */


/*     Utility Variables */


/*     The first thing we do is to display version. */

    s_copy(line, "CKBRIEF Version: #. SPICE Toolkit Version: #.", (ftnlen)256,
	     (ftnlen)45);
    tostdo_(" ", (ftnlen)1);
    repmc_(line, "#", "3.1.0, 2005-11-08", line, (ftnlen)256, (ftnlen)1, (
	    ftnlen)17, (ftnlen)256);
    tkvrsn_("TOOLKIT", hword, (ftnlen)7, (ftnlen)256);
    repmc_(line, "#", hword, line, (ftnlen)256, (ftnlen)1, (ftnlen)256, (
	    ftnlen)256);
    tostdo_(line, (ftnlen)256);

/*     Set up the help text. */

    s_copy(text, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 256, "     CKBRIEF is a command line program that allows y"
	    "ou to easily summarize", (ftnlen)256, (ftnlen)74);
    s_copy(text + 512, "     the pointing (orientation) data coverage of one"
	    " or more SPICE CK", (ftnlen)256, (ftnlen)69);
    s_copy(text + 768, "     files. ``Coverage'' is used in the sense of spe"
	    "cifying time span(s)", (ftnlen)256, (ftnlen)72);
    s_copy(text + 1024, "     for which orientation data are available.", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 1280, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 1536, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 1792, "Usage", (ftnlen)256, (ftnlen)5);
    s_copy(text + 2048, "---------------------------------------------------"
	    "-----", (ftnlen)256, (ftnlen)56);
    s_copy(text + 2304, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 2560, "     CKBRIEF is run by typing the name of the progr"
	    "am at a shell prompt.", (ftnlen)256, (ftnlen)72);
    s_copy(text + 2816, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 3072, "        ckbrief [-option(s)] ck-file [ck-file ...] "
	    "[sclk-file] [lsk-file]", (ftnlen)256, (ftnlen)73);
    s_copy(text + 3328, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 3584, "     A wide variety of options may be specified on "
	    "the command line giving", (ftnlen)256, (ftnlen)74);
    s_copy(text + 3840, "     you a great deal of flexibility in the operati"
	    "on and summary", (ftnlen)256, (ftnlen)65);
    s_copy(text + 4096, "     capability of the program.", (ftnlen)256, (
	    ftnlen)31);
    s_copy(text + 4352, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 4608, "     A SPICE SCLK file must be provided if time bou"
	    "nds are to be displayed", (ftnlen)256, (ftnlen)74);
    s_copy(text + 4864, "     as SCLK strings. Both an SCLK and an LSK file "
	    "must be provided if time", (ftnlen)256, (ftnlen)75);
    s_copy(text + 5120, "     bounds are to be displayed in UTC, DOY or ET.", 
	    (ftnlen)256, (ftnlen)50);
    s_copy(text + 5376, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 5632, "     The options and CK, SCLK and LSK file names ma"
	    "y appear in any order on", (ftnlen)256, (ftnlen)75);
    s_copy(text + 5888, "     the command line.", (ftnlen)256, (ftnlen)22);
    s_copy(text + 6144, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 6400, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 6656, "Options", (ftnlen)256, (ftnlen)7);
    s_copy(text + 6912, "---------------------------------------------------"
	    "-----", (ftnlen)256, (ftnlen)56);
    s_copy(text + 7168, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 7424, "     Any of the following options may be specified."
	    " Some options may", (ftnlen)256, (ftnlen)68);
    s_copy(text + 7680, "     disable other options in which case the last s"
	    "pecified option will be", (ftnlen)256, (ftnlen)74);
    s_copy(text + 7936, "     used. For example if you request that coverage"
	    " be displayed as", (ftnlen)256, (ftnlen)67);
    s_copy(text + 8192, "     ephemeris time and another option in the same "
	    "command line requests", (ftnlen)256, (ftnlen)72);
    s_copy(text + 8448, "     UTC time then only UTC time will be displayed."
	    " We have not attempted", (ftnlen)256, (ftnlen)73);
    s_copy(text + 8704, "     to spell out all of the possible conflicts her"
	    "e, since for the most", (ftnlen)256, (ftnlen)72);
    s_copy(text + 8960, "     part you'd be unlikely to specify conflicting "
	    "options intentionally.", (ftnlen)256, (ftnlen)73);
    s_copy(text + 9216, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 9472, "           -t        display results in a tabular f"
	    "ormat", (ftnlen)256, (ftnlen)56);
    s_copy(text + 9728, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 9984, "           -g        group together objects having "
	    "the same coverage", (ftnlen)256, (ftnlen)68);
    s_copy(text + 10240, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 10496, "           -rel      display ID code or name of th"
	    "e frame relative to which", (ftnlen)256, (ftnlen)75);
    s_copy(text + 10752, "                     orientation is available", (
	    ftnlen)256, (ftnlen)45);
    s_copy(text + 11008, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 11264, "           -h        display help text", (ftnlen)
	    256, (ftnlen)38);
    s_copy(text + 11520, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 11776, "           -v        display the version number of"
	    " the program", (ftnlen)256, (ftnlen)62);
    s_copy(text + 12032, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 12288, "           -f        provide a text ``list file'' "
	    "containing full path", (ftnlen)256, (ftnlen)70);
    s_copy(text + 12544, "                     name(s) of CK file(s) to summ"
	    "arize and/or the names of", (ftnlen)256, (ftnlen)75);
    s_copy(text + 12800, "                     SPICE SCLK or LSK files to us"
	    "e for doing time", (ftnlen)256, (ftnlen)66);
    s_copy(text + 13056, "                     conversions. This flag is use"
	    "d as shown below", (ftnlen)256, (ftnlen)66);
    s_copy(text + 13312, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 13568, "                        -f list_of_sources.file", (
	    ftnlen)256, (ftnlen)47);
    s_copy(text + 13824, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 14080, "           -sclk     display times in spacecraft c"
	    "lock string format", (ftnlen)256, (ftnlen)68);
    s_copy(text + 14336, "                     (requires SPICE SCLK file)", (
	    ftnlen)256, (ftnlen)47);
    s_copy(text + 14592, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 14848, "           -dpsclk   display times in spacecraft c"
	    "lock double precision", (ftnlen)256, (ftnlen)71);
    s_copy(text + 15104, "                     format (also called \"spacecr"
	    "aft clock ticks\")", (ftnlen)256, (ftnlen)66);
    s_copy(text + 15360, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 15616, "           -utc      display times in UTC Calendar"
	    " Date format (requires", (ftnlen)256, (ftnlen)72);
    s_copy(text + 15872, "                     SPICE SCLK and LSK files)", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 16128, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 16384, "           -utcdoy   display times in UTC Day-Of-Y"
	    "ear format (requires", (ftnlen)256, (ftnlen)70);
    s_copy(text + 16640, "                     SPICE SCLK and LSK files)", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 16896, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 17152, "           [obj]     create a summary for the spec"
	    "ified object. Here \"obj\"", (ftnlen)256, (ftnlen)74);
    s_copy(text + 17408, "                     is the NAIF ID integer code o"
	    "f a spacecraft,", (ftnlen)256, (ftnlen)65);
    s_copy(text + 17664, "                     instrument or structure. Note"
	    " that CKBRIEF assumes", (ftnlen)256, (ftnlen)71);
    s_copy(text + 17920, "                     that NAIF ID codes for a spac"
	    "ecraft, instrument or", (ftnlen)256, (ftnlen)71);
    s_copy(text + 18176, "                     structure are negative intege"
	    "r numbers. (Don't include", (ftnlen)256, (ftnlen)75);
    s_copy(text + 18432, "                     the square brackets)", (ftnlen)
	    256, (ftnlen)41);
    s_copy(text + 18688, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 18944, "           -nm       (\"no merge\") causes the pro"
	    "gram to display a separate", (ftnlen)256, (ftnlen)74);
    s_copy(text + 19200, "                     record for each segment in th"
	    "e CK file, even when", (ftnlen)256, (ftnlen)70);
    s_copy(text + 19456, "                     segments overlap", (ftnlen)256,
	     (ftnlen)37);
    s_copy(text + 19712, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 19968, "           -dump     causes the program to display"
	    " a separate record for", (ftnlen)256, (ftnlen)72);
    s_copy(text + 20224, "                     each interpolation interval i"
	    "n each segment of every", (ftnlen)256, (ftnlen)73);
    s_copy(text + 20480, "                     CK file; overrides options -g"
	    ", [obj] and -nm", (ftnlen)256, (ftnlen)65);
    s_copy(text + 20736, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 20992, "     If neither \"-nm\" nor \"-dump\" option is sp"
	    "ecified the program displays", (ftnlen)256, (ftnlen)74);
    s_copy(text + 21248, "     merged coverage based on the segment descript"
	    "or information.", (ftnlen)256, (ftnlen)65);
    s_copy(text + 21504, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 21760, "     If none of the options specifying output time"
	    " display type (\"-sclk\",", (ftnlen)256, (ftnlen)73);
    s_copy(text + 22016, "     \"-dpsclk\", \"-utc\", \"-utcdoy\") is specif"
	    "ied, the times are displayed as", (ftnlen)256, (ftnlen)75);
    s_copy(text + 22272, "     Ephemeris Time (ET) in calendar date format.", 
	    (ftnlen)256, (ftnlen)49);
    s_copy(text + 22528, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 22784, "     The name(s) of CK file(s) to be summarized an"
	    "d the LSK and SCLK files", (ftnlen)256, (ftnlen)74);
    s_copy(text + 23040, "     required to support time conversions must be "
	    "provided on the command", (ftnlen)256, (ftnlen)73);
    s_copy(text + 23296, "     line, or in a list file, the name of which mu"
	    "st be provided on the", (ftnlen)256, (ftnlen)71);
    s_copy(text + 23552, "     command line following the \"-f\" key. The na"
	    "mes provided in a list file", (ftnlen)256, (ftnlen)75);
    s_copy(text + 23808, "     may each be on a separate line, or multiple n"
	    "ames per line separated", (ftnlen)256, (ftnlen)73);
    s_copy(text + 24064, "     by spaces, or mixture of these two cases.", (
	    ftnlen)256, (ftnlen)46);
    s_copy(text + 24320, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 24576, "     CKBRIEF will NOT display the time if needed S"
	    "CLK, or SCLK and LSK,", (ftnlen)256, (ftnlen)71);
    s_copy(text + 24832, "     files were not provided.", (ftnlen)256, (
	    ftnlen)29);
    s_copy(text + 25088, " ", (ftnlen)256, (ftnlen)1);
    s_copy(text + 25344, "     CKBRIEF will inform the user of any incorrect"
	    " option, incorrect file", (ftnlen)256, (ftnlen)73);
    s_copy(text + 25600, "     name, or incorrect file type specified on the"
	    " command line.", (ftnlen)256, (ftnlen)64);
    s_copy(text + 25856, " ", (ftnlen)256, (ftnlen)1);

/*     Next step is to parse the command line. This is done in two */
/*     passes. The first pass determines the options specified. The */
/*     second pass gets file names. */

/*     Pass one.  The defaults are: */

    obnam = FALSE_;
    tdsp = FALSE_;
    help = FALSE_;
    vrsn = FALSE_;
    havfil = FALSE_;
    fdsp = FALSE_;
    sfile = FALSE_;
    nomerg = FALSE_;
    idump = FALSE_;
    s_copy(tout, "ET", (ftnlen)256, (ftnlen)2);

/*     Reset ancillary strings that will be used in parsing of the */
/*     command line. */

    s_copy(pass1, " ", (ftnlen)4000, (ftnlen)1);
    s_copy(pass2, " ", (ftnlen)4000, (ftnlen)1);
    s_copy(pass3, " ", (ftnlen)4000, (ftnlen)1);

/*     Get command line. */

    getcml_(pass1, (ftnlen)4000);

/*     Now locate the first word in the command line. */

    numobj = 0;
    start = 1;
    fndnwd_(pass1, &start, &beg, &end, (ftnlen)4000);
    while(beg > 0) {

/*        All options begin with a '-'. */

	if (*(unsigned char *)&pass1[beg - 1] != '-') {

/*           This item doesn't have dash as the first character, so */
/*           it is presumed to be a file name which we will append */
/*           to the string containing only file names. */

	    suffix_(pass1 + (beg - 1), &c__1, pass2, end - (beg - 1), (ftnlen)
		    4000);
	    havfil = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-t", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Display summary in tabular format. */

	    tdsp = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-g", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Group summaries for objects with the same coverage */

	    gdsp = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-rel", end - (beg - 1), (ftnlen)
		4) == 0) {

/*           Display names of reference frames */

	    fdsp = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-h", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Print the help. */

	    help = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-v", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           Print the version. */

	    vrsn = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-f", end - (beg - 1), (ftnlen)2) 
		== 0) {

/*           We have got a file containing names of the CK, LSK */
/*           or/and SCLK files. */

	    start = end + 1;
	    fndnwd_(pass1, &start, &beg, &end, (ftnlen)4000);
	    if (beg > 0) {
		sfile = TRUE_;
		s_copy(srcfil, pass1 + (beg - 1), (ftnlen)256, end - (beg - 1)
			);
	    }
	} else if (s_cmp(pass1 + (beg - 1), "-utc", end - (beg - 1), (ftnlen)
		4) == 0) {

/*           Display times as UTC times. */

	    s_copy(tout, "UTC", (ftnlen)256, (ftnlen)3);
	} else if (s_cmp(pass1 + (beg - 1), "-sclk", end - (beg - 1), (ftnlen)
		5) == 0) {

/*           Display times as string SCLK times. */

	    s_copy(tout, "SCLK", (ftnlen)256, (ftnlen)4);
	} else if (s_cmp(pass1 + (beg - 1), "-dpsclk", end - (beg - 1), (
		ftnlen)7) == 0) {

/*           Display times as DP SCLK or SCLK ticks. */

	    s_copy(tout, "TICKS", (ftnlen)256, (ftnlen)5);
	} else if (s_cmp(pass1 + (beg - 1), "-utcdoy", end - (beg - 1), (
		ftnlen)7) == 0) {

/*           Display times as UTC/DOY times. */

	    s_copy(tout, "UTC/DOY", (ftnlen)256, (ftnlen)7);
	} else if (s_cmp(pass1 + (beg - 1), "-nm", end - (beg - 1), (ftnlen)3)
		 == 0) {

/*           Set "no-merge" flag. */

	    nomerg = TRUE_;
	} else if (s_cmp(pass1 + (beg - 1), "-dump", end - (beg - 1), (ftnlen)
		5) == 0) {

/*           Set "dump-intervals" flag. */

	    idump = TRUE_;
	} else {

/*           Items that begin with '-' that are not one of the previous */
/*           cases are regarded as a request to summarize only for */
/*           particular items. This item must an integer, so we try to */
/*           parse it as integer. If we were successful, we add to the */
/*           integer array containing IDs "ro restrict relative to" :) */

	    if (beint_(pass1 + (beg - 1), end - (beg - 1))) {
		nparsi_(pass1 + (beg - 1), &value, error, &ptr, end - (beg - 
			1), (ftnlen)256);

/*              INSLAI is a great routine but it's our responsibility */
/*              to check whether our ID will fit into OBJLIS array. */

		if (numobj < 100) {

/*                 This ID will fit into our OBJLIS array, lets */
/*                 insert it there. */

		    i__1 = numobj + 1;
		    inslai_(&value, &c__1, &i__1, objlis, &numobj);
		} else {

/*                 There is no space for this ID in our array. Lets */
/*                 report about it. */

		    tostdo_(" Object number ", (ftnlen)15);
		    tostdo_(pass1 + (beg - 1), end - (beg - 1));
		    tostdo_(" doesn't fit into the buffer", (ftnlen)28);
		    tostdo_(" which can hold no more than", (ftnlen)28);
		    tostdo_(" MAXUSE elements.", (ftnlen)17);
		}
	    } else {

/*              Unrecognized option specified. */

		tostdo_(" ", (ftnlen)1);
		s_copy(hword, "'#' is not a recognized option.", (ftnlen)256, 
			(ftnlen)31);
		repmc_(hword, "#", pass1 + (beg - 1), hword, (ftnlen)256, (
			ftnlen)1, end - (beg - 1), (ftnlen)256);
		tostdo_(hword, (ftnlen)256);
		tostdo_(" ", (ftnlen)1);
		help = TRUE_;
	    }
	}

/*        Locate the next word. */

	start = end + 1;
	fndnwd_(pass1, &start, &beg, &end, (ftnlen)4000);
    }

/*     Handle any exceptions that might have been occurred. First, */
/*     display version if version key was the only one on the */
/*     command line. */

    if (vrsn && ! havfil && ! sfile && ! help) {
	tostdo_(" ", (ftnlen)1);
	s_stop("", (ftnlen)0);
    }

/*     Display help only if it was requested or if we didn't get any */
/*     file names on the command line and we didn't get the name of a */
/*     file containing these names. */

    help = help || ! (havfil || sfile);
    if (help) {
	tostdo_(" ", (ftnlen)1);
	for (i__ = 1; i__ <= 102; ++i__) {
	    tostdo_(text + (((i__1 = i__ - 1) < 102 && 0 <= i__1 ? i__1 : 
		    s_rnge("text", i__1, "ckbrief_", (ftnlen)754)) << 8), (
		    ftnlen)256);
	}
	tostdo_(" ", (ftnlen)1);
	s_stop("", (ftnlen)0);
    }

/*     Reset contradicting flags. If interval dump was requested we */
/*     cannot do grouping (-g), filtering by object ID ([obj]) or */
/*     displaing of segment boundaries (-nm). */

    if (idump) {
	nomerg = FALSE_;
	gdsp = FALSE_;
	numobj = 0;
    }

/*     Now finish up determining what the user wants us to do. It is */
/*     necessary to process string PASS2 and file SRCFIL, if it was */
/*     provided, to check files the names of which provided and */
/*     load/process these files correspondingly. */

/*     User can provide 3 types of input files: */

/*      - LSK file(s); */
/*      - SCLK file(s); */
/*      - binary CK file(s). */

/*     First, let check if we have a file name provided using -f */
/*     command line flag */

    if (sfile) {
	eof = FALSE_;
	while(! eof) {
	    rdnbl_(srcfil, strn, &eof, (ftnlen)256, (ftnlen)256);
	    if (! eof) {

/*              We need to check whether we have enough space in our */
/*              string to append another file name to it. If we do, */
/*              we append it. Other wise we report about it. */

		if (rtrim_(strn, (ftnlen)256) + rtrim_(pass2, (ftnlen)4000) <=
			 4000) {
		    suffix_(strn, &c__1, pass2, (ftnlen)256, (ftnlen)4000);
		    havfil = TRUE_;
		} else {
		    s_copy(hword, "No space in the file name buffer for the "
			    "name '#' obtained from the input file '#'", (
			    ftnlen)256, (ftnlen)82);
		    repmc_(hword, "#", strn, hword, (ftnlen)256, (ftnlen)1, (
			    ftnlen)256, (ftnlen)256);
		    repmc_(hword, "#", srcfil, hword, (ftnlen)256, (ftnlen)1, 
			    (ftnlen)256, (ftnlen)256);
		    tostdo_(hword, (ftnlen)256);
		}
	    }
	}
    }

/*     Start processing of the file names in string PASS2. */

    if (havfil) {
	start = 1;
	fndnwd_(pass2, &start, &beg, &end, (ftnlen)4000);
	while(beg > 0) {
	    getfat_(pass2 + (beg - 1), arch, type__, end - (beg - 1), (ftnlen)
		    3, (ftnlen)3);
	    if (s_cmp(type__, "CK", (ftnlen)3, (ftnlen)2) == 0 && s_cmp(arch, 
		    "DAF", (ftnlen)3, (ftnlen)3) == 0) {

/*              We don't need to check whether we have enough space */
/*              in the PASS3 because PASS2 and PASS3 are of the same */
/*              size. */

		suffix_(pass2 + (beg - 1), &c__1, pass3, end - (beg - 1), (
			ftnlen)4000);
	    } else if (s_cmp(arch, "DAF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(
		    arch, "DAS", (ftnlen)3, (ftnlen)3) == 0) {

/*              Skip this one */

	    } else {

/*              Whatever this file is, it's not a CK. To simplify our */
/*              lives we load this file into the kernel pool without */
/*              checking of what type this file is. If it's LSK or */
/*              SCLK, it's going to be processed just fine. If it's */
/*              something else, kernel pool subsystem won't find any */
/*              data in it ... it's just going to take a long time to */
/*              load if somebody provided the name of 20MB file :). */

		ldpool_(pass2 + (beg - 1), end - (beg - 1));
	    }
	    start = end + 1;
	    fndnwd_(pass2, &start, &beg, &end, (ftnlen)4000);
	}
    }

/*     Check whether at least one CK file was provided. If not, */
/*     complain about it. */

    if (s_cmp(pass3, " ", (ftnlen)4000, (ftnlen)1) == 0) {
	tostdo_("No CK files were provided -- no summary will be displayed.", 
		(ftnlen)58);
	tostdo_(" ", (ftnlen)1);
	tostdo_("Run CKBRIEF without command line options to see program usa"
		"ge.", (ftnlen)62);
	tostdo_(" ", (ftnlen)1);
	s_stop("", (ftnlen)0);
    }

/*     Below is the main loop processing sequentially all CK-files those */
/*     names are stored in string PASS3. */

    start = 1;
    fndnwd_(pass3, &start, &beg, &end, (ftnlen)4000);
    while(beg != 0) {

/*        Open the next file. */

	dafopr_(pass3 + (beg - 1), &handle, end - (beg - 1));
	fndsum = FALSE_;
	dafbfs_(&handle);
	daffna_(&fnd);

/*        Initialize arrays to store summary data from CK-file segments */
/*        descriptors. These arrays will have the same size equal to */
/*        NOBJ: */

/*           IDA      contains IDs of object. */
/*           AVFA     contains AV flags. */
/*           FRAMEA   contains reference frame IDs */
/*           TYPEA    contains segment types */
/*           BADDRA   contains segment begin addresses */
/*           EADDRA   contains segment end addresses */
/*           TSTRTA   contains start time for the */
/*                    objects coverage. */
/*           TENDA    contains end time for the */
/*                    objects coverage. */

	nobj = 1;
	fulbuf = FALSE_;
	while(fnd) {
	    dafgs_(segsum);
	    dafus_(segsum, &c__2, &c__6, dc, ic);

/*           If we are summarizing from a list of input object, */
/*           find out if this object is in the list to summarize. */

	    if (numobj > 0) {
		if (isrchi_(ic, &numobj, objlis) > 0) {

/*                 We need to check whether we have space in the buffer. */
/*                 Note that we check against MAXBOD-1 because we will */
/*                 use the element IDA(MAXBOD) as loop terminator flag */
/*                 further in the program. */

		    if (nobj <= 9999) {
			fndsum = TRUE_;
			ida[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("ida", i__1, "ckbrief_", (ftnlen)948)] 
				= ic[0];
			framea[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 :
				 s_rnge("framea", i__1, "ckbrief_", (ftnlen)
				949)] = ic[1];
			typea[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("typea", i__1, "ckbrief_", (ftnlen)950)
				] = ic[2];
			avfa[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("avfa", i__1, "ckbrief_", (ftnlen)951)]
				 = ic[3];
			baddra[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 :
				 s_rnge("baddra", i__1, "ckbrief_", (ftnlen)
				952)] = ic[4];
			eaddra[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 :
				 s_rnge("eaddra", i__1, "ckbrief_", (ftnlen)
				953)] = ic[5];
			tstrta[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 :
				 s_rnge("tstrta", i__1, "ckbrief_", (ftnlen)
				954)] = dc[0];
			tenda[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("tenda", i__1, "ckbrief_", (ftnlen)955)
				] = dc[1];
			++nobj;
		    } else {
			fulbuf = TRUE_;
		    }
		}
	    } else {

/*              Same as above -- check whether we have space in the */
/*              buffer. Note that we check against MAXBOD-1 because we */
/*              will use the element IDA(MAXBOD) as loop terminator */
/*              flag further in the program. */

		if (nobj <= 9999) {
		    fndsum = TRUE_;
		    ida[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("ida", i__1, "ckbrief_", (ftnlen)979)] = 
			    ic[0];
		    framea[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("framea", i__1, "ckbrief_", (ftnlen)980)] =
			     ic[1];
		    typea[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("typea", i__1, "ckbrief_", (ftnlen)981)] = 
			    ic[2];
		    avfa[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("avfa", i__1, "ckbrief_", (ftnlen)982)] = 
			    ic[3];
		    baddra[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("baddra", i__1, "ckbrief_", (ftnlen)983)] =
			     ic[4];
		    eaddra[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("eaddra", i__1, "ckbrief_", (ftnlen)984)] =
			     ic[5];
		    tstrta[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tstrta", i__1, "ckbrief_", (ftnlen)985)] =
			     dc[0];
		    tenda[(i__1 = nobj - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tenda", i__1, "ckbrief_", (ftnlen)986)] = 
			    dc[1];
		    ++nobj;
		} else {
		    fulbuf = TRUE_;
		}
	    }

/*           Go to the next segment */

	    daffna_(&fnd);
	}

/*        The NOBJ is currently greater that the number of colleted */
/*        objects by one. We need to fix this. */

	--nobj;

/*        Display name of the file which we are summarizing now. */

	if (nobj != 0) {
	    tostdo_("  ", (ftnlen)2);
	    tostdo_("  ", (ftnlen)2);
/* Writing concatenation */
	    i__2[0] = 13, a__1[0] = "Summary for: ";
	    i__2[1] = end - (beg - 1), a__1[1] = pass3 + (beg - 1);
	    s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)4013);
	    tostdo_(ch__1, end - (beg - 1) + 13);

/*           Check whether we could have had buffer overflow and */
/*           collected only MAXBOD-1 summaries to prevent that. */

	    if (fulbuf) {
		if (numobj > 0) {
		    tostdo_(" ", (ftnlen)1);
		    s_copy(hword, "Number of segments containing data for th"
			    "e specified IDs was greater than", (ftnlen)256, (
			    ftnlen)73);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "the size of the internal buffer that hold"
			    "s segment descriptors. Therefore", (ftnlen)256, (
			    ftnlen)73);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "coverage for only # first segments for th"
			    "ese IDs from the file will be ", (ftnlen)256, (
			    ftnlen)71);
		    repmi_(hword, "#", &c__9999, hword, (ftnlen)256, (ftnlen)
			    1, (ftnlen)256);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "summarized.", (ftnlen)256, (ftnlen)11);
		    tostdo_(hword, (ftnlen)256);
		} else {
		    tostdo_(" ", (ftnlen)1);
		    s_copy(hword, "Number of segments in the file was greate"
			    "r than the size of the internal ", (ftnlen)256, (
			    ftnlen)73);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "buffer that holds segment descriptors. Th"
			    "erefore coverage for only # first ", (ftnlen)256, 
			    (ftnlen)75);
		    repmi_(hword, "#", &c__9999, hword, (ftnlen)256, (ftnlen)
			    1, (ftnlen)256);
		    tostdo_(hword, (ftnlen)256);
		    s_copy(hword, "segments from the file will be summarized."
			    , (ftnlen)256, (ftnlen)42);
		    tostdo_(hword, (ftnlen)256);
		}
	    }
	}

/*        If we were asked to dump intervals, we have got everything */
/*        we need for displaying them. Otherwise, we have a lot of work */
/*        do. */

	if (idump) {

/*           All we need to do to dump intervals is to call Bills */
/*           ZZCKCRVs and copy output schedule to the buffers that */
/*           DISPSM expects. (BTW, if NOBJ is 0 this DO will never */
/*           DO :-) */

	    i__1 = nobj;
	    for (i__ = 1; i__ <= i__1; ++i__) {

/*              Diplay segment order number. */

		s_copy(hword, "Segment No.: #", (ftnlen)256, (ftnlen)14);
		repmi_(hword, "#", &i__, hword, (ftnlen)256, (ftnlen)1, (
			ftnlen)256);
		tostdo_("  ", (ftnlen)2);
		tostdo_(hword, (ftnlen)256);

/*              Does looking for interval for a segment of this */
/*              type make sense? */

		if (typea[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? i__3 : 
			s_rnge("typea", i__3, "ckbrief_", (ftnlen)1089)] == 2 
			|| typea[(i__4 = i__ - 1) < 10000 && 0 <= i__4 ? i__4 
			: s_rnge("typea", i__4, "ckbrief_", (ftnlen)1089)] == 
			3 || typea[(i__5 = i__ - 1) < 10000 && 0 <= i__5 ? 
			i__5 : s_rnge("typea", i__5, "ckbrief_", (ftnlen)1089)
			] == 4 || typea[(i__6 = i__ - 1) < 10000 && 0 <= i__6 
			? i__6 : s_rnge("typea", i__6, "ckbrief_", (ftnlen)
			1089)] == 5) {

/*                 Sure does! Initialize window and call corresponding */
/*                 ZZCKCRVx depending on what type the segment is. */

		    ssized_(&c__20000, wind);
		    if (typea[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? i__3 : 
			    s_rnge("typea", i__3, "ckbrief_", (ftnlen)1100)] 
			    == 2) {
			zzckcvr2_(&handle, &baddra[(i__3 = i__ - 1) < 10000 &&
				 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1102)], &eaddra[(i__4 = 
				i__ - 1) < 10000 && 0 <= i__4 ? i__4 : s_rnge(
				"eaddra", i__4, "ckbrief_", (ftnlen)1102)], 
				wind);
		    } else if (typea[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? 
			    i__3 : s_rnge("typea", i__3, "ckbrief_", (ftnlen)
			    1104)] == 3) {
			zzckcvr3_(&handle, &baddra[(i__3 = i__ - 1) < 10000 &&
				 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1106)], &eaddra[(i__4 = 
				i__ - 1) < 10000 && 0 <= i__4 ? i__4 : s_rnge(
				"eaddra", i__4, "ckbrief_", (ftnlen)1106)], 
				wind);
		    } else if (typea[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? 
			    i__3 : s_rnge("typea", i__3, "ckbrief_", (ftnlen)
			    1108)] == 4) {
			zzckcvr4_(&handle, &baddra[(i__3 = i__ - 1) < 10000 &&
				 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1110)], &eaddra[(i__4 = 
				i__ - 1) < 10000 && 0 <= i__4 ? i__4 : s_rnge(
				"eaddra", i__4, "ckbrief_", (ftnlen)1110)], 
				wind);
		    } else if (typea[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? 
			    i__3 : s_rnge("typea", i__3, "ckbrief_", (ftnlen)
			    1112)] == 5) {
			zzckcvr5_(&handle, &baddra[(i__3 = i__ - 1) < 10000 &&
				 0 <= i__3 ? i__3 : s_rnge("baddra", i__3, 
				"ckbrief_", (ftnlen)1114)], &eaddra[(i__4 = 
				i__ - 1) < 10000 && 0 <= i__4 ? i__4 : s_rnge(
				"eaddra", i__4, "ckbrief_", (ftnlen)1114)], 
				wind);
		    }

/*                 We fill have got a schedule for this segment. Copy */
/*                 it to buffers and call DISPSM. */

		    if (cardd_(wind) != 0) {
			nobgs = cardd_(wind) / 2;
			i__3 = nobgs - 1;
			for (l = 0; l <= i__3; ++l) {
			    ids[(i__4 = l) < 10000 && 0 <= i__4 ? i__4 : 
				    s_rnge("ids", i__4, "ckbrief_", (ftnlen)
				    1127)] = ida[(i__5 = i__ - 1) < 10000 && 
				    0 <= i__5 ? i__5 : s_rnge("ida", i__5, 
				    "ckbrief_", (ftnlen)1127)];
			    tstrts[(i__4 = l) < 10000 && 0 <= i__4 ? i__4 : 
				    s_rnge("tstrts", i__4, "ckbrief_", (
				    ftnlen)1128)] = wind[(i__5 = (l << 1) + 6)
				     < 20006 && 0 <= i__5 ? i__5 : s_rnge(
				    "wind", i__5, "ckbrief_", (ftnlen)1128)];
			    tends[(i__4 = l) < 10000 && 0 <= i__4 ? i__4 : 
				    s_rnge("tends", i__4, "ckbrief_", (ftnlen)
				    1129)] = wind[(i__5 = (l << 1) + 7) < 
				    20006 && 0 <= i__5 ? i__5 : s_rnge("wind",
				     i__5, "ckbrief_", (ftnlen)1129)];
			    avfs[(i__4 = l) < 10000 && 0 <= i__4 ? i__4 : 
				    s_rnge("avfs", i__4, "ckbrief_", (ftnlen)
				    1130)] = avfa[(i__5 = i__ - 1) < 10000 && 
				    0 <= i__5 ? i__5 : s_rnge("avfa", i__5, 
				    "ckbrief_", (ftnlen)1130)];
			    frames[(i__4 = l) < 10000 && 0 <= i__4 ? i__4 : 
				    s_rnge("frames", i__4, "ckbrief_", (
				    ftnlen)1131)] = framea[(i__5 = i__ - 1) < 
				    10000 && 0 <= i__5 ? i__5 : s_rnge("fram"
				    "ea", i__5, "ckbrief_", (ftnlen)1131)];
			}
			dispsm_(&nobgs, ids, tstrts, tends, avfs, frames, 
				tout, &fdsp, &tdsp, &gdsp, (ftnlen)256);
		    }
		} else {

/*                 Well, this segment is not eligible for having */
/*                 intervals. Tell user about it. */

		    s_copy(hword, "This segment is a type # segment for whic"
			    "h interpolation is not supported.", (ftnlen)256, (
			    ftnlen)74);
		    repmi_(hword, "#", &typea[(i__3 = i__ - 1) < 10000 && 0 <=
			     i__3 ? i__3 : s_rnge("typea", i__3, "ckbrief_", (
			    ftnlen)1147)], hword, (ftnlen)256, (ftnlen)1, (
			    ftnlen)256);
		    tostdo_("  ", (ftnlen)2);
		    tostdo_(hword, (ftnlen)256);
		}
	    }
	} else {

/*           We are here because we weren't asked to do interval dump */
/*           but were rather asked to do something intelligent (that */
/*           intelligent work is what CKRBIEF was written to do :-) */

/*           Data from all segment descriptors in the current file are */
/*           stored in arrays. Now it will be distributed to two */
/*           different groups of arrays. */

/*           First group - for objects which have multiple coverage */
/*           intervals in current CK-file. */

/*           Second group - for objects which have single coverage */
/*           interval in current CK-file. */

/*           This distribution is done to provide a possibility to merge */
/*           time intervals for a particular object if intervals */
/*           overlap. */

/*           Initialization of array pointers */

	    nobgs = 1;
	    nobgo = 1;
	    i__ = 1;

/*           Now we set IDA(NOBJ+1) to 0 we can safely do that because */
/*           we checked against MAXBOD-1 in the loop filling the */
/*           buffers. */

	    ida[(i__1 = nobj) < 10000 && 0 <= i__1 ? i__1 : s_rnge("ida", 
		    i__1, "ckbrief_", (ftnlen)1187)] = 0;

/*           Here is the cycle to get through all descriptors to */
/*           distribute them to two arrays. */

	    while(fndsum && i__ <= nobj) {

/*              Skip all records with IDAs set to zero -- these were */
/*              already taken into account. */

		while(ida[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ? i__1 : 
			s_rnge("ida", i__1, "ckbrief_", (ftnlen)1199)] == 0 &&
			 i__ <= nobj) {
		    ++i__;
		}
		if (i__ <= nobj) {

/*                 Current segment is the first segment found for this */
/*                 ID in the buffer. Set counter of segments for current */
/*                 ID to 1 and copy complete summary for current segment */
/*                 to IDO, etc. buffers. */

		    cnt = 1;
		    ido[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("ido", i__1, "ckbrief_", (ftnlen)1213)] = 
			    ida[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? i__3 :
			     s_rnge("ida", i__3, "ckbrief_", (ftnlen)1213)];
		    avfo[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("avfo", i__1, "ckbrief_", (ftnlen)1214)] = 
			    avfa[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? i__3 
			    : s_rnge("avfa", i__3, "ckbrief_", (ftnlen)1214)];
		    frameo[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("frameo", i__1, "ckbrief_", (ftnlen)1215)] 
			    = framea[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? 
			    i__3 : s_rnge("framea", i__3, "ckbrief_", (ftnlen)
			    1215)];
		    tstrto[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tstrto", i__1, "ckbrief_", (ftnlen)1216)] 
			    = tstrta[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? 
			    i__3 : s_rnge("tstrta", i__3, "ckbrief_", (ftnlen)
			    1216)];
		    tendo[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("tendo", i__1, "ckbrief_", (ftnlen)1217)] =
			     tenda[(i__3 = i__ - 1) < 10000 && 0 <= i__3 ? 
			    i__3 : s_rnge("tenda", i__3, "ckbrief_", (ftnlen)
			    1217)];

/*                 Increase counter of segments for current ID and */
/*                 "mark" current segment as "processed" in IDA buffer */
/*                 by setting its IDA to zero. */

		    ++nobgo;
		    ida[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ? i__1 : s_rnge(
			    "ida", i__1, "ckbrief_", (ftnlen)1225)] = 0;

/*                 Loop to find all segments with the same ID in the IDA */
/*                 buffer. */

		    i__4 = nobj - i__;
		    loc = isrchi_(&ido[(i__1 = nobgo - 2) < 10000 && 0 <= 
			    i__1 ? i__1 : s_rnge("ido", i__1, "ckbrief_", (
			    ftnlen)1231)], &i__4, &ida[(i__3 = i__) < 10000 &&
			     0 <= i__3 ? i__3 : s_rnge("ida", i__3, "ckbrief_"
			    , (ftnlen)1231)]);
		    k = loc + i__;
		    while(loc != 0) {

/*                    We found one more -- increase counter, save */
/*                    summary in IDO, etc. array and reset its IDS to 0. */

			++cnt;
			ido[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("ido", i__1, "ckbrief_", (ftnlen)1242)]
				 = ida[(i__3 = k - 1) < 10000 && 0 <= i__3 ? 
				i__3 : s_rnge("ida", i__3, "ckbrief_", (
				ftnlen)1242)];
			avfo[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("avfo", i__1, "ckbrief_", (ftnlen)1243)
				] = avfa[(i__3 = k - 1) < 10000 && 0 <= i__3 ?
				 i__3 : s_rnge("avfa", i__3, "ckbrief_", (
				ftnlen)1243)];
			frameo[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 
				: s_rnge("frameo", i__1, "ckbrief_", (ftnlen)
				1244)] = framea[(i__3 = k - 1) < 10000 && 0 <=
				 i__3 ? i__3 : s_rnge("framea", i__3, "ckbri"
				"ef_", (ftnlen)1244)];
			tstrto[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 
				: s_rnge("tstrto", i__1, "ckbrief_", (ftnlen)
				1245)] = tstrta[(i__3 = k - 1) < 10000 && 0 <=
				 i__3 ? i__3 : s_rnge("tstrta", i__3, "ckbri"
				"ef_", (ftnlen)1245)];
			tendo[(i__1 = nobgo - 1) < 10000 && 0 <= i__1 ? i__1 :
				 s_rnge("tendo", i__1, "ckbrief_", (ftnlen)
				1246)] = tenda[(i__3 = k - 1) < 10000 && 0 <= 
				i__3 ? i__3 : s_rnge("tenda", i__3, "ckbrief_"
				, (ftnlen)1246)];
			++nobgo;
			ida[(i__1 = k - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("ida", i__1, "ckbrief_", (ftnlen)1249)]
				 = 0;
			i__4 = nobj - k;
			loc = isrchi_(&ido[(i__1 = nobgo - 2) < 10000 && 0 <= 
				i__1 ? i__1 : s_rnge("ido", i__1, "ckbrief_", 
				(ftnlen)1251)], &i__4, &ida[(i__3 = k) < 
				10000 && 0 <= i__3 ? i__3 : s_rnge("ida", 
				i__3, "ckbrief_", (ftnlen)1251)]);
			k += loc;
		    }

/*                 Did we find more than one segment for current ID? */

		    if (cnt == 1) {

/*                    No, we didn't. Then we include this segment into */
/*                    IDS buffer. But first we reset NOBGO back to */
/*                    remove it from IDO buffer. */

			--nobgo;
			ids[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("ids", i__1, "ckbrief_", (ftnlen)1267)]
				 = ido[(i__3 = nobgo - 1) < 10000 && 0 <= 
				i__3 ? i__3 : s_rnge("ido", i__3, "ckbrief_", 
				(ftnlen)1267)];
			avfs[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? i__1 : 
				s_rnge("avfs", i__1, "ckbrief_", (ftnlen)1268)
				] = avfo[(i__3 = nobgo - 1) < 10000 && 0 <= 
				i__3 ? i__3 : s_rnge("avfo", i__3, "ckbrief_",
				 (ftnlen)1268)];
			frames[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? i__1 
				: s_rnge("frames", i__1, "ckbrief_", (ftnlen)
				1269)] = frameo[(i__3 = nobgo - 1) < 10000 && 
				0 <= i__3 ? i__3 : s_rnge("frameo", i__3, 
				"ckbrief_", (ftnlen)1269)];
			tstrts[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? i__1 
				: s_rnge("tstrts", i__1, "ckbrief_", (ftnlen)
				1270)] = tstrto[(i__3 = nobgo - 1) < 10000 && 
				0 <= i__3 ? i__3 : s_rnge("tstrto", i__3, 
				"ckbrief_", (ftnlen)1270)];
			tends[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? i__1 :
				 s_rnge("tends", i__1, "ckbrief_", (ftnlen)
				1271)] = tendo[(i__3 = nobgo - 1) < 10000 && 
				0 <= i__3 ? i__3 : s_rnge("tendo", i__3, 
				"ckbrief_", (ftnlen)1271)];
			++nobgs;
		    }
		}
	    }
	    --nobgo;

/*           At this point we have two buffers -- xxxO and xxxS -- */
/*           filled with appropriate segment descriptors. There is no */
/*           need to do any more processing for xxxS buffer. But there */
/*           is work to be done on xxxO buffer: we need to merge */
/*           overlapping time intervals for each ID. */

	    if (nobgo > 1) {
		i__ = 1;
		k = 1;
		while(i__ <= nobgo - 1) {

/*                 All segments for the same ID are already grouped */
/*                 together. We need to find out what is the first and */
/*                 last of them */

		    while(ido[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ? i__1 : 
			    s_rnge("ido", i__1, "ckbrief_", (ftnlen)1302)] == 
			    ido[(i__3 = k - 1) < 10000 && 0 <= i__3 ? i__3 : 
			    s_rnge("ido", i__3, "ckbrief_", (ftnlen)1302)] && 
			    k <= nobgo) {
			++k;
		    }

/*                 After we know it, we copy start and stop times to */
/*                 a WINDOW array. */

		    ssized_(&c__20000, wind);
		    i__1 = k - i__ << 1;
		    scardd_(&i__1, wind);
		    i__1 = k - i__ - 1;
		    for (l = 0; l <= i__1; ++l) {
			wind[(i__3 = (l << 1) + 6) < 20006 && 0 <= i__3 ? 
				i__3 : s_rnge("wind", i__3, "ckbrief_", (
				ftnlen)1314)] = tstrto[(i__4 = l + i__ - 1) < 
				10000 && 0 <= i__4 ? i__4 : s_rnge("tstrto", 
				i__4, "ckbrief_", (ftnlen)1314)];
			wind[(i__3 = (l << 1) + 7) < 20006 && 0 <= i__3 ? 
				i__3 : s_rnge("wind", i__3, "ckbrief_", (
				ftnlen)1315)] = tendo[(i__4 = l + i__ - 1) < 
				10000 && 0 <= i__4 ? i__4 : s_rnge("tendo", 
				i__4, "ckbrief_", (ftnlen)1315)];
		    }

/*                 Here is important point of algorithm. We'll validate */
/*                 window of time intervals. But we do it only if NOMERG */
/*                 flag is not set. */

		    if (! nomerg) {
			i__1 = k - i__ << 1;
			wnvald_(&c__20000, &i__1, wind);
		    }

/*                 Now we can check whether our window validating */
/*                 brought any results. */

		    if (cardd_(wind) == k - i__ << 1) {

/*                    Nothing happened with our windows. Well, the best */
/*                    we can do then is to order coverages for this ID */
/*                    by start time (and this order in xxxO all arrays.) */

			i__3 = k - i__;
			orderd_(&tstrto[(i__1 = i__ - 1) < 10000 && 0 <= i__1 
				? i__1 : s_rnge("tstrto", i__1, "ckbrief_", (
				ftnlen)1338)], &i__3, iorder);
			i__3 = k - i__;
			reordd_(iorder, &i__3, &tstrto[(i__1 = i__ - 1) < 
				10000 && 0 <= i__1 ? i__1 : s_rnge("tstrto", 
				i__1, "ckbrief_", (ftnlen)1340)]);
			i__3 = k - i__;
			reordd_(iorder, &i__3, &tendo[(i__1 = i__ - 1) < 
				10000 && 0 <= i__1 ? i__1 : s_rnge("tendo", 
				i__1, "ckbrief_", (ftnlen)1341)]);
			i__3 = k - i__;
			reordi_(iorder, &i__3, &avfo[(i__1 = i__ - 1) < 10000 
				&& 0 <= i__1 ? i__1 : s_rnge("avfo", i__1, 
				"ckbrief_", (ftnlen)1342)]);
			i__3 = k - i__;
			reordi_(iorder, &i__3, &frameo[(i__1 = i__ - 1) < 
				10000 && 0 <= i__1 ? i__1 : s_rnge("frameo", 
				i__1, "ckbrief_", (ftnlen)1343)]);

/*                    Now we can copy sorted data back to xxxS buffer. */

			i__4 = k - i__;
			movei_(&ido[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ? 
				i__1 : s_rnge("ido", i__1, "ckbrief_", (
				ftnlen)1348)], &i__4, &ids[(i__3 = nobgs - 1) 
				< 10000 && 0 <= i__3 ? i__3 : s_rnge("ids", 
				i__3, "ckbrief_", (ftnlen)1348)]);
			i__4 = k - i__;
			moved_(&tstrto[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ?
				 i__1 : s_rnge("tstrto", i__1, "ckbrief_", (
				ftnlen)1349)], &i__4, &tstrts[(i__3 = nobgs - 
				1) < 10000 && 0 <= i__3 ? i__3 : s_rnge("tst"
				"rts", i__3, "ckbrief_", (ftnlen)1349)]);
			i__4 = k - i__;
			moved_(&tendo[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ? 
				i__1 : s_rnge("tendo", i__1, "ckbrief_", (
				ftnlen)1350)], &i__4, &tends[(i__3 = nobgs - 
				1) < 10000 && 0 <= i__3 ? i__3 : s_rnge("ten"
				"ds", i__3, "ckbrief_", (ftnlen)1350)]);
			i__4 = k - i__;
			movei_(&avfo[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ? 
				i__1 : s_rnge("avfo", i__1, "ckbrief_", (
				ftnlen)1351)], &i__4, &avfs[(i__3 = nobgs - 1)
				 < 10000 && 0 <= i__3 ? i__3 : s_rnge("avfs", 
				i__3, "ckbrief_", (ftnlen)1351)]);
			i__4 = k - i__;
			movei_(&frameo[(i__1 = i__ - 1) < 10000 && 0 <= i__1 ?
				 i__1 : s_rnge("frameo", i__1, "ckbrief_", (
				ftnlen)1352)], &i__4, &frames[(i__3 = nobgs - 
				1) < 10000 && 0 <= i__3 ? i__3 : s_rnge("fra"
				"mes", i__3, "ckbrief_", (ftnlen)1352)]);
			nobgs = nobgs + k - i__;
		    } else {

/*                    Some of the windows got merged. It means that by */
/*                    validating we broke connection between them and */
/*                    AVFS and FRAMES for the original segments. And */
/*                    what if original segments used in window */
/*                    validating had a different AV flags of were */
/*                    relative to different frames? We have to check */
/*                    that and assign right values to indicate this -- */
/*                    set AVS to 2 and FRAMES to 0. */

			mixdav = FALSE_;
			mixdfr = FALSE_;
			l = i__;
			while(l < k - 1) {
			    if (avfo[(i__1 = l - 1) < 10000 && 0 <= i__1 ? 
				    i__1 : s_rnge("avfo", i__1, "ckbrief_", (
				    ftnlen)1373)] != avfo[(i__3 = l) < 10000 
				    && 0 <= i__3 ? i__3 : s_rnge("avfo", i__3,
				     "ckbrief_", (ftnlen)1373)]) {
				mixdav = TRUE_;
			    }
			    if (frameo[(i__1 = l - 1) < 10000 && 0 <= i__1 ? 
				    i__1 : s_rnge("frameo", i__1, "ckbrief_", 
				    (ftnlen)1377)] != frameo[(i__3 = l) < 
				    10000 && 0 <= i__3 ? i__3 : s_rnge("fram"
				    "eo", i__3, "ckbrief_", (ftnlen)1377)]) {
				mixdfr = TRUE_;
			    }
			    ++l;
			}

/*                    If we had mixed AV flags, we set all AVFO to 2. */

			if (mixdav) {
			    i__1 = k - 1;
			    for (l = i__; l <= i__1; ++l) {
				avfo[(i__3 = l - 1) < 10000 && 0 <= i__3 ? 
					i__3 : s_rnge("avfo", i__3, "ckbrief_"
					, (ftnlen)1390)] = 2;
			    }
			}

/*                    If we had mixed reference frames, we set all */
/*                    FRAMEO to 0. */

			if (mixdfr) {
			    i__1 = k - 1;
			    for (l = i__; l <= i__1; ++l) {
				frameo[(i__3 = l - 1) < 10000 && 0 <= i__3 ? 
					i__3 : s_rnge("frameo", i__3, "ckbri"
					"ef_", (ftnlen)1400)] = 0;
			    }
			}

/*                    What if after validation we have only 1 time */
/*                    interval? Then data for the object have to be */
/*                    moved from array for multiple intervals to array */
/*                    for single intervals. */

			if (cardd_(wind) == 2) {

/*                       Copy summaries to IDS, etc. arrays. */

			    ids[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? 
				    i__1 : s_rnge("ids", i__1, "ckbrief_", (
				    ftnlen)1415)] = ido[(i__3 = i__ - 1) < 
				    10000 && 0 <= i__3 ? i__3 : s_rnge("ido", 
				    i__3, "ckbrief_", (ftnlen)1415)];
			    avfs[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? 
				    i__1 : s_rnge("avfs", i__1, "ckbrief_", (
				    ftnlen)1416)] = avfo[(i__3 = i__ - 1) < 
				    10000 && 0 <= i__3 ? i__3 : s_rnge("avfo",
				     i__3, "ckbrief_", (ftnlen)1416)];
			    frames[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? 
				    i__1 : s_rnge("frames", i__1, "ckbrief_", 
				    (ftnlen)1417)] = frameo[(i__3 = i__ - 1) <
				     10000 && 0 <= i__3 ? i__3 : s_rnge("fra"
				    "meo", i__3, "ckbrief_", (ftnlen)1417)];
			    tstrts[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? 
				    i__1 : s_rnge("tstrts", i__1, "ckbrief_", 
				    (ftnlen)1418)] = wind[6];
			    tends[(i__1 = nobgs - 1) < 10000 && 0 <= i__1 ? 
				    i__1 : s_rnge("tends", i__1, "ckbrief_", (
				    ftnlen)1419)] = wind[7];

/*                       Increment number of elements in AVS, etc. */
/*                       arrays. */

			    ++nobgs;
			} else {

/*                       It looks like we have more than one interval. */

			    i__1 = cardd_(wind) / 2 - 1;
			    for (l = 0; l <= i__1; ++l) {
				temps[(i__3 = l) < 10000 && 0 <= i__3 ? i__3 :
					 s_rnge("temps", i__3, "ckbrief_", (
					ftnlen)1433)] = wind[(i__4 = (l << 1) 
					+ 6) < 20006 && 0 <= i__4 ? i__4 : 
					s_rnge("wind", i__4, "ckbrief_", (
					ftnlen)1433)];
				tempe[(i__3 = l) < 10000 && 0 <= i__3 ? i__3 :
					 s_rnge("tempe", i__3, "ckbrief_", (
					ftnlen)1434)] = wind[(i__4 = (l << 1) 
					+ 7) < 20006 && 0 <= i__4 ? i__4 : 
					s_rnge("wind", i__4, "ckbrief_", (
					ftnlen)1434)];
			    }
			    l = cardd_(wind) / 2;

/*                       Copy objects with multiple time intervals to */
/*                       xxxS buffer. */

			    movei_(&ido[(i__1 = i__ - 1) < 10000 && 0 <= i__1 
				    ? i__1 : s_rnge("ido", i__1, "ckbrief_", (
				    ftnlen)1442)], &l, &ids[(i__3 = nobgs - 1)
				     < 10000 && 0 <= i__3 ? i__3 : s_rnge(
				    "ids", i__3, "ckbrief_", (ftnlen)1442)]);
			    moved_(temps, &l, &tstrts[(i__1 = nobgs - 1) < 
				    10000 && 0 <= i__1 ? i__1 : s_rnge("tstr"
				    "ts", i__1, "ckbrief_", (ftnlen)1443)]);
			    moved_(tempe, &l, &tends[(i__1 = nobgs - 1) < 
				    10000 && 0 <= i__1 ? i__1 : s_rnge("tends"
				    , i__1, "ckbrief_", (ftnlen)1444)]);
			    movei_(&avfo[(i__1 = i__ - 1) < 10000 && 0 <= 
				    i__1 ? i__1 : s_rnge("avfo", i__1, "ckbr"
				    "ief_", (ftnlen)1445)], &l, &avfs[(i__3 = 
				    nobgs - 1) < 10000 && 0 <= i__3 ? i__3 : 
				    s_rnge("avfs", i__3, "ckbrief_", (ftnlen)
				    1445)]);
			    movei_(&frameo[(i__1 = i__ - 1) < 10000 && 0 <= 
				    i__1 ? i__1 : s_rnge("frameo", i__1, 
				    "ckbrief_", (ftnlen)1446)], &l, &frames[(
				    i__3 = nobgs - 1) < 10000 && 0 <= i__3 ? 
				    i__3 : s_rnge("frames", i__3, "ckbrief_", 
				    (ftnlen)1446)]);
			    nobgs += l;
			}
		    }

/*                 We are done with current ID. Lets move to the next */
/*                 one. */

		    i__ = k;
		}
	    }

/*           OK, we are done with processing of the xxxO buffer. All */
/*           data sorted/merged and stored in a single buffer -- xxxS. */
/*           Lets display summary then .... */

	    --nobgs;
	    if (nobgs != 0) {
		dispsm_(&nobgs, ids, tstrts, tends, avfs, frames, tout, &fdsp,
			 &tdsp, &gdsp, (ftnlen)256);
	    }
	}

/*        Current CK-file processing is over - close it and move on to */
/*        the next file. */

	dafcls_(&handle);
	start = end + 1;
	fndnwd_(pass3, &start, &beg, &end, (ftnlen)4000);
    }

/*     Add one more blank line at the end of the summary report. */

    tostdo_(" ", (ftnlen)1);
    byebye_("SUCCESS", (ftnlen)7);
    s_stop("", (ftnlen)0);
    return 0;
} /* MAIN__ */

/* Main program alias */ int ckbrief_ () { MAIN__ (); return 0; }
