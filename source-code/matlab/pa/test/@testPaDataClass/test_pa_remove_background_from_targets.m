function [self] = test_pa_remove_background_from_targets(self)
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% [self] = test_pa_remove_background_from_targets(self)
%
% This test generates background pixels based on a specified background
% polynomial with additive noise, and fits a low order 2D background
% polynomial to it on a cadence by cadence basis. A target pixel time
% series is then generated by overlaying target pixels on the same
% background. Additive noise is included in both target and background.
% The background is then estimated and removed from the targets cadence by
% cadence. Chi-square and z-tests on the background removed target levels
% are performed to validate the fitting process within a specified
% confidence level.
%
%  Example
%  =======
%  Use a test runner to run the test method:
%      run(text_test_runner, ...
%          testPaDataClass('test_pa_remove_background_from_targets'));
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% 
% Copyright 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% 
% NASA acknowledges the SETI Institute's primary role in authoring and
% producing the Kepler Data Processing Pipeline under Cooperative
% Agreement Nos. NNA04CC63A, NNX07AD96A, NNX07AD98A, NNX11AI13A,
% NNX11AI14A, NNX13AD01A & NNX13AD16A.
% 
% This file is available under the terms of the NASA Open Source Agreement
% (NOSA). You should have received a copy of this agreement with the
% Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
% 
% No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
% WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
% INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
% WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
% INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
% FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
% TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
% CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
% OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
% OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
% FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
% REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
% AND DISTRIBUTES IT "AS IS."
% 
% Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
% AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
% SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
% THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
% EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
% PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
% SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
% STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
% PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
% REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
% TERMINATION OF THIS AGREEMENT.
%


% Reset random number generators.
randn('state', 0);
rand('twister', 5489);

% Define basic parameters.
nGridPoints = 65;
nBackPixels = nGridPoints * nGridPoints;
nTargets = 20;

nCadences = 200;
polyOrder = 2;

nominalPoly = [250e3; 9.5; 1.3; 6.1; 5.3; 13.3];
backgroundSigma = 2e3;

confidenceLevel = 0.95;

unitFlux = 10e6;

% Define basic fields in PA input structure.
paBackgroundFileName = 'pa_background.mat';
paStateFileName = 'pa_state.mat';
paInputUncertaintiesFileName = 'pa_input_uncertainties.mat';
paFileStruct.paBackgroundFileName = paBackgroundFileName;
paFileStruct.paStateFileName = paStateFileName;
paFileStruct.paInputUncertaintiesFileName = paInputUncertaintiesFileName;

cadenceTimes.startTimestamps = 55555 + (0 : nCadences - 1)' * 0.5 / 24;
cadenceTimes.midTimestamps = cadenceTimes.startTimestamps + 0.25 / 24;
cadenceTimes.endTimestamps = cadenceTimes.midTimestamps + 0.25 / 24;
cadenceTimes.gapIndicators = false([nCadences, 1]);
cadenceTimes.requantEnabled = false([nCadences, 1]);
cadenceTimes.cadenceNumbers = (0 : nCadences - 1)';

paConfigurationStruct.debugLevel = 0;
paConfigurationStruct.cosmicRayCleaningEnabled = false;
paConfigurationStruct.targetPrfCentroidingEnabled = false;
paConfigurationStruct.ppaTargetPrfCentroidingEnabled = true;
paConfigurationStruct.falseCrRejectionRate = 0.0001;
paConfigurationStruct.oapEnabled = false;
paConfigurationStruct.brightRobustThreshold = 0.05;
paConfigurationStruct.minimumBrightTargets = 10;

backgroundConfigurationStruct.aicOrderSelectionEnabled = false;
backgroundConfigurationStruct.fitMaxOrder = 8;
backgroundConfigurationStruct.fitOrder = polyOrder;
backgroundConfigurationStruct.fitMinPoints = 200;

pouConfigurationStruct.pouEnabled = false;
pouConfigurationStruct.compressionEnabled = true;
pouConfigurationStruct.pixelChunkSize = 2500;
pouConfigurationStruct.cadenceChunkSize = 240;
pouConfigurationStruct.interpDecimation = 24;
pouConfigurationStruct.interpMethod = 'linear';

oapAncillaryEngineeringConfigurationStruct.mnemonics = [];
ancillaryPipelineConfigurationStruct.mnemonics = [];
ancillaryAttitudeConfigurationStruct.mnemonics = [];
motionConfigurationStruct.aicOrderSelectionEnabled = false;
encircledEnergyConfigurationStruct.fluxFraction = 0.95;
gapFillConfigurationStruct.madXFactor = 10;

fcConstants.BITS_IN_ADC = 14;
spacecraftConfigMap.entries.mnemonic = [];
prfModel.ccdModule = 2;

paDataStruct.ccdModule = 4;
paDataStruct.ccdOutput = 3;
paDataStruct.cadenceType = 'LONG';
paDataStruct.startCadence = 0;
paDataStruct.endCadence = nCadences - 1;
paDataStruct.firstCall = true;
paDataStruct.lastCall = false;
paDataStruct.fcConstants = fcConstants;
paDataStruct.spacecraftConfigMap = spacecraftConfigMap;
paDataStruct.cadenceTimes = cadenceTimes;
paDataStruct.longCadenceTimes = cadenceTimes;
paDataStruct.paConfigurationStruct = paConfigurationStruct;
paDataStruct.oapAncillaryEngineeringConfigurationStruct = ...
    oapAncillaryEngineeringConfigurationStruct;
paDataStruct.ancillaryPipelineConfigurationStruct = ...
    ancillaryPipelineConfigurationStruct;
paDataStruct.ancillaryAttitudeConfigurationStruct = ...
    ancillaryAttitudeConfigurationStruct;
paDataStruct.backgroundConfigurationStruct = backgroundConfigurationStruct;
paDataStruct.motionConfigurationStruct = motionConfigurationStruct;
paDataStruct.pouConfigurationStruct = pouConfigurationStruct;
paDataStruct.encircledEnergyConfigurationStruct = ...
    encircledEnergyConfigurationStruct;
paDataStruct.gapFillConfigurationStruct = gapFillConfigurationStruct;
paDataStruct.ancillaryEngineeringDataStruct = [];
paDataStruct.ancillaryPipelineDataStruct = [];
paDataStruct.targetStarDataStruct = [];
paDataStruct.attitudeSolutionStruct = [];
paDataStruct.prfModel = prfModel;
paDataStruct.backgroundPolyStruct = [];
paDataStruct.motionPolyStruct = [];
paDataStruct.paFileStruct = paFileStruct;

% Generate the (1-based) background grid.
rowSpacing = 1024 / nGridPoints;
columnSpacing = 1100 / nGridPoints;

gridRows = 21 + round(rowSpacing / 2 + (0 : nGridPoints - 1)' * rowSpacing);
gridColumns = 13 + round(columnSpacing / 2 + (0 : nGridPoints - 1)' * columnSpacing);
[meshRows, meshColumns] = meshgrid(gridRows, gridColumns);

% Set up a dummy background polynomial fit to get a background coefficient
% struct with the correct x,y origins and scale factors. Assign the nominal
% background polynomial.
backgroundCoeffStruct = robust_polyfit2d(meshRows( : ), meshColumns( : ), ...
    nominalPoly(1) * ones([nBackPixels, 1]), ones([nBackPixels, 1]), ...
    polyOrder);

backgroundCoeffStruct.coeffs = nominalPoly;

% Fill the background data struct array.
uncertainties = backgroundSigma * ones([nCadences, 1]);
gapIndicators = false([nCadences, 1]);

backgroundDataStruct = repmat(struct( ...
    'ccdRow', [], ...
    'ccdColumn', [], ...
    'isInOptimalAperture', true, ...
    'values', [], ...
    'uncertainties', uncertainties, ...
    'gapIndicators', gapIndicators ), [1, nBackPixels]);

ccdRowCellArray = num2cell(meshRows( : ));
[backgroundDataStruct(1 : nBackPixels).ccdRow] = ccdRowCellArray{:};
ccdColumnCellArray = num2cell(meshColumns( : ));
[backgroundDataStruct(1 : nBackPixels).ccdColumn] = ccdColumnCellArray{:};

[backgroundValues, zu, Aback] = weighted_polyval2d(meshRows( : ), meshColumns( : ), ...
    backgroundCoeffStruct);
values = repmat(backgroundValues', [nCadences, 1]) + ...
    backgroundSigma * randn([nCadences, nBackPixels]);

for i = 1 : nBackPixels
    backgroundDataStruct(i).values = values( : , i);
end

clear values

paDataStruct.backgroundDataStruct = backgroundDataStruct;

% Instantiate a PA data object and initialize an output structure.
[paDataObject] = paDataClass(paDataStruct);
[paResultsStruct] = initialize_pa_output_structure(paDataObject);

% Fit the background.
backgroundPolyStruct = [];                                                                 %#ok<NASGU>
nInvocations = 2;                                                                          %#ok<NASGU>
save(paStateFileName, 'backgroundPolyStruct', 'nInvocations');

[paResultsStruct, backgroundPolyStruct] = ...
    fit_background(paDataObject, paResultsStruct);

% Compute the theoretical covariance matrix for the fit parameters.
Cback = repmat(backgroundSigma ^ 2, [nBackPixels, 1]);
pinvAback = pinv(Aback);
Cparams = scalerow(Cback, pinvAback) * pinvAback';

% Generate random target locations. All targets must lie within  the visible
% region of the CCD.
referenceRows = 22 + fix(1022 * rand([nTargets, 1]));
referenceColumns = 14 + fix(1098 * rand([nTargets, 1]));

[targetRows, targetColumns, targetValues] = ...
    define_targets(referenceRows, referenceColumns);

targetValues = targetValues * unitFlux;

% Populate the target star data structure. There are five pixels per target
% for this test.
targetStarDataStruct = repmat(struct( ...
    'keplerId', 0, ...
    'labels', '', ...
    'raHours', 12.3, ...
    'decDegrees', 45, ...
    'keplerMag', 12, ...
    'fluxFractionInAperture', 1.0, ...
    'referenceRow', [], ...
    'referenceColumn', [], ...
    'pixelDataStruct', []), [1, nTargets]);

referenceRowCellArray = num2cell(referenceRows);
[targetStarDataStruct(1 : nTargets).referenceRow] = ...
    referenceRowCellArray{:};
referenceColumnCellArray = num2cell(referenceColumns);
[targetStarDataStruct(1 : nTargets).referenceColumn] = ...
    referenceColumnCellArray{:};

[backgroundValues, zu, Atarg] = weighted_polyval2d(targetRows, targetColumns, backgroundCoeffStruct);
targetUncertainties = sqrt(backgroundValues + targetValues);
values = repmat((backgroundValues + targetValues)', [nCadences, 1]) + ...
    repmat(targetUncertainties', [nCadences, 1]) .* randn([nCadences, 5 * nTargets]);

index = 1;

for i = 1 : nTargets
    
    gapIndicators = false([nCadences, 1]);
    
    pixelDataStruct = repmat(struct( ...
        'ccdRow', [], ...
        'ccdColumn', [], ...
        'isInOptimalAperture', true, ...
        'values', [], ...
        'uncertainties', [], ...
        'gapIndicators', gapIndicators), [1, 5]);
    
    targetRowCellArray = num2cell(targetRows(index : index+4));
    [pixelDataStruct(1 : 5).ccdRow] = targetRowCellArray{:};
    targetColumnCellArray = num2cell(targetColumns(index : index+4));
    [pixelDataStruct(1 : 5).ccdColumn] = targetColumnCellArray{:};

    valuesCellArray = num2cell(values( : , index:index+4), 1);
    [pixelDataStruct(1 : 5).values] = valuesCellArray{:};
    uncertaintiesCellArray = num2cell(repmat(targetUncertainties(index:index+4)', [nCadences, 1]), 1);
    [pixelDataStruct(1 : 5).uncertainties] = uncertaintiesCellArray{:};
    
    targetStarDataStruct(i).pixelDataStruct = pixelDataStruct;
    
    index = index + 5;
    
end

clear values

paDataStruct.targetStarDataStruct = targetStarDataStruct;
paDataStruct.backgroundDataStruct = [];
paDataStruct.backgroundPolyStruct = backgroundPolyStruct;

% Instantiate a PA data object.
[paDataObject] = paDataClass(paDataStruct);

% Remove the background and delete the local files.
[paDataObject] = ...
    remove_background_from_targets(paDataObject);
delete(paStateFileName);
delete(paBackgroundFileName);

% Get the updated target star data structure with the background removed
% target pixels.
newTargetStarDataStruct = get_target_star_data_struct(paDataObject);
pixelDataStruct = [newTargetStarDataStruct.pixelDataStruct];
pixelValues = [pixelDataStruct.values];
pixelUncertainties = [pixelDataStruct.uncertainties];                                      %#ok<NASGU>

% Compute the theoretical covariance matrix for the background removed
% target pixels. One component is due to the uncertainties in the pixel
% values (with background) and the second component is due to the uncertainty
% in the background estimate.
Ctarg = diag(targetUncertainties .^ 2);
Cest = Atarg * Cparams * Atarg';
CtargMinusBack = Ctarg + Cest;

% Determine confidence level per test.
nPixels = size(CtargMinusBack, 1);
confidenceLevelPerTest = confidenceLevel ^ (1 / nPixels);

% Compare results for the mean and standard deviations of all pixel levels.
disp(' ');
disp(['Number of target pixels = ', num2str(nPixels)]);
disp(['Confidence level = ', num2str(confidenceLevel), ...
    '; Confidence level per test = ', num2str(confidenceLevelPerTest)]);
disp(' ');

disp('Performing chi-square tests to validate variance in pixel levels.');
messageOut = sprintf( ...
    'Background removal failed; variance in pixel levels is not sufficiently close to theoretical variance');
normalizedValues = (pixelValues - repmat(targetValues', [nCadences, 1])) ...
    ./ repmat(sqrt(diag(CtargMinusBack)'), [nCadences, 1]);
[hv, pv] = vartest(normalizedValues, 1, 1 - confidenceLevelPerTest);                       %#ok<NASGU>
assert_equals(hv, zeros(size(hv)), messageOut);

disp('Performing z-tests to validate mean in pixel levels.');
messageOut = sprintf( ...
    'Background removal failed; mean in pixel levels is not sufficiently close to target pixel values');
[hz, pz] = ztest(normalizedValues, 0, 1, 1 - confidenceLevelPerTest);                      %#ok<NASGU>
assert_equals(hz, zeros(size(hz)), messageOut);

% Return.
return


function [targetRows, targetColumns, targetValues] = ...
define_targets(referenceRows, referenceColumns)
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% function [targetRows, targetColumns, targetValues] = ...
% define_targets(referenceRows, referenceColumns)
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% Place five pixels per target with random amplitude times the following
% prf:
%             0.4
%        0.8  1.0  0.6
%             0.2
%
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

nTargets = length(referenceRows);
levels = 1 + 49 * rand([nTargets, 1]);

targetRows = [];
targetColumns = [];
targetValues = [];

for i = 1 : nTargets
    r = referenceRows(i);
    c = referenceColumns(i);
    l = levels(i);
    targetRows = [targetRows; r; r; r; r+1; r-1];                                          %#ok<AGROW>
    targetColumns = [targetColumns; c; c-1; c+1; c; c];                                    %#ok<AGROW>
    newValues = l * [1; 0.8; 0.6; 0.4; 0.2];
    targetValues = [targetValues; newValues];                                              %#ok<AGROW>
end

% Return.
return
    