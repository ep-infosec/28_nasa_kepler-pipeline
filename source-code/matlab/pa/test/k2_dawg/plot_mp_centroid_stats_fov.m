function plot_mp_centroid_stats_fov(rootTaskDir, outputDir, channels, campaign)
%**************************************************************************
% plot_mp_centroid_stats_fov(rootTaskDir, outputDir, channels, campaign)
%**************************************************************************
% Examine the number of centroids used in motion polynomial computation for
% each channel at each cadence and plot statistics across the FOV. Also
% examine the results of RA/Dec fitting for each channel. We expect poorer
% motion polynomials on channels with fewer centroids contributing to the
% fits. It is therefore expected that, if stars are allowed to drift freely
% in the RA/Dec fitting as they were in 9.3 V&V processing, that we would
% see larger median offsets on channels with poorer motion polynomials.
%
% INPUTS
%     rootTaskDir : The full path to the directory containing task 
%                   directories for the pipeline instance (this is the
%                   directory containing the uow/ subdirectory).
%     outputDir   : Where to save the figures generated by this function.
%     channels    : A list of channels to process.
%     campaign    :
%
% OUTPUTS
%     Generates figures and saves them to 'outputDir'.
%**************************************************************************
% 
% Copyright 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% 
% NASA acknowledges the SETI Institute's primary role in authoring and
% producing the Kepler Data Processing Pipeline under Cooperative
% Agreement Nos. NNA04CC63A, NNX07AD96A, NNX07AD98A, NNX11AI13A,
% NNX11AI14A, NNX13AD01A & NNX13AD16A.
% 
% This file is available under the terms of the NASA Open Source Agreement
% (NOSA). You should have received a copy of this agreement with the
% Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
% 
% No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
% WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
% INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
% WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
% INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
% FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
% TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
% CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
% OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
% OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
% FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
% REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
% AND DISTRIBUTES IT "AS IS."
% 
% Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
% AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
% SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
% THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
% EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
% PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
% SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
% STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
% PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
% REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
% TERMINATION OF THIS AGREEMENT.
%
    
    if ~exist(outputDir, 'dir')
        mkdir(outputDir);
    end
    
    if ~exist('channels', 'var')
        channels = 1:84;
    end
    
    if ~exist('campaign', 'var')
        campaign = [];
    end
   
    [modules, outputs] = convert_mod_out_to_from_channel(channels);

    startingDir = pwd;
    cd(outputDir);

    initArray = zeros(length(channels), 1);
    
    nValidMotionPolys   = initArray;
    minNzCentroids      = initArray;
    maxCentroids        = initArray;
    medianNzCentroids   = initArray;
    medianOffsetDegrees = initArray;
    
    for iChannel = 1:length(channels)
        fprintf('Processing channel %d ...\n', channels(iChannel));
        
        % -----------------------------------------------------------------
        % Load data for the current channel.
        % -----------------------------------------------------------------
        paTaskDir = get_group_dir( 'PA', channels(iChannel), ...
            'quarter',  campaign, 'rootPath', ...
            rootTaskDir, 'fullPath', true);
        paTaskDir = paTaskDir{1};
        
        if isempty(paTaskDir)
            warning('Group directory for channel %d is unavailable.', channels(iChannel));
            continue
        end
        
        % We read the motion polys from the pa_motion.mat file because the
        % motionPolyStruct variable in the state file has been interpolated
        % and we want to look at the raw results.
        load( fullfile(paTaskDir, 'pa_motion.mat') );
        
        if ~exist('inputStruct', 'var')
            warning('Unable to load motion polynomial struct.');
            continue
        end
        
        motionPolyStruct = inputStruct;
        
        % nRow Centroids and nColumn Centroids are nCadence-length arrays
        % whose values represent the number of centroids having non-zero
        % weights in the LS fit that yields the motion polynomials.
        % Effectively, the number of points used in the fit.
        load( fullfile(paTaskDir, 'pa_state.mat'), ...
            'nRowCentroids', 'nColumnCentroids');
        
        if ~exist('nRowCentroids', 'var')
            warning('Unable to load state variable nRowCentroids');
            continue
        end
        
        if ~exist('nColumnCentroids', 'var') 
            warning('Unable to load state variable nColumnCentroids');
            continue
        end

        % Load results of RA/Dec/Mag fitting.
        load( fullfile(paTaskDir, 'pa_state.mat'), 'raDecMagFitResults');
        
        if ~exist('raDecMagFitResults', 'var')
            warning('Unable to load state variable raDecMagFitResults. Continuing to next channel ...');
            continue
        elseif isempty(raDecMagFitResults)
            warning('State variable raDecMagFitResults is empty. Continuing to next channel ...');
            continue
        end
        
        % -----------------------------------------------------------------
        % Compute stats for the current channel.
        % -----------------------------------------------------------------
        nCadences = numel(motionPolyStruct);

        mpStatus = colvec([motionPolyStruct.rowPolyStatus] & ...
            [motionPolyStruct.colPolyStatus]);
        nValidMotionPolys(iChannel) = nnz(mpStatus);

        nCentroids = min(colvec(nRowCentroids), colvec(nColumnCentroids));
        minNzCentroids(iChannel) = min( nCentroids(mpStatus) );
        maxCentroids(iChannel) = max( nCentroids );
        medianNzCentroids(iChannel) = max( nCentroids(mpStatus) );
        
        lockRaDec = [raDecMagFitResults.lockRaDec];
        
        catalogRaDegrees  = colvec([raDecMagFitResults(~lockRaDec).catalogRaDegrees]);
        catalogDecDegrees = colvec([raDecMagFitResults(~lockRaDec).catalogDecDegrees]);
        fittedRaDegrees   = colvec([raDecMagFitResults(~lockRaDec).raDegrees]);
        fittedDecDegrees  = colvec([raDecMagFitResults(~lockRaDec).decDegrees]);
        offsetDegrees = angular_separation_degrees( ...
            [fittedRaDegrees, fittedDecDegrees], ...
            [catalogRaDegrees, catalogDecDegrees] );
        medianOffsetDegrees(iChannel) = median(offsetDegrees);
    end
    
    save(fullfile(outputDir, 'mp_centroid_stats.mat'), ...
        'channels', 'nValidMotionPolys','minNzCentroids', 'maxCentroids', 'medianNzCentroids');

    % ---------------------------------------------------------------------
    % Generate figures
    % ---------------------------------------------------------------------
    h = fovPlottingClass.plot_on_modout(modules, outputs, nValidMotionPolys);
    h = fovPlottingClass.make_ccd_legend_plot(h);
    title(sprintf('Number Of Valid MPs (of %d cadences)', nCadences));
    saveas(h, fullfile(outputDir, 'num_valid_mps_per_channel.fig'));

    h = fovPlottingClass.plot_on_modout(modules, outputs, minNzCentroids);
    h = fovPlottingClass.make_ccd_legend_plot(h);
    title('Minimum Number of Centroids in Computation Of Valid MPs On Any Cadence');
    saveas(h, fullfile(outputDir, 'min_num_centroids_per_channel.fig'));

    h = fovPlottingClass.plot_on_modout(modules, outputs, maxCentroids);
    h = fovPlottingClass.make_ccd_legend_plot(h);
    title('Maximum Number of Centroids in Computation Of Valid MPs On Any Cadence');
    saveas(h, fullfile(outputDir, 'max_num_centroids_per_channel.fig'));

    h = fovPlottingClass.plot_on_modout(modules, outputs, medianNzCentroids);
    h = fovPlottingClass.make_ccd_legend_plot(h);
    title('Median Number of Centroids in Computation Of Valid MPs');
    saveas(h, fullfile(outputDir, 'median_num_centroids_per_channel.fig'));
    
    h = fovPlottingClass.plot_on_modout(modules, outputs, medianOffsetDegrees);
    h = fovPlottingClass.make_ccd_legend_plot(h);
    title('Median Offset (Degrees) Of Fitted Star Positions');
    saveas(h, fullfile(outputDir, 'median_offset_per_channel.fig'));

    cd(startingDir);
end


function degrees = angular_separation_degrees( raDec1, raDec2 )
%**************************************************************************
% Compute the angular separation (degrees) between two points on the unit
% celestial sphere given in degrees. 
%
% INPUTS
%     raDec1  : A Nx2 matrix with RA in the first column and Dec in the
%               second, both in degrees.
%     raDec2  : A Nx2 matrix with RA in the first column and Dec in the
%               second, both in degrees.
% OUTPUTS
%     degrees : An Nx1 array containing the angular separation in degrees
%               bewteen each pair of points in the inputs, raDec1(iPoint,:)
%               and raDec2(iPoint,:).  
%
%**************************************************************************
    xyz1 = convert_ra_dec_to_xyz( raDec1 );
    xyz2 = convert_ra_dec_to_xyz( raDec2 );

    dotProd = dot(xyz1, xyz2, 2); % Dot products of row vectors
    dotProd(dotProd > 1.0) = 1; % Clamp values before calling acos()
    dotProd(dotProd < -1.0) = -1;

    degrees = acosd(dotProd);
end


function xyz = convert_ra_dec_to_xyz( raDec )
%**************************************************************************
% Convert from celestial to cartesian coordinates.
% raDec is in degrees.
% xyz is in a right-handed coord system with:
%     +x toward RA = Dec = 0
%     +z toward celestial north pole
%**************************************************************************
    ra  = (pi/180)*raDec(:,1);
    dec = (pi/180)*raDec(:,2);
    xyz = [ cos( ra ).*cos( dec ), cos( dec ).*sin( ra ), sin( dec ) ];
end


%**************************************************************************
% format_current_figure.m 
% Format all axes in the current figure.
%**************************************************************************
function h_fig = format_current_figure(dataLabels, setLineWidth)

    if ~exist('setLineWidth', 'var')
        setLineWidth = true;
    end
    
    % Get handles for all non-legend axes.
    h_fig   = gcf();
    children = get(h_fig, 'Children');
    h_axes = findobj(children, 'Type', 'axes','-not','Tag','legend');
    
    for iAxes = 1:length(h_axes)
        format_axes(h_axes(iAxes), dataLabels, setLineWidth);
    end

    refreshdata(h_fig);
end

%**************************************************************************
function format_axes(h_axes, dataLabels, setLineWidth)
    FONT = 'Arial';
    LINE_WIDTH = 1.0;
    LINE_WIDTH_DELTA = 1;
        
    h_leg   = legend(h_axes);
    h_title = get(h_axes,'Title');
    h_xlab  = get(h_axes,'XLabel');
    h_ylab  = get(h_axes,'YLabel');

    axesProperties = struct(...
        'FontName',  FONT, ...
        'FontUnits', 'points', ...
        'FontSize', 14, ...
        'FontWeight', 'normal', ...
        'LineWidth', 1 ...
        );

    xLabelProperties = struct(...
        'FontName',  FONT, ...
        'FontUnits', 'points', ...
        'FontSize', 14, ...
        'FontWeight', 'bold' ...
        );

    titleProperties  = struct(...
        'FontName',  FONT, ...
        'FontUnits', 'points', ...
        'FontSize', 16, ...
        'FontWeight', 'bold' ...
        );

    legendProperties  = struct(...
        'FontName',  FONT, ...
        'FontUnits', 'points', ...
        'FontSize', 14, ...
        'FontWeight', 'normal' ...
        );

    set(h_axes,  axesProperties);
    set(h_title, titleProperties);
    set(h_xlab,  xLabelProperties);
    set(h_ylab,  xLabelProperties);
    set(h_leg,   legendProperties);

    % Modify line widths, if desired.
    if setLineWidth
        h_tmp = get(h_axes, 'Children');
        h_line = findobj(h_tmp, 'Type', 'line');

        % Find lines representing data series
        h_data = [];
        for n = 1:length(h_line)
            if any(strcmp( get(h_line(n), 'DisplayName'), dataLabels ))
                h_data = [h_data, h_line(n)];
            end
        end

        % Plot lines with increasing width (the list of child handles is in the
        % reverse plotting order).
        for i = 1:length(h_data)
            set(h_data(i), 'LineWidth', LINE_WIDTH + i*LINE_WIDTH_DELTA);
        end
    end
    
end
