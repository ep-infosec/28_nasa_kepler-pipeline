function test_wavelet_domain_variance_estimation(noiseTypeString, s)
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% function test_wavelet_domain_variance_estimation.m
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%
% Function Name: test_wavelet_domain_variance_estimation.m
%
% Goal: To establish that the estimation of variance in the wavelet domain
% is done correctly.
% To create a time varying noise variance in each channel,
% (1) create a white noise sequence
% (2) take the overcomplete wavelet expansion of the sequence
% (3) nScales the variance in each nScales(channel) differently at marked
% intervals to mimic non-stationary process
% (4) recombine (reconstruct multiresolution signals) the channels to
% create the test sequence
% (5) now estimate the noise variance and the test statistic
% (6) see how agile the adaptive matched filter detector is.
%
%
% Description: This function demonstrates the estimation of variance in
% various scales (band pass) of wavelet domain.
% NOTE:  Remember that time varying channel variance estimates are made in
% the wavelet domain over a window whose length increases as 2^(i)K+1 for
% each nScales i. What this means is, for the lowest band pass (highest nScales
% - in wavelet domain, lowest nScales implies highest freq band and vice
% versa), the window is the longest but the samples are not independent-->
% thus spread of the estimator is minimum. On the contrary, the estimation
% window length is minimum for the lowest nScales (highest freq band) and the
% spread is the maximum.
%
% Input:
%       A long sequence of white gaussian noise generated by invoking
%       sqrt(var)*randn(2^16,1)
% Output:
%       plots of estimation of channel variances of
%       non-stationary time series using OWT
%
%
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% 
% Copyright 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% 
% NASA acknowledges the SETI Institute's primary role in authoring and
% producing the Kepler Data Processing Pipeline under Cooperative
% Agreement Nos. NNA04CC63A, NNX07AD96A, NNX07AD98A, NNX11AI13A,
% NNX11AI14A, NNX13AD01A & NNX13AD16A.
% 
% This file is available under the terms of the NASA Open Source Agreement
% (NOSA). You should have received a copy of this agreement with the
% Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
% 
% No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
% WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
% INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
% WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
% INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
% FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
% TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
% CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
% OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
% OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
% FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
% REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
% AND DISTRIBUTES IT "AS IS."
% 
% Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
% AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
% SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
% THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
% EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
% PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
% SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
% STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
% PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
% REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
% TERMINATION OF THIS AGREEMENT.
%


%close all;
% clc;
% clear;


%--------------------------------------------------------------------------
% Create a non-stationary time series (time varying noise variance
% possibly in one or more band pass channel)
% (1) create a white noise sequence
% (2) take the overcomplete wavelet expansion of the sequence
% (3) scale the variance in each scale differently at marked
%     intervals to mimic a non-stationary process
% (4) recombine (reconstruct multiresolution signals) the channels to
%     create the test sequence
%--------------------------------------------------------------------------

% packagae each trial as a star

nMonteCarloTrials = 100;

noiseSigmaInPpm = 20*1e-6;

logLength = 12; % sequence length

waveletFilterLength = 12; % using Daubechies 12 tap scaling filter

varianceFirstHalf = 0.75;
varianceSecondHalf = 0.1;


s.tpsModuleParameters.trialTransitPulseInHours = 6;
s.tpsModuleParameters.storeCdppFlag = true;
s.gapFillParameters.cadenceDurationInMinutes = 30;
s.tpsModuleParameters.varianceWindowLengthMultiplier = 5;
cadencesPerHour = 2;


h0 = daubechies_low_pass_scaling_filter(waveletFilterLength);

nCadences = 2^logLength;
n2 = 2^(logLength-1); % between n1+1 and n2 variance is sigma2


% find out how many stages of filtering to do
% for any signal that is band limited, there will be an upper nScales j = J,
% above which the wavelet coefficients are negligibly small
%nScales = log2(nCadences)-floor(log2(waveletFilterLength))+1;
nScales = log2(nCadences)-floor(log2(waveletFilterLength));


% fill variable sigma matrix by invoking rand and filling with unique
% fractions

% decided to assign hand picked but different variances for each band
% passes anyway....
% the code comes in handy should anyone decide to assign random fractions
% to various channels

rand('twister',0); % this ensures that randperm returns the same sequence every time
waveletCoefftsXFactor = ones(nCadences, nScales+1);

noiseSigmaInEachScale = ones(nScales+1,1)*noiseSigmaInPpm;

if (strcmp(noiseTypeString, 'whiteNoise'))

    for jScale = 1:nScales+1
        noiseSigmaInEachScale(jScale) = 1;
        waveletCoefftsXFactor(:,jScale) = noiseSigmaInEachScale(jScale);
        noiseSigmaInEachScale(jScale) = noiseSigmaInEachScale(jScale)*noiseSigmaInPpm;
    end

elseif(strcmp(noiseTypeString, 'coloredNoise'))

    for jScale = 1:nScales+1
        noiseSigmaInEachScale(jScale) = min(0.2*jScale,1);
        waveletCoefftsXFactor(:,jScale) = noiseSigmaInEachScale(jScale);
        noiseSigmaInEachScale(jScale) = noiseSigmaInEachScale(jScale)*noiseSigmaInPpm;
    end


elseif(strcmp(noiseTypeString, 'timeVaryingWhiteNoise'))


    for jScale = 1:nScales+1
        noiseSigmaInEachScale(jScale) = 1;
        waveletCoefftsXFactor(:,jScale) = noiseSigmaInEachScale(jScale);
        noiseSigmaInEachScale(jScale) = noiseSigmaInEachScale(jScale)*noiseSigmaInPpm;
    end
    waveletCoefftsXFactor(1:n2,:) = waveletCoefftsXFactor(1:n2,:)*varianceFirstHalf;
    waveletCoefftsXFactor(n2+1:end,:) = waveletCoefftsXFactor(n2+1:end,:)*varianceSecondHalf;



elseif(strcmp(noiseTypeString, 'timeVaryingColoredNoise'))

    for jScale = 1:nScales+1
        noiseSigmaInEachScale(jScale) = min(0.2*jScale,1);
        waveletCoefftsXFactor(:,jScale) = noiseSigmaInEachScale(jScale);
        noiseSigmaInEachScale(jScale) = noiseSigmaInEachScale(jScale)*noiseSigmaInPpm;
    end
    waveletCoefftsXFactor(1:n2,:) = waveletCoefftsXFactor(1:n2,:)*varianceFirstHalf;
    waveletCoefftsXFactor(n2+1:end,:) = waveletCoefftsXFactor(n2+1:end,:)*varianceSecondHalf;

else
    fprintf('The string type can only be ''whiteNoise'',  ''coloredNoise'',  ''timeVaryingWhiteNoise'', ''timeVaryingColoredNoise''\n');
end



%
% x = (1:nCadences)';
% x = x-mean(x);
% a = 1*1e-2;
% % waveletCoefftsXFactor(1:n2,:) = 0.1;
% % waveletCoefftsXFactor(n2+1:end,:) = 0.5;
% sigmoidFunction = ((0.5-0.1)./(1+exp(-a*x))) + 0.1;
%
% for jScale = 1:nScales+1
%     waveletCoefftsXFactor(:,jScale) = sigmoidFunction;
% end



meanNonStationarySequence = 1.0; % this mean is needed as time series will be scaled by this mean in TPSLite
s.tpsTargets(nMonteCarloTrials+1:end) = [];
% allocate memory
for jTrial = 1:nMonteCarloTrials
    s.tpsTargets(jTrial).fluxValue = zeros(nCadences, 1);
    s.tpsTargets(jTrial).gapIndices = [];
    s.tpsTargets(jTrial).fillIndices = [];
    s.tpsTargets(jTrial).uncertainty = zeros(nCadences, 1);
end




for jTrial = 1:nMonteCarloTrials

    %--------------------------------------------------------------------------
    % Create a non-stationary time series (time varying noise variance
    % possibly in one or more band pass channel)
    % (1) create a white noise sequence
    %--------------------------------------------------------------------------

    whiteNoise = noiseSigmaInPpm*randn(nCadences,1);


    %--------------------------------------------------------------------------
    % (2) take the overcomplete wavelet expansion of the sequence
    %--------------------------------------------------------------------------

    [whiteNoiseWaveletCoeffts] = overcomplete_wavelet_transform(whiteNoise,h0,nScales);


    %--------------------------------------------------------------------------
    % reconstruct the test signal which will have time varying variances
    % in each band pass
    %--------------------------------------------------------------------------

    nonStationarySequence = reconstruct_in_frequency_domain(whiteNoiseWaveletCoeffts,h0);

    %--------------------------------------------------------------------------
    % (3) scale the variance in each scale differently at marked
    %     intervals to mimic a non-stationary process
    %--------------------------------------------------------------------------

    for i = 1:nScales+1
        nonStationarySequence(:,i) = nonStationarySequence(:,i).* waveletCoefftsXFactor(:,i);
    end;



    nonStationarySequence = sum(nonStationarySequence,2);

    nonStationaryWaveletCoefficients = overcomplete_wavelet_transform(nonStationarySequence,h0,nScales);


    %--------------------------------------------------------------------------
    % replace the target flux value with nonstationary colred gaussian
    % noise sequence
    %--------------------------------------------------------------------------
    s.tpsTargets(jTrial).fluxValue = nonStationarySequence + meanNonStationarySequence;

end


%--------------------------------------------------------------------------
% prepare the input struct for instantiation
%--------------------------------------------------------------------------
s.cadenceTimes.startTimestamps = s.cadenceTimes.startTimestamps(1:nCadences);
s.cadenceTimes.midTimestamps = s.cadenceTimes.midTimestamps(1:nCadences);
s.cadenceTimes.gapIndicators = false(nCadences,1);
s.cadenceTimes.requantEnabled = true(nCadences,1);


%--------------------------------------------------------------------------
% prepare the input struct for instantiation
%--------------------------------------------------------------------------

% step 3
[tpsOutputStruct] = tps_matlab_controller(s);

%--------------------------------------------------------------------------
% compute analytically the SNR and then the noise; compare with estimated
% cdpp
%--------------------------------------------------------------------------
if (strcmp(s.tpsModuleParameters.waveletFamily, 'daub'))
    h0 = daubechies_low_pass_scaling_filter(s.tpsModuleParameters.waveletFilterLength);
    % invoke relevant functions when using scaling filter from another wavelet family
end
transitPulse = -ones(cadencesPerHour*s.tpsModuleParameters.trialTransitPulseInHours,1);
varianceEstimationWindowLength = length(transitPulse) * s.tpsModuleParameters.varianceWindowLengthMultiplier;


%--------------------------------------------------------------------------
% plot analytically computed noise versus cdpp
%--------------------------------------------------------------------------
paperOrientationFlag = false; % not landscape
includeTimeFlag = false;
printJpgFlag = true;
if (strcmp(noiseTypeString, 'whiteNoise'))

    snrTimeSeries = compute_snr_using_known_noise_whitened_transit(noiseSigmaInEachScale, nCadences, h0, transitPulse, varianceEstimationWindowLength);
    h1 = plot(mean(cat(2,tpsOutputStruct.tpsResults.cdppTimeSeries),2));grid minor;
    hold on;
    h2 = plot(1e6./snrTimeSeries, 'r');
    legend([h1 h2], {'mesaured cdpp', 'analytical cdpp'});
    title('(White Noise) CDPP Meaured versus Analytical')
    hold off;

    fileNameStr = 'whiteNoiseCDPP';
    plot_to_file(fileNameStr, paperOrientationFlag, includeTimeFlag, printJpgFlag);
elseif(strcmp(noiseTypeString, 'coloredNoise'))


    snrTimeSeries = compute_snr_using_known_noise_whitened_transit(noiseSigmaInEachScale, nCadences, h0, transitPulse, varianceEstimationWindowLength);
    h1 = plot(mean(cat(2,tpsOutputStruct.tpsResults.cdppTimeSeries),2));grid minor;
    hold on;
    h2 = plot(1e6./snrTimeSeries, 'r');
    legend([h1 h2], {'mesaured cdpp', 'analytical cdpp'});
    title('(Colored Noise) CDPP Meaured versus Analytical');
    hold off;
    fileNameStr = 'coloredNoiseCDPP';
    plot_to_file(fileNameStr, paperOrientationFlag, includeTimeFlag, printJpgFlag);

elseif(strcmp(noiseTypeString, 'timeVaryingWhiteNoise'))

    snrTimeSeries1 = compute_snr_using_known_noise_whitened_transit(noiseSigmaInEachScale*varianceFirstHalf, n2, h0, transitPulse, varianceEstimationWindowLength);
    snrTimeSeries2 = compute_snr_using_known_noise_whitened_transit(noiseSigmaInEachScale*varianceSecondHalf, n2, h0, transitPulse, varianceEstimationWindowLength);
    h1 = plot(mean(cat(2,tpsOutputStruct.tpsResults.cdppTimeSeries),2));grid minor;
    hold on;
    h2 = plot(1:n2, 1e6./snrTimeSeries1, 'r');
    plot(n2+1:2*n2, 1e6./snrTimeSeries2, 'r');
    legend([h1 h2], {'mesaured cdpp', 'analytical cdpp'});
    title('(Time varying White Noise) CDPP Meaured versus Analytical');

    hold off;
    fileNameStr = 'timeVaryingWhiteNoiseCDPP';
    plot_to_file(fileNameStr, paperOrientationFlag, includeTimeFlag, printJpgFlag);

elseif(strcmp(noiseTypeString, 'timeVaryingColoredNoise'))

    snrTimeSeries1 = compute_snr_using_known_noise_whitened_transit(noiseSigmaInEachScale*varianceFirstHalf, n2, h0, transitPulse, varianceEstimationWindowLength);
    snrTimeSeries2 = compute_snr_using_known_noise_whitened_transit(noiseSigmaInEachScale*varianceSecondHalf, n2, h0, transitPulse, varianceEstimationWindowLength);
    h1 = plot(mean(cat(2,tpsOutputStruct.tpsResults.cdppTimeSeries),2));grid minor;
    hold on;
    h2 = plot(1:n2, 1e6./snrTimeSeries1, 'r');
    plot(n2+1:2*n2, 1e6./snrTimeSeries2, 'r');
    legend([h1 h2], {'mesaured cdpp', 'analytical cdpp'});
    title('(Time varying Colored Noise) CDPP Meaured versus Analytical');

    hold off;
    fileNameStr = 'timeVaryingColoredNoiseCDPP';
    plot_to_file(fileNameStr, paperOrientationFlag, includeTimeFlag, printJpgFlag);

else
    fprintf('The string type can only be ''whiteNoise'',  ''coloredNoise'',  ''timeVaryingWhiteNoise'', ''timeVaryingColoredNoise''\n');
end


return
