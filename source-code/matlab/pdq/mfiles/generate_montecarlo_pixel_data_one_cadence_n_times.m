function generate_montecarlo_pixel_data_one_cadence_n_times(pdqInputStruct, optionsStruct,nRealizations)
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% function generate_montecarlo_pixel_data_one_cadence_n_times(turnOffNoiseFlag, useOneModOutFlag)
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%  This function generates Monte Carlo reference pixel data structure tby
%  (1) first loading a pdq input structure obtained from reading an inputs.bin
%  generated by the pipeline
%  (2) replacing the pixel time series values for the chosen modouts by Monte Carlo data
%
% nRealizations = number realizations to generate
% remember that every realization has 'nRepeatedCadences' realizations of the same time stamp
% the idea behind providing the additional parameter 'nRealizations' is, incase we want to generate 1000 realizations of
% the same time stamp we can do it in stages. Remember that PDQ can't process more than 150 cadence sor so at a time.
%
% optionsStruct =
%
%      useOneModOutFlag: 0
%      turnOffNoiseFlag: 1
%           blackPolyOn: 0
%     nRepeatedCadences: 10
%          underShootOn: 0
%
% 'turnOffNoiseFlag' if set to 'true' will prevent adding shot noise, read
% noise, and quantization noise to the data
%
% modulesToKeep: data will be simulated for the specified modules only even if the inputs contain more modouts
% for example modulesToKeep = [2 4; 4 3; 22 3; 24 4; 13 2; ];
%
% 'nRepeatedCadences'  = 1 cadence repeated 'nRepeatedCadences' times
% (the firstcadence will be repeted 'nRepeatedCadences' times)
%
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% 
% Copyright 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% 
% NASA acknowledges the SETI Institute's primary role in authoring and
% producing the Kepler Data Processing Pipeline under Cooperative
% Agreement Nos. NNA04CC63A, NNX07AD96A, NNX07AD98A, NNX11AI13A,
% NNX11AI14A, NNX13AD01A & NNX13AD16A.
% 
% This file is available under the terms of the NASA Open Source Agreement
% (NOSA). You should have received a copy of this agreement with the
% Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
% 
% No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
% WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
% INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
% WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
% INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
% FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
% TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
% CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
% OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
% OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
% FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
% REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
% AND DISTRIBUTES IT "AS IS."
% 
% Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
% AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
% SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
% THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
% EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
% PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
% SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
% STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
% PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
% REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
% TERMINATION OF THIS AGREEMENT.
%

% generate_montecarlo_pixel_data.m
% s =
%         pdqConfiguration: [1x1 struct]
%              fcConstants: [1x1 struct]
%               configMaps: [1x1 struct]
%             cadenceTimes: [4x1 double]
%                gainModel: [1x1 struct]
%           raDec2PixModel: [1x1 struct]
%          twoDBlackModels: [1x84 struct]
%          flatFieldModels: [1x84 struct]
%           readNoiseModel: [1x1 struct]
%           inputPdqTsData: [1x1 struct]
%        stellarPdqTargets: [1x579 struct]
%     backgroundPdqTargets: [1x84 struct]
%     collateralPdqTargets: [1x1260 struct]


% turnOffNoiseFlag = false;
% useOneModOutFlag = true;
% blackPolyOn = true;
% nRepeatedCadences = 200;
% generate_montecarlo_pixel_data_one_cadence_n_times(turnOffNoiseFlag, useOneModOutFlag, blackPolyOn, nRepeatedCadences);

%optionsStruct = struct('useOneModOutFlag', true, 'turnOffNoiseFlag', true, 'blackPolyOn', false, 'nRepeatedCadences' , 25, 'underShootOn', false);

% nRealizations = number realizations to generate
% remember that every realization has 'nRepeatedCadences' realizations of the same time stamp
% the idea behind providing the additional parameter 'nRealizations' is, incase we want to generate 1000 realizations of
% the same time stamp we can do it in stages. Remember that PDQ can't process more than 150 cadence sor so at a time.
if(~exist('nRealizations', 'var'))
    nRealizations = 1;
end

s = pdqInputStruct; % copy input struct to s


modulesToKeep = optionsStruct.modulesToKeep; % for example modulesToKeep = [2 4; 4 3; 22 3; 24 4; 13 2; ];

turnOffNoiseFlag = optionsStruct.turnOffNoiseFlag;
blackPolyOn = optionsStruct.blackPolyOn;
underShootOn = optionsStruct.underShootOn;
nRepeatedCadences = optionsStruct.nRepeatedCadences;

clc;
warning off all;
%eval(['load  ' inputMatFileName]);


if(blackPolyOn)
    blackLevelInADU = 7; % in ADU, black2D is at 700 ADU
    blackPolyCoeffts = [ -1e-4 1];
else

    blackLevelInADU = 0; % in ADU, black2D is at 700 ADU
    blackPolyCoeffts = [ 0 0];
end



%--------------------------------------------------------------------------
% Step 0
% ground truth structure
%--------------------------------------------------------------------------
gt = repmat(struct('blackLevelAllRows', [],'black2DForBlackPixels', [],'black2DForTargetPixels', [], ...
    'black2DForBkgdPixels', [], 'black2DForMsmearPixels', [], 'black2DForVsmearPixels', [],  ...
    'smearForTargetColumns', [], 'smearForBkgdColumns', [],  'bkgdPixelValues', [], ...
    'targetPixelValues', [], 'readNoiseSigmaPerLongCadence', []), 84,1);



%--------------------------------------------------------------------------
% Step 1
% allocate memory here as the number of cadences 200 > 4 (initial number of
% cadences that came from the bin file)
%--------------------------------------------------------------------------

cadenceTimes = s.pdqTimestampSeries.startTimes;
cadenceTimes = cadenceTimes(1);

s.cadenceTimes = cadenceTimes*ones(nRepeatedCadences,1);

numCadences = length(s.cadenceTimes);

nStars  = length(s.stellarPdqTargets);

for j =1:nStars
    nPixels = length(s.stellarPdqTargets(j).referencePixels);
    for k = 1: nPixels
        s.stellarPdqTargets(j).referencePixels(k).timeSeries = zeros(numCadences,1);
        s.stellarPdqTargets(j).referencePixels(k).gapIndicators = false(numCadences,1);
    end
end

nBkgds = length(s.backgroundPdqTargets);

for j = 1:nBkgds
    nPixels = length(s.backgroundPdqTargets(j).referencePixels);
    for k = 1:nPixels

        s.backgroundPdqTargets(j).referencePixels(k).timeSeries = zeros(numCadences,1);
        s.backgroundPdqTargets(j).referencePixels(k).gapIndicators = false(numCadences,1);
    end
end


nCollaterals = length(s.collateralPdqTargets);

for j = 1:nCollaterals
    nPixels = length(s.collateralPdqTargets(j).referencePixels);
    for k = 1:nPixels

        s.collateralPdqTargets(j).referencePixels(k).timeSeries = zeros(numCadences,1);
        s.collateralPdqTargets(j).referencePixels(k).gapIndicators = false(numCadences,1);
    end
end

%--------------------------------------------------------------------------
% Step 2
% retrieve models for the time range interested in
%--------------------------------------------------------------------------


% raDec2PixModel = retrieve_ra_dec_2_pix_model;
% s.raDec2PixModel = raDec2PixModel;

%--------------------------------------------------------------------------
% Step 3
% select modouts for which Monte Carlo data will be generated
% if the number of realizations = 1000, then limit the number of cadences
% to 1 and the number of modouts to 1
% this means we need to remove the other modouts from the input structure
% before we populate it
%--------------------------------------------------------------------------


debugLevel = false;

ccdModules          = cat(1,s.stellarPdqTargets.ccdModule);
ccdOutputs          = cat(1, s.stellarPdqTargets.ccdOutput);
modOuts = convert_from_module_output(ccdModules, ccdOutputs);

validModOuts = convert_from_module_output(modulesToKeep(:,1), modulesToKeep(:,2));

% if generating data for just 1 modout only
allModOuts = unique(modOuts);
allModOuts = allModOuts(:);

invalidModOuts =  setxor(allModOuts, validModOuts);


allIndexFlag  = true(length(s.stellarPdqTargets),1);

for j=1:length(invalidModOuts)
    index = find(modOuts ==  invalidModOuts(j));
    allIndexFlag(index) = false;
end

indexToRemove = find(~allIndexFlag);
s.stellarPdqTargets(indexToRemove) = [];


ccdModules          = cat(1,s.backgroundPdqTargets.ccdModule);
ccdOutputs          = cat(1, s.backgroundPdqTargets.ccdOutput);
modOuts = convert_from_module_output(ccdModules, ccdOutputs);

[invalidModOuts,indexToRemove] = intersect(modOuts,invalidModOuts);
s.backgroundPdqTargets(indexToRemove) = [];


ccdModules          = cat(1,s.collateralPdqTargets.ccdModule);
ccdOutputs          = cat(1, s.collateralPdqTargets.ccdOutput);
modOuts = convert_from_module_output(ccdModules, ccdOutputs);



allIndexFlag  = true(length(s.collateralPdqTargets),1);

for j=1:length(invalidModOuts)
    index = find(modOuts ==  invalidModOuts(j));
    allIndexFlag(index) = false;
end
indexToRemove = find(~allIndexFlag);

s.collateralPdqTargets(indexToRemove) = [];


close all;


%--------------------------------------------------------------------------
% Step 4
% Choose simulation parameters
%--------------------------------------------------------------------------

% various FC constants
% nRowsImaging: 1024
% nColsImaging: 1100
% nLeadingBlack: 12
% nTrailingBlack: 20
% nVirtualSmear: 26
% nMaskedSmear: 20
% MODULE_OUTPUTS: 84
% TWELFTH_MAGNITUDE_ELECTRON_FLUX_PER_SECOND: 246000

ccdRows = 1070; %1024;
ccdColumns = 1132; % 1100;
nModOuts = 84;
visibleCcdRows = 1024; %1024;
visibleCcdColumns = 1100; % 1100;
nLeadingBlackColumns = 12;
%nTrailingBlackColumns = 20;
nMaskedSmearRows = 20;
standardMag12FluxPerSec = s.fcConstants.TWELFTH_MAGNITUDE_ELECTRON_FLUX_PER_SECOND; % in photo electrons


% next choose simulation parameters that don't come from models

backgroundLevelAtMagnitude  = 19;
darkCurrentInElectronsPerSec = 2; % 6e-/sec


%--------------------------------------------------------------------------
% Update ground truth structure to contain these parameters
%--------------------------------------------------------------------------
% sigmaPSF = sqrt((HWHM^2)/(2*log(2)));
% gtParameters.HWHM = HWHM;
% gtParameters.sigmaPSF = sigmaPSF;


gtParameters.blackLevelInADU = blackLevelInADU;
gtParameters.backgroundLevelAtMagnitude  = backgroundLevelAtMagnitude;
gtParameters.darkCurrentInElectronsPerSec = darkCurrentInElectronsPerSec; % 6e-/sec
gtParameters.blackPolyCoeffts = blackPolyCoeffts;



%--------------------------------------------------------------------------
% Clarification about zero based row, column indices in s
% pdqScienceObject is created with the zeroBasedInputFlag turned on.
% pdqTemp structure contains 1-based indexing just as the ccdImage.
% only the structure 's ' still has the zero-based row,column appropriate
% for invoking pdq_matlab_controller.
%--------------------------------------------------------------------------

zeroBasedInputFlag = true;
pdqScienceObject  = pdqScienceClass(s, zeroBasedInputFlag);

%--------------------------------------------------------------------------
% Step 5
% Extract FC models
%--------------------------------------------------------------------------
% extract simple models

% extract raDec2Pix model
raDec2PixObject = raDec2PixClass(s.raDec2PixModel, 'one-based');

% instantiate the undershoot model object
undershootObject = undershootClass(s.undershootModel);

fcConstantsStruct = s.fcConstants;

%--------------------------------------------------------------------------
% Step 6
% Monte Carlo step for each realization (Outer loop)
%--------------------------------------------------------------------------


for iRealization = 1:nRealizations

    tic

    for currentModOut = allModOuts(:)'

        if(~isempty(intersect(currentModOut,invalidModOuts)))
            continue;
        end

        fprintf('------------------------------------------------------\n');
        fprintf('modout %d/%d\n', currentModOut, nModOuts);
        fprintf('------------------------------------------------------\n');

        % black 2d model, flatfield model
        fprintf('PDQ: Instantiating flatfield and black2D models ....\n');

        % instantiate gain, read noise, black 2D, flat field models for this mod/out
        [flatFieldObject, black2DObject] = instantiate_modout_specific_focal_plane_models(pdqScienceObject, currentModOut);




        % Sort reference pixles - select those that belong to the current
        % Module output

        [pdqTempStruct] = determine_available_stellar_pixels(pdqScienceObject, currentModOut);
        %move on to the next module output as calibration is not possible
        [pdqTempStruct] = determine_available_bkgd_pixels(pdqScienceObject, pdqTempStruct,  currentModOut);

        [pdqTempStruct] = determine_available_collateral_pixels(pdqScienceObject, pdqTempStruct,  currentModOut);


        numCadences = pdqTempStruct.numCadences;


        numPixels = pdqTempStruct.numPixels;
        nTargets = pdqTempStruct.numTargets;


        % collect all the rows and columns of targets, backgrounds, and
        % collateral pixels
        dynamicPixels = pdqTempStruct.dynamicPixels;
        dynamicRows = pdqTempStruct.dynamicRows;
        dynamicColumns  = pdqTempStruct.dynamicColumns;

        allRows = [pdqTempStruct.targetPixelRows; pdqTempStruct.bkgdPixelRows; pdqTempStruct.msmearRows; pdqTempStruct.vsmearRows; pdqTempStruct.blackRows; dynamicRows];

        allColumns = [pdqTempStruct.targetPixelColumns; pdqTempStruct.bkgdPixelColumns; pdqTempStruct.msmearColumns; pdqTempStruct.vsmearColumns; pdqTempStruct.blackColumns; dynamicColumns];


        ccdImage = zeros(ccdRows, ccdColumns);
        neededPixelsLinearIndex = sub2ind(size(ccdImage), allRows, allColumns);
        targetPixelsLinearIndex = sub2ind(size(ccdImage), pdqTempStruct.targetPixelRows, pdqTempStruct.targetPixelColumns);


        fprintf('reading  %s......\n', pdqTempStruct.prfFilename );
        fid = fopen(pdqTempStruct.prfFilename);
        if(fid == -1) % unable to open file
            error('PDQ:compute_prf_based_centroids:prfFileNotFound', ...
                ['could not open prf model file ' pdqTempStruct.prfFilename ]);

        end

        %         prfBlob = fread(fid, 'uint8=>uint8');
        %         fclose(fid);
        %         % Instantiate a prf object. Blob must first be converted to struct.
        %         prfStruct = blob_to_struct(prfBlob);
        %         prfObject = prfClass(prfStruct);

        prfBlob = fread(fid, 'uint8=>uint8');
        fclose(fid);
        % Instantiate a prf object. Blob must first be converted to struct.
        prfStruct = blob_to_struct(prfBlob);

        if(isfield(prfStruct, 'c')) % it's a single prf model
            prfModelStruct.polyStruct = prfStruct;
        else
            prfModelStruct = prfStruct;
        end

        prfObject = prfCollectionClass(prfModelStruct,fcConstantsStruct);



        %__________________________________________________________________
        % generate monte carlo data each realization (cadence)
        %__________________________________________________________________

        for iCadence = 1: numCadences

            fprintf('cadence %d/%d\n', iCadence, numCadences);

            cadenceTimeStamp = pdqTempStruct.cadenceTimes(iCadence);

            [gainForOneCadenceAllModOuts, readNoiseForOneCadenceAllModOuts, configMapStruct, requantTableStruct]...
                = extract_simple_focal_plane_models_per_cadence(pdqScienceObject, cadenceTimeStamp);

            ccdReadTimeInSec = configMapStruct.ccdReadTime; %
            ccdExposureTimeInSec = configMapStruct.ccdExposureTime;
            numberOfExposuresInLongCadence = configMapStruct.numberOfExposuresPerLongCadence;

            %-------------------------------------------
            %get fixed offset and mean black value for this cadence and for
            %this modout
            %-------------------------------------------

            requantizationTableFixedOffset  = requantTableStruct.requantizationTableFixedOffset;
            meanBlackFromTable              = requantTableStruct.meanBlackEntries(currentModOut);
            % need the mod out
            meanBlackFromTablePerLongCadence = meanBlackFromTable * numberOfExposuresInLongCadence;




            ccdImage = zeros(ccdRows, ccdColumns);


            for jTarget = 1:nTargets

                % need to extract the aperture while keeping the data structure the same

                % extract rows, columns for jTarget
                if (jTarget == 1)
                    indexStart  = 1;
                    indexEnd    = numPixels(1);
                end

                if (jTarget > 1)
                    indexStart  = sum(numPixels(1:(jTarget-1))) + 1;
                    indexEnd    = sum(numPixels(1:(jTarget)));
                end

                rows = pdqTempStruct.targetPixelRows(indexStart:indexEnd);
                cols = pdqTempStruct.targetPixelColumns(indexStart:indexEnd);
                isInOptimalApertureOriginal = pdqTempStruct.isInOptimalAperture(indexStart:indexEnd);

                inFlag = find(isInOptimalApertureOriginal);

                raStar = pdqTempStruct.raStars(jTarget);
                decStar = pdqTempStruct.decStars(jTarget);
                targetMagnitude = pdqTempStruct.keplerMags(jTarget);

                %-------------------------------------------
                % compute the stellar flux per exposure
                %-------------------------------------------
                % assume a flux rate of 4.5e9 e-/6.5 hours for a 12th magnitude star (this
                % is in FCConstants too) - convert it to flux/sec

                % after evaluating the PSF over the aperture (remember the PSF is
                % normalized - the area evaluates to unity when the limits are set to -inf to
                % inf), scale the pixel values by flux/sec.

                targetFluxPerSec = standardMag12FluxPerSec * mag2b(targetMagnitude - 12); % in photo electrons

                % where to locate the artificial gaussian 2D PSF
                % no need to call raDec2Pix to transform ra, dec to row, column since it is
                % part of the input structure

                % call radec2pix with a time stamp to get the predicted centroid location
                %aberrateFlag = 1;
                [module, output, predictedCentroidRow, predictedCentroidColumn] = ...
                    ra_dec_2_pix_absolute(raDec2PixObject, raStar, decStar, cadenceTimeStamp);


                if(module == -1 || output == -1)
                    continue;
                end


                if(debugLevel)
                    figure(1);
                    plot(rows,cols,'bp')
                    hold on;
                    plot(rows(inFlag), cols(inFlag), 'rs')
                    plot(rows(inFlag), cols(inFlag), 'r.')
                    plot(predictedCentroidRow, predictedCentroidColumn,'ks')
                    plot(predictedCentroidRow, predictedCentroidColumn,'gp')
                    titleStr = sprintf('module = %d, output = %d', module, output);
                    title(titleStr);
                    hold off;

                    fprintf('');
                end

                % Monte Carlo generation of PDQ reference pixel time series
                % Notes from chat with Jon

                %--------------------------------
                % generate a sparse star field (build an FFI for one exposure)
                %--------------------------------

                % given {ra, dec} of target stars, use raDec2Pix to map it to {row, column} on
                % the CCD (or use the existing PDQ target definitions and locate the center
                % of the aperture)


                [prfFitted, prfRows, prfColumns] = evaluate(prfObject, predictedCentroidRow, predictedCentroidColumn);

                prfFitted = prfFitted./sum(prfFitted);


                rowsColsPrf = [prfRows, prfColumns];
                rowsColsTarget = [rows(:), cols(:)];


                % find the common rows and column
                [commonRowColumns, indexIntoTarget, indexIntoPrf] = intersect(rowsColsTarget, rowsColsPrf, 'rows');


                % simulate each star field by evaluating the prf centered
                % at predicted centroid row, column
                % choose the aperture for each star (as defined in the data structure)
                % evaluate the PRF over the pixels


                nPixelsForThisTarget = length(indexIntoTarget);
                targetPixelsFluxPerExposure  = zeros(nPixelsForThisTarget, 1);


                for k =1:nPixelsForThisTarget

                    prfValueAtPixel = prfFitted(indexIntoPrf(k)); % any scaling involved

                    targetPixelsFluxPerExposure(indexIntoTarget(k)) = prfValueAtPixel*targetFluxPerSec*ccdExposureTimeInSec;

                    ccdImage(commonRowColumns(k,1), commonRowColumns(k,2)) = targetPixelsFluxPerExposure(indexIntoTarget(k)) ;

                end

            end;




            %-------------------------------------------
            % set the background at magnitude 19 star flux (check with JJ)
            %-------------------------------------------

            backgroundFluxPerExposure = standardMag12FluxPerSec * mag2b(backgroundLevelAtMagnitude-12)*ccdExposureTimeInSec; % in photo electrons

            %-------------------------------------------
            % collect background pixels ground truth just for 1 cadence
            %-------------------------------------------
            if(iCadence == 1)

                gt(currentModOut).bkgdPixelValues = backgroundFluxPerExposure * numberOfExposuresInLongCadence; % per long cadence

            end


            %-------------------------------------------
            % collect target pixels ground truth just for 1 cadence
            %-------------------------------------------
            if(iCadence == 1)

                gt(currentModOut).targetPixelValues = ccdImage(targetPixelsLinearIndex) * numberOfExposuresInLongCadence; % per long cadence

            end

            %-------------------------------------------
            % add dynamic range targets too... no need for artificial PSF; use
            % as it is
            %-------------------------------------------
            dynamicPixelIndex = sub2ind(size(ccdImage), dynamicRows, dynamicColumns);

            ccdImage(dynamicPixelIndex) = dynamicPixels(:,iCadence);


            %-------------------------------------------
            % after placing all the stars on a frame, add the rest
            % add background only to visible silicon
            %-------------------------------------------
            ccdImage = ccdImage + backgroundFluxPerExposure;
            % zero out collateral region
            ccdImage(1:nMaskedSmearRows,:) = 0;
            ccdImage(nMaskedSmearRows+visibleCcdRows+1:ccdRows,:) = 0;

            ccdImage(:, 1:nLeadingBlackColumns) = 0;
            ccdImage(:,nLeadingBlackColumns+visibleCcdColumns+1:ccdColumns) = 0;

            %--------------------------------------------------------------
            % include flat field
            %--------------------------------------------------------------
            % background and target pixels may overlap (RPTS problem)


            targetPlusDynamicRows =    [pdqTempStruct.targetPixelRows; dynamicRows];
            targetPlusDynamicColumns = [pdqTempStruct.targetPixelColumns; dynamicColumns];

            flatFieldForTargetPixels   = get_flat_field(flatFieldObject, cadenceTimeStamp, targetPlusDynamicRows, targetPlusDynamicColumns);

            bkgdRows    = pdqTempStruct.bkgdPixelRows;
            bkgdColumns = pdqTempStruct.bkgdPixelColumns;

            flatFieldForBkgdPixels   = get_flat_field(flatFieldObject, cadenceTimeStamp, bkgdRows, bkgdColumns);


            visibleRows =    [pdqTempStruct.targetPixelRows; dynamicRows; bkgdRows];
            visibleColumns = [pdqTempStruct.targetPixelColumns; dynamicColumns; bkgdColumns];
            visiblePixelsLinearIndex = sub2ind(size(ccdImage), visibleRows, visibleColumns);

            flatFieldForVisiblePixels   = get_flat_field(flatFieldObject, cadenceTimeStamp, visibleRows, visibleColumns);

            ccdImage(visiblePixelsLinearIndex) = ...
                ccdImage(visiblePixelsLinearIndex) .* flatFieldForVisiblePixels;

            %-------------------------------------------
            % add dark current
            %-------------------------------------------
            % add dark current during exposure to masked rows (the first 20 pixel rows)
            % pick a dark current value for scale factor
            % (full exposure + read out time) x dark current



            % add dark current for the read time to visible CCD = virtual smear region, masked
            % smear region
            ccdImage(1:visibleCcdRows+nMaskedSmearRows, nLeadingBlackColumns+1:visibleCcdColumns+nLeadingBlackColumns)  = ...
                ccdImage(1:visibleCcdRows+nMaskedSmearRows, nLeadingBlackColumns+1:visibleCcdColumns+nLeadingBlackColumns)...
                + darkCurrentInElectronsPerSec*ccdExposureTimeInSec; % dark added to visible ccd + masked smear region...

            % add dark current for the read time to visible CCD , virtual smear region, masked
            % smear region
            ccdImage(1:ccdRows, nLeadingBlackColumns+1:visibleCcdColumns+nLeadingBlackColumns)  = ...
                ccdImage(1:ccdRows, nLeadingBlackColumns+1:visibleCcdColumns+nLeadingBlackColumns)...
                + darkCurrentInElectronsPerSec*ccdReadTimeInSec; % dark for read time added to visible ccd + masked  + virtual smear region...




            %-------------------------------------------
            % calculate smear
            %-------------------------------------------
            % take column sum (flux/sec) (1100 columns) divide by the number of
            % rows (1024) the above gives the flux/sec/row traversed multiply
            % by read out time (0.51 sec) this is the value of the smear add
            % this to every column

            columnSum = sum(ccdImage,1);
            columnSum = columnSum';

            smearValue = (columnSum/ccdExposureTimeInSec)*ccdReadTimeInSec/ccdRows;


            %-------------------------------------------------------------------------------------
            % collect smear pixels ground truth just for 1 cadence
            %-------------------------------------------------------------------------------------

            if(iCadence == 1)

                % remeber that mSmearValue, vSmearValue arrays exist only
                % for columns 13:1112; index into them correctly to get the
                % smear values for target, bkgd pixels
                %allVisibleColumns = [pdqTempStruct.targetPixelColumns; pdqTempStruct.bkgdPixelColumns];
                %gt(currentModOut).smearPixelValues  = smearValue(allVisibleColumns)*numberOfExposuresInLongCadence;
                gt(currentModOut).darkCurrentValueForVsmear  = darkCurrentInElectronsPerSec*ccdReadTimeInSec*numberOfExposuresInLongCadence;
                gt(currentModOut).darkCurrentValueForMsmear  = darkCurrentInElectronsPerSec*(ccdExposureTimeInSec+ccdReadTimeInSec)*numberOfExposuresInLongCadence;

                gt(currentModOut).flatFieldForTargetPixels  = flatFieldForTargetPixels;
                gt(currentModOut).flatFieldForBkgdPixels  = flatFieldForBkgdPixels;

                gt(currentModOut).smearForBkgdColumns  = smearValue(pdqTempStruct.bkgdPixelColumns)*numberOfExposuresInLongCadence;
                gt(currentModOut).smearForTargetColumns  = smearValue(pdqTempStruct.targetPixelColumns)*numberOfExposuresInLongCadence;

            end

            %-------------------------------------------------------------------------------------
            % add smear ccd image (exclude leading/trailing black)
            %-------------------------------------------------------------------------------------

            ccdImage  = ccdImage + repmat(smearValue', ccdRows,1); % masked smear added to target + background + all collateral regions (except black) too...

            %-------------------------------------------
            % add shot noise
            %-------------------------------------------

            % model noise as a Poisson process
            % sqrt(photo e-) in each pixel
            % this becomes the scale factor X the random deviates (gaussian)

            % alternately, use Poisson deviates from the statistics tool box
            % R = poissrnd(lambda) generates random numbers from the Poisson
            % distribution with mean parameter lambda. lambda can be a vector, a
            % matrix, or a multidimensional array. The size of R is the size of lambda.

            % add entire ccd except for black  ( measurement)

            coAddedImage =  zeros(ccdRows, ccdColumns);
            ccdImageStatic = ccdImage;
            for kExposure = 1:numberOfExposuresInLongCadence
                ccdImage = ccdImageStatic;

                if(~turnOffNoiseFlag) % if the flag is true, do not add shot noise or any noise

                    shotNoisePlusImage = poissrnd(ccdImage(neededPixelsLinearIndex)); % ccdImage is the mean Image for the poisson distribution
                    ccdImage(neededPixelsLinearIndex) = shotNoisePlusImage;

                end

                %-------------------------------------------------------------------------------------
                % at this point, the image can be co-added for long cadence or  short cadence
                %-------------------------------------------------------------------------------------

                % keep only the needed pixels

                coAddedImage(neededPixelsLinearIndex) = coAddedImage(neededPixelsLinearIndex) + ccdImage(neededPixelsLinearIndex);
            end
            ccdImage = coAddedImage;

            if (underShootOn)
                %-------------------------------------------------------------------------------------
                % add undershoot artifact (should we exclude leading/trailing black?)
                %-------------------------------------------------------------------------------------
                % add undershoot artifact (from ETEM2 code @etemUndershootClass
                % apply undershoot filter to the rows of pixelArray
                % undershoot is a causal filter operating to the right
                % get the coefficients of the undershoot filter for this modout


                undershootCoeffts = get_undershoot(undershootObject, pdqTempStruct.cadenceTimes, pdqTempStruct.ccdModule, pdqTempStruct.ccdOutput);
                undershootCoeffts = undershootCoeffts'; % now of size nCoeffts x nCadences

                % imbed the ccdImage in a larger array with leading columns.  The number
                % of leading columns should be greater than the number of coefficients.
                % The content of each leading column is the first column of pixelArray
                nCols = length(undershootCoeffts(:,1));
                leadingCols = repmat(ccdImage(:,1), 1, nCols);

                leftExtendedCcdImage = [leadingCols, ccdImage];

                % the filter coefficients are for the correction to the overshoot, so to
                % inject the signal we invert the filter by using these coefficients in the
                % first arg of filter.
                % apply filter along rows
                leftExtendedCcdImage = filter(undershootCoeffts(:,iCadence), 1, leftExtendedCcdImage, [], 2);

                % collect ground truth here...?

                if(iCadence == 1)
                    % remeber that mSmearValue, vSmearValue arrays exist only
                    % for columns 13:1112; index into them correctly to get the

                    % the undershoot filter coefficients don't change with time
                    % smear values for target, bkgd pixels
                    gt(currentModOut).undershootImage = leftExtendedCcdImage(:,nCols+1:end) - ccdImage;
                end

                % extract ccdImage
                ccdImage = leftExtendedCcdImage(:,nCols+1:end);

            end
            %-------------------------------------------
            % add black after shot noise
            %-------------------------------------------

            % approximately 700 ADU + tilt to the black polynomial
            % evalutate and add to the pixel

            blackLevel = (polyval(blackPolyCoeffts, 1:ccdRows) + blackLevelInADU) ...
                * gainForOneCadenceAllModOuts(currentModOut)*numberOfExposuresInLongCadence;


            ccdImagePerLongCadence = ccdImage + repmat(blackLevel',1, ccdColumns); % this frame valid only for the pixels of interest
            ccdImageTemp = zeros(ccdRows, ccdColumns);
            ccdImageTemp(neededPixelsLinearIndex) = ccdImagePerLongCadence(neededPixelsLinearIndex);
            ccdImagePerLongCadence = ccdImageTemp;


            %-------------------------------------------
            % collect black pixels ground truth just for 1 cadence
            %-------------------------------------------

            if(iCadence == 1)

                gt(currentModOut).blackLevelAllRows = blackLevel;

                gt(currentModOut).black2DForBlackPixels    = get_two_d_black(black2DObject, cadenceTimeStamp, pdqTempStruct.blackRows, pdqTempStruct.blackColumns);
                gt(currentModOut).black2DForTargetPixels   = get_two_d_black(black2DObject, cadenceTimeStamp, pdqTempStruct.targetPixelRows, pdqTempStruct.targetPixelColumns);
                gt(currentModOut).black2DForBkgdPixels     = get_two_d_black(black2DObject, cadenceTimeStamp, pdqTempStruct.bkgdPixelRows, pdqTempStruct.bkgdPixelColumns);
                gt(currentModOut).black2DForMsmearPixels   = get_two_d_black(black2DObject, cadenceTimeStamp, pdqTempStruct.msmearRows, pdqTempStruct.msmearColumns);
                gt(currentModOut).black2DForVsmearPixels   = get_two_d_black(black2DObject, cadenceTimeStamp, pdqTempStruct.vsmearRows, pdqTempStruct.vsmearColumns);



                targetPixelsLinearIndex = sub2ind(size(ccdImage), pdqTempStruct.targetPixelRows, pdqTempStruct.targetPixelColumns);
                gt(currentModOut).targetPixelsAfterBlack2D   = ccdImagePerLongCadence(targetPixelsLinearIndex);


            end


            %-------------------------------------------
            % add black 2D
            %-------------------------------------------
            black2DForAllPixels   = get_two_d_black(black2DObject, cadenceTimeStamp, allRows, allColumns);
            % black 2D values are per readout - scale it up by number of exposures

            ccdImagePerLongCadence(neededPixelsLinearIndex) = ...
                ccdImagePerLongCadence(neededPixelsLinearIndex) + black2DForAllPixels*gainForOneCadenceAllModOuts(currentModOut)*numberOfExposuresInLongCadence;

            %-------------------------------------------
            % read noise, quantization noise
            %-------------------------------------------

            % number of exposures is synonymous with number of coadds
            % read noise sigma = 0 mean, sigma = 1ADU random deviates
            % 1 ADU = 113 e-
            % quantization noise per read out = 1/sqrt(12)
            % scale by 1/sqrt(Nexp)

            % from Jon's email
            % Suppose the read noise is 1.1 ADU per read, and there are 270
            % exposures per long cadence with 116 e-/ADU.
            %
            % The read noise per pixel in the co-added frame will have a
            % standard deviation of 1.1*sqrt(270)*116 e-, so that a realization
            % of the noise would be
            % readNoise = 1.1*sqrt(270)*116*randn(size(CCD))
            % where CCD is the frame (2D array containing the synthetic frame).
            %
            % For quantization noise the noise per read per pixel is 116
            % e-/sqrt(12) as a rms value. With 270 coadds we expect a standard
            % deviation of 116/sqrt(12)*sqrt(270) e-, so that the realization
            % would be quantizationNoise =
            % 116/sqrt(12)*sqrt(270)*randn(size(CCD));
            %
            % The distribution is not uniform, it is nearly Gaussian. (do not
            % confuse the single read quantization noise with what you do for
            % multiple co-adds). For a single exposure, model the quantization
            % noise as a sample from a uniform distribution of width equal to
            % the step size, centered on zero. But after a sufficient number of
            % co-adds, treat quantization noise as a Gaussian noise source via
            % the central limit theorem.

            if(~turnOffNoiseFlag) % if the flag is true, do not add shot noise or any noise

                % accumulation memory
                readNoiseSigmaPerLongCadence = readNoiseForOneCadenceAllModOuts(currentModOut)...
                    *sqrt(numberOfExposuresInLongCadence)*gainForOneCadenceAllModOuts(currentModOut);
                quantizationNoiseSigmaPerLongCadence = (1/sqrt(12))*sqrt(numberOfExposuresInLongCadence)*gainForOneCadenceAllModOuts(currentModOut);
                readNoiseQuantizationNoiseSigmaPerLongCadence = sqrt(sum(readNoiseSigmaPerLongCadence^2 +quantizationNoiseSigmaPerLongCadence^2));


                nTotalPixels = length(neededPixelsLinearIndex);
                readNoiseQuantizationNoisePerLongCadence = readNoiseQuantizationNoiseSigmaPerLongCadence*randn(nTotalPixels,1);
                ccdImagePerLongCadence(neededPixelsLinearIndex) = ccdImagePerLongCadence(neededPixelsLinearIndex) + readNoiseQuantizationNoisePerLongCadence;


            else
                readNoiseSigmaPerLongCadence = 0;
                quantizationNoiseSigmaPerLongCadence = 0;
                readNoiseQuantizationNoiseSigmaPerLongCadence = 0;
            end
            %-------------------------------------------
            % collect read noise, quantization noise for ground truth just for 1 cadence
            %-------------------------------------------

            if(iCadence == 1)
                gt(currentModOut).readNoiseSigmaPerLongCadence = readNoiseSigmaPerLongCadence;
                gt(currentModOut).quantizationNoiseSigmaPerLongCadence = quantizationNoiseSigmaPerLongCadence;
                gt(currentModOut).readNoiseQuantizationNoiseSigmaPerLongCadence = readNoiseQuantizationNoiseSigmaPerLongCadence;
            end
            %-------------------------------------------
            % run test data generation
            %-------------------------------------------

            % now extract target pixels, background pixels, collateral pixels
            % from this FFI and fill the appropriate input structure fields

            % stellar targets
            validTargetIndicesForThisModOut = pdqTempStruct.validTargetIndicesForThisModOut; % index into pdqScienceObject stellarPdqTargets
            validBkgdIndicesForThisModOut = pdqTempStruct.validBkgdIndicesForThisModOut; % index into pdqScienceObject stellarPdqTargets
            validCollTargetsForThisModOut = pdqTempStruct.validCollTargetsForThisModOut; % index into pdqScienceObject stellarPdqTargets


            for iTarget = 1:length(validTargetIndicesForThisModOut)
                index = validTargetIndicesForThisModOut(iTarget);
                nPixelsForThisTarget = length(s.stellarPdqTargets(index).referencePixels);


                % not comfortable using 'deal' here
                for jPixel = 1:nPixelsForThisTarget
                    row = s.stellarPdqTargets(index).referencePixels(jPixel).row + 1;
                    column = s.stellarPdqTargets(index).referencePixels(jPixel).column + 1;
                    s.stellarPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) = (ccdImagePerLongCadence(row, column)./gainForOneCadenceAllModOuts(currentModOut));

                    % new requantTable/meanBlackTable related updates
                    s.stellarPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) = ...
                        s.stellarPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) + requantizationTableFixedOffset - meanBlackFromTablePerLongCadence;


                    s.stellarPdqTargets(index).referencePixels(jPixel).gapIndicators(iCadence) = 0; % no gaps at all for now
                end


                if(debugLevel)
                    targetRows = cat(1,s.stellarPdqTargets(index).referencePixels.row);
                    targetColumns = cat(1,s.stellarPdqTargets(index).referencePixels.column);
                    targetPixelFluxes = cat(2,s.stellarPdqTargets(index).referencePixels.timeSeries);
                    targetPixelFluxes = targetPixelFluxes';
                    % meshplot for a visual check
                    minRow = min(targetRows);
                    maxRow = max(targetRows);
                    nUniqueRows = maxRow - minRow +1;
                    minCol = min(targetColumns);
                    maxCol = max(targetColumns);
                    nUniqueCols = maxCol - minCol +1;

                    X = repmat((minRow:maxRow)',1, nUniqueCols);
                    Y = repmat((minCol:maxCol), nUniqueRows,1);

                    Z = zeros(size(X));
                    idx = sub2ind(size(X), targetRows -minRow+1,targetColumns-minCol+1);
                    Z(idx) = targetPixelFluxes(:,1);

                    if(size(Z,1) ~=1)
                        %        figure(1)
                        mesh(X,Y,Z);
                        keplerMag = s.stellarPdqTargets(index).keplerMag;
                        ccdModule = s.stellarPdqTargets(index).ccdModule;
                        ccdOutput = s.stellarPdqTargets(index).ccdOutput;
                        label = char(s.stellarPdqTargets(index).labels);

                        label = strrep(label,'_',' ');
                        titleString = sprintf('%s  Magnitude = %5.2f ccd = %d  Output = %d', ...
                            label, keplerMag, ccdModule, ccdOutput);
                        title(titleString)
                        xlabel('rows');
                        ylabel('columns');
                        fprintf('');
                    end
                    pause(0.5);
                end

            end

            for iBkgd = 1:length(validBkgdIndicesForThisModOut)

                index = validBkgdIndicesForThisModOut(iBkgd);
                nBgdPixelsForThisBkgd = length(s.backgroundPdqTargets(index).referencePixels);

                % not comfortable using 'deal' here
                for jPixel = 1:nBgdPixelsForThisBkgd

                    row = s.backgroundPdqTargets(index).referencePixels(jPixel).row + 1;
                    column = s.backgroundPdqTargets(index).referencePixels(jPixel).column + 1;
                    s.backgroundPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) = (ccdImagePerLongCadence(row, column)./gainForOneCadenceAllModOuts(currentModOut));
                    % new requantTable/meanBlackTable related updates
                    s.backgroundPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) = ...
                        s.backgroundPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) + requantizationTableFixedOffset - meanBlackFromTablePerLongCadence;

                    s.backgroundPdqTargets(index).referencePixels(jPixel).gapIndicators(iCadence) = 0; % no gaps at all for now
                end
            end
            for iCollateral = 1:length(validCollTargetsForThisModOut)

                index = validCollTargetsForThisModOut(iCollateral);
                nCollPixels = length(s.collateralPdqTargets(index).referencePixels);
                % not comfortable using 'deal' here
                for jPixel = 1:nCollPixels
                    row = s.collateralPdqTargets(index).referencePixels(jPixel).row + 1;
                    column = s.collateralPdqTargets(index).referencePixels(jPixel).column + 1;
                    s.collateralPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) = (ccdImagePerLongCadence(row, column)./gainForOneCadenceAllModOuts(currentModOut));
                    % new requantTable/meanBlackTable related updates
                    s.collateralPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) = ...
                        s.collateralPdqTargets(index).referencePixels(jPixel).timeSeries(iCadence) + requantizationTableFixedOffset - meanBlackFromTablePerLongCadence;

                    s.collateralPdqTargets(index).referencePixels(jPixel).gapIndicators(iCadence) = 0; % no gaps at all for now
                end
            end

            % sequences of cadences (100 cadences)
            % have the ability to turn on/off smear etc.

        end

    end

    sFileName = ['pdq_monte_carlo_one_cadence_multiple_realizations_' num2str(iRealization) '.mat'];
    save(sFileName,'s', 'gt', 'gtParameters');

    toc
end
fprintf('');




