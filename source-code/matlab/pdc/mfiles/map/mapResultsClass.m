%% classdef mapResultsClass
%
%   Contains all final results generated by MAP to be delivered to PDC. This class contains a subset
%   of the data contained in mapDataClass and only that to be seen by the outside world.
%
%   Most data is organized in the mapResultsStruct struct array for each target processed.
%
%   Results are in the denormalized absolute basis with the exception of the fit coefficients which are in the
%   normalized basis.
%%
% 
% Copyright 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% 
% NASA acknowledges the SETI Institute's primary role in authoring and
% producing the Kepler Data Processing Pipeline under Cooperative
% Agreement Nos. NNA04CC63A, NNX07AD96A, NNX07AD98A, NNX11AI13A,
% NNX11AI14A, NNX13AD01A & NNX13AD16A.
% 
% This file is available under the terms of the NASA Open Source Agreement
% (NOSA). You should have received a copy of this agreement with the
% Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
% 
% No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
% WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
% INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
% WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
% INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
% FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
% TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
% CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
% OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
% OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
% FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
% REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
% AND DISTRIBUTES IT "AS IS."
% 
% Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
% AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
% SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
% THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
% EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
% PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
% SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
% STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
% PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
% REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
% TERMINATION OF THIS AGREEMENT.
%

classdef mapResultsClass < classIoTools
    
    properties(GetAccess = 'public', SetAccess = 'private')
        mapParams = [];                     % The map input parameters for this run
        runLabel = [];                      % The name for this run (e.g. coarse, band_1, etc...)
        alerts = [];                        % All alerts reported from PDC.
        debug = [];                        % The debug setting used during MAP
        normMethod = [];                    % The normalization method used for fitting
        mapFailed = [];                     % MAP was not performed?
        diagS = [];                         % [nSingularVectors] Diagonal of S matrix in SVD (The Singular Values))
        uMatrix = [];                       % [nCadences x nSingularVectors] (only first ~128 singular vectors
        vMatrix = [];                       % [nCadences x nSingularVectors] 
        basisVectors = [];                  % [nCadences x nBasisVectors] Basis Vectors for cotrending
        spikeBasisVectors = [];             % [nCadences x nBasisVectors] Spike Basis Vectors for cotrending
        basisVectorEntropy;                 % [nSingularVectors] entropy wrt Gaussian of similar width
        targetsForSvd = [];                 % Index of targets used for generating basis vectors
        targetsForGeneratingPriors = [];    % Index of targets used for generating Prior PDFs
        targetsMapAppliedTo = [];           % Logical array of targets MAP was applied to
        targetsMapWasAttempted = [];        % Logical array of targets MAP was attempted and either succeeded or failed (mainly due to bad priors)
        medianVariability = [];             % Value used to normalize stellar variability
        cadenceTimestamps = []; % Cadence time stamps used for plotting results (MPA doesn't care about cadence times to
                                % do its calculation
        mapCorrectedTargetDataStruct = [] % The new targetDataStruct with MAP corrections 
                                            %Note: if MAP not performed this contains the reduced robust residual
        intermediateMapResults = []; % Struct containing target specific results not in TargetDataStruct (see below)
        pdf = [];                           % [mapPdfClass] The prior, conditional and posterior PDFs
        mapBlobStruct = [];                 % For saving LC data for use with SC quickMap
        quickMapPerformed = false;       
    end

%*******************************************************************************
    methods
        % This constructor parses all the data into the mapResults Object format and
        % calculates the fits and plots selected targets.
        %
        % optional inputs
        %   mapData  -- [mapDataClass]
        %   mapInput -- [mapInputClass]
        %   mapResultsStruct -- [struct] Call with this argument to generate the object from the saved struct
        %
        function obj = mapResultsClass(varargin)
        
            % Keep track of MAP memory usage
            mapResultsMemUsage = memoryUsageClass('mapResultsObject Memory Usage'); % memUSage is a global object handle

            % optional arguments
            nvarargin = size(varargin,2);
            if (mod(size(varargin,2),2) ~= 0)
                error ('All optional arguments for mapResultsClass must be labeled');
           %elseif (nvarargin>4)
           %    error('mapResultsClass can only be called with two or zero optional arguments');
            elseif (nvarargin==0)
                % a "naked" object is desired (used for loading in a saved struct)
                return;
           %elseif (nvarargin<4)
           %    error('mapResultsClass must be called with two or zero optional arguments');
            end
            for ivarargin = 1 :2: nvarargin
                switch varargin{ivarargin}
                
                    case ('mapData')
                        if (~strcmp(class(varargin{ivarargin+1}), 'mapDataClass'))
                            error('mapData must be of type mapDataClass');
                        end
                        mapData = varargin{ivarargin+1};

                    case ('mapInput')
                        if (~strcmp(class(varargin{ivarargin+1}), 'mapInputClass'))
                            error('mapInput must be of type mapInputClass');
                        end
                        mapInput = varargin{ivarargin+1};

                    case ('mapResultsStruct')
                        display('Constructing mapResultsObject from struct');
                        mapResultsStruct = varargin{ivarargin+1};
                        obj = obj.construct_from_struct (mapResultsStruct);
                        return;

                    otherwise
                        error(['Unknown optional argument: ',varargin{ivarargin}]);
                end
            end

            % Confirm both mapInput and mapData were set
            if (~exist('mapData') || ~exist('mapInput'))
                error ('Both mapData and mapInput must be passed in order to construct mapResultsObject');
            end

            component = 'compileResults';
            mapInput.debug.display(component, 'Compiling results...');
            tic

            obj.intermediateMapResults   = repmat( struct( ...
                                'mapInputFluxValues',           [], ... % Input flux values passed to map_controller
                                'mapInputUncertainties',        [], ...
                                'medianFlux',                   [], ...
                                'meanFlux',                     [], ...
                                'stdFlux',                      [], ...
                                'noiseFloor',                   [], ...
                                'kic',                          [], ...
                                'priorPdfInfo',                 [], ...
                                'priorWeight',                  [], ...
                                'priorGoodness',                [], ...
                                'variability',                  [], ...
                                'robustFitCoefficients',        [], ... % in normalized basis
                                'robustSpikeCoefficients',      [], ... % in normalized basis
                                'priorFitCoefficients',         [], ... % in normalized basis
                                'conditionalFitCoefficients',   [], ... % in normalized basis
                                'quickMapFitCoefficients',      [], ... % in normalized basis
                                'mapFitCoefficients',           []),... % in normalized basis 
                                                                    [mapData.nTargets,1]);

            mapResultsMemUsage.add('blank intermediateMapResults');

            %***
            % If Map Failed then just pass back the alerts and unaltered light curves
            if (mapData.mapFailed)
                obj.mapFailed = true;
                obj.alerts  = mapData.alerts;
                obj.mapCorrectedTargetDataStruct = mapInput.targetDataStruct;
                obj.runLabel    = mapInput.debug.runLabel;
                obj.debug       = mapInput.debug;
                % Still return the uMatrix so we see what the found singular vectors were, if any were found
                obj.uMatrix     = mapData.uMatrix;
                obj.create_and_save_short_mapResultsStruct;
                return;
            end

            %***
            % Set all data to be transfered to the MapResults Object for export
            obj.pdf         = mapData.pdf; % NOTE: with intermediateMapResults  there is repeated information here!
            obj.mapParams   = mapInput.mapParams;
            obj.runLabel    = mapInput.debug.runLabel;
            obj.debug       = mapInput.debug;
            obj.normMethod  = mapData.normTargetDataStruct(1).normMethod; % Assume the same for each target
            obj.mapFailed   = false;
            obj.alerts      = mapData.alerts;
            obj.cadenceTimestamps   = mapInput.cadenceTimestamps;
            obj.diagS       = mapData.diagS;
            obj.uMatrix     = mapData.uMatrix;
            obj.vMatrix     = mapData.vMatrix;
            obj.basisVectors        = mapData.basisVectors;
            obj.basisVectorEntropy  = mapData.basisVectorEntropy;
            obj.targetsForSvd       = mapData.targetsForSvd;
            obj.targetsForGeneratingPriors = mapData.targetsForGeneratingPriors;
            obj.quickMapPerformed = mapData.quickMap.quickMapPerformed;
            if (obj.quickMapPerformed)
                % Quick MAP is not a true MAP fit so "MAP" has not been performed 
                obj.targetsMapAppliedTo    = false(mapData.nTargets,1);
                obj.targetsMapWasAttempted = false(mapData.nTargets,1);
            else
                obj.targetsMapAppliedTo    = mapData.pdf.targetsMapAppliedTo;
                obj.targetsMapWasAttempted = mapData.pdf.targetsMapWasAttempted;
            end
            obj.medianVariability = mapData.medianVariability;

            % As we populate the intermediateMapResults struct we also denormalize the data and fits (but not the coefficients)
            % The fit coefficients are in the normalized basis so the fit removal is to occur in the normalized
            % basis, once the fit is removed then denormalize.

            obj.mapCorrectedTargetDataStruct = mapData.normTargetDataStruct;
            %***
            % For speed parallelize as much of this as we can
            % All calls to denormalize values and flux are parallelized
            if (isfield(mapData.normTargetDataStruct(1), 'normMethod'))
                normMethod = mapData.normTargetDataStruct(1).normMethod;
            elseif (any(strcmp(mapData.normTargetDataStruct(1).normMethod, {mapData.normTargetDataStruct.normMethod})))
                error ('MapResultsClass: For now it is assumed all targets are normalized using the same normMethod but this does not appear to be the case here!')
            else
                error ('Flux must be normalized!')
            end

            mapResultsMemUsage.add('obj.* properties set');

            % This is the reduced, constrained robust fit using fewer basis vectors
            % There is a chance there are fewer basis vectors than the number requested
            nBasisVectorsForReducedRobustFit = min(size(obj.basisVectors,2), mapInput.mapParams.svdOrderForReducedRobustFit);
            normalizedReducedRobustResidualMatrix = [mapData.normTargetDataStruct.values] - ...
                obj.basisVectors(:,1:nBasisVectorsForReducedRobustFit ) * mapData.robustFit.coefficients(1:nBasisVectorsForReducedRobustFit ,:);

            % If we are using spike basis vectors then collect this data
            if (mapData.nSpikeBasisVectors > 0)
                obj.spikeBasisVectors = mapData.spikeBasisVectors;
            end

            if (obj.quickMapPerformed)
                normalizedQuickMapResidualMatrix = [mapData.normTargetDataStruct.values] - mapData.basisVectors *  mapData.quickMap.FitCoefficients;

                [keplerIds, scTargetIndicesInLcList, scTargetOrder] = intersect([mapInput.mapBlobStruct.kic.keplerId], mapData.kic.keplerId);
                % Re-arrange scTargetIndicesInLcList to the original order of mapData.kic.keplerId
                [~, sortOrder] = sort(scTargetOrder);
                scTargetIndicesInLcList = scTargetIndicesInLcList(sortOrder);
                lcMapFitCoeffsMatrix = mapInput.mapBlobStruct.mapFitCoefficients(:,scTargetIndicesInLcList); 
            else
                posteriorArray = mapData.pdf.targetInfo;
                posteriorArray = [posteriorArray.fits];
                posteriorArray = [posteriorArray.posterior];
                mapCorrectedTargetDataStructValuesMatrix = [mapData.normTargetDataStruct.values] - mapData.basisVectors * [posteriorArray.basisVectorCoeff];
                clear posteriorArray;
            end

            mapResultsMemUsage.add('Parallelizing matrices created');

            % end parallizing section
            %***

            % Distribute results into each intermediateMapResults struct (THIS IS SLOW!!!!)
            for iTarget = 1 : mapData.nTargets
                % If this is a debug run and not applying MAP to all targets then only compile data for targets
                % MAP applied to (speeds things up for testing)
                if (~mapInput.debug.applyMapToAllTargets && mapInput.debug.debugRun && ...
                                                        ~mapInput.debug.targetsToAnalyze(iTarget))
                    continue;
                end
                obj.intermediateMapResults(iTarget).mapInputFluxValues      = mapInput.targetDataStruct(iTarget).values;
                obj.intermediateMapResults(iTarget).mapInputUncertainties   = mapInput.targetDataStruct(iTarget).uncertainties;
                obj.intermediateMapResults(iTarget).medianFlux              = mapData.medianFlux(iTarget);
                obj.intermediateMapResults(iTarget).meanFlux                = mapData.meanFlux(iTarget);
                obj.intermediateMapResults(iTarget).stdFlux                 = mapData.stdFlux(iTarget);
                obj.intermediateMapResults(iTarget).noiseFloor              = mapData.noiseFloor(iTarget);
                obj.intermediateMapResults(iTarget).kic = struct( ...
                                                    'keplerId',  mapData.kic.keplerId(iTarget), ...
                                                    'ra',        mapData.kic.ra(iTarget), ...
                                                    'dec',       mapData.kic.dec(iTarget), ...
                                                    'keplerMag', mapData.kic.keplerMag(iTarget));

                obj.intermediateMapResults(iTarget).variability = mapData.variability(iTarget);

                obj.intermediateMapResults(iTarget).robustFitCoefficients = mapData.robustFit.coefficients(:,iTarget);

                % MAP isn't always applied to all targets so only collect data for the subset
                if (obj.targetsMapAppliedTo(iTarget))
                    % Full blown MAP
                    obj.intermediateMapResults(iTarget).priorWeight = mapData.pdf.targetInfo(iTarget).posteriorPdfInfo.priorWeight;
                    obj.intermediateMapResults(iTarget).priorGoodness = mapData.pdf.targetInfo(iTarget).posteriorPdfInfo.priorGoodness;
                    obj.intermediateMapResults(iTarget).priorFitCoefficients  = mapData.pdf.targetInfo(iTarget).fits.prior.basisVectorCoeff;
                    obj.intermediateMapResults(iTarget).conditionalFitCoefficients = mapData.pdf.targetInfo(iTarget).fits.conditional.basisVectorCoeff;
                    obj.intermediateMapResults(iTarget).mapFitCoefficients  = mapData.pdf.targetInfo(iTarget).fits.posterior.basisVectorCoeff;
                    obj.intermediateMapResults(iTarget).priorPdfInfo = mapData.pdf.targetInfo(iTarget).priorPdfInfo;
                    % Note: this is still in the normalized basis
                    % TODO: this is prone to confustion. Change this so all this section is in the unnormalized basis

                    obj.mapCorrectedTargetDataStruct(iTarget).values = mapCorrectedTargetDataStructValuesMatrix(:,iTarget);
                elseif (obj.quickMapPerformed)
                    % Quick MAP, most fields here are zero
                    obj.intermediateMapResults(iTarget).priorWeight = mapData.quickMap.priorWeight(iTarget);
                    obj.intermediateMapResults(iTarget).priorGoodness = mapData.quickMap.priorGoodness(iTarget); 
                    obj.intermediateMapResults(iTarget).priorFitCoefficients  = lcMapFitCoeffsMatrix(:,iTarget);
                    obj.intermediateMapResults(iTarget).conditionalFitCoefficients = zeros(mapData.nBasisVectors,1);
                    obj.intermediateMapResults(iTarget).mapFitCoefficients  = zeros(mapData.nBasisVectors,1);
                    obj.intermediateMapResults(iTarget).quickMapFitCoefficients = mapData.quickMap.FitCoefficients(:,iTarget);
                    % Note: this is still in the normalized basis
                    obj.mapCorrectedTargetDataStruct(iTarget).values = normalizedQuickMapResidualMatrix(:,iTarget);
                else
                    % This is when MAP is not performed (nor quick MAP). A reduced robust fit
                    % is used for the MAP fit
                    obj.intermediateMapResults(iTarget).priorWeight = 0.0;
                    obj.intermediateMapResults(iTarget).priorGoodness = mapData.pdf.targetInfo(iTarget).posteriorPdfInfo.priorGoodness;
                    obj.intermediateMapResults(iTarget).priorFitCoefficients  = mapData.pdf.targetInfo(iTarget).fits.prior.basisVectorCoeff;
                    obj.intermediateMapResults(iTarget).conditionalFitCoefficients = zeros(mapData.nBasisVectors,1);
                    obj.intermediateMapResults(iTarget).priorPdfInfo = mapData.pdf.targetInfo(iTarget).priorPdfInfo;
                    obj.intermediateMapResults(iTarget).mapFitCoefficients  = zeros(mapData.nBasisVectors,1);
                    % A reduced order robust fit is used in MAP's stead
                    % Note: this is still in the normalized basis
                    obj.mapCorrectedTargetDataStruct(iTarget).values = normalizedReducedRobustResidualMatrix(:,iTarget);
                end
                if (mapInput.debug.query(component, mapInput.debug.VERBOSEDEBUGLEVEL));
                    mapInput.debug.waitbar(iTarget/mapData.nTargets, 'Compiling results...')
                end
            end
            clear mapCorrectedTargetDataStructValuesMatrix lcMapFitCoeffsMatrix normalizedQuickMapResidualMatrix normalizedReducedRobustResidualMatrix;

            mapResultsMemUsage.add('intermediateMapResults for loop finished');

            % Now denormalize the corrected flux
            obj.mapCorrectedTargetDataStruct = mapNormalizeClass.denormalize_flux(obj.mapCorrectedTargetDataStruct);

            mapResultsMemUsage.add('Corrected flux denormalized');

            duration = toc;
            mapInput.debug.display(component, ['Finished compiling results: ' num2str(duration) ...
                ' seconds = '  num2str(duration/60) ' minutes']);

            % Plot results for the reduced set to analyze
            % This function is public and can be used to plot the results after MAP has completed
            % This is run in map_controller so set optional argument so that results are (potentiall) saved
            % If this is a debug run then plotting the results is done after goodness metric plotting in
            % map_test_suite.m
            if (~mapInput.debug.debugRun && mapInput.debug.doFigures)
                obj.plot_selected_targets ('mapControllerRun', true)
                % Also plot the coefficient utilization and save results
                doSavePlots = true;
                obj.plot_coefficient_utilization(doSavePlots)
                obj.plot_prior_goodness(doSavePlots)
            end
            
            obj.create_blob_structure (mapInput);

            obj.create_and_save_short_mapResultsStruct();

            mapResultsMemUsage.add('MAP blob structure created');

            mapInput.debug.close_waitbar

            % plot memory usage
           %mapResultsMemUsage.plot_memory_usage;

        end
    end % public methods

%*******************************************************************************
    methods(Access = 'public')

        %********************************************************************************
        % function [] = plot_selected_targets (obj, varargin) 
        %
        % Plots the MAP fits to a selection of targets.
        % 
        % optional Inputs:
        %   mapControllerRun    -- [logical default:false] if true then output is saved to file
        %   targetIndicesToPlot -- [integer array default:find(obj.debug.targetsToAnalyze)] list of targets to plot.
        %   targetKeplerIdsToPlot -- [integer array] List of Kepler IDs to plot. NOTE: Overrides targetIndicesToPlot 
        %   figureHandle(:)        -- [handle (main, pdf)] if you want to plot to an already open window then this is it's handle
        %   doPlotPdfs          -- [logical] plot the target Prior, Conditional and Posterior PDFs using mapPdcClass.plot_pdf
        %
        %********************************************************************************


        function [] = plot_selected_targets (obj, varargin)

            persistent pdfFigureHandle;
    
            component = 'resultantPlots';
            setFigureHandle = [];
            doNanGaps = true;
            doPlotPdfs = false;
            cadenceTimes = [];

            % Set to the default values, optional arguments override these
            targetIndicesToPlot = find(obj.debug.targetsToAnalyze);
            nTargetIndicesToPlot = obj.debug.nTargetsToAnalyze;
            mapControllerRun= false;

            nTargets = length(obj.mapCorrectedTargetDataStruct);

            % optional arguments
            nvarargin = size(varargin,2);
            if (mod(size(varargin,2),2) ~= 0)
                error ('All optional arguments for plot_selected_targets must be labeled');
            end
            for ivarargin = 1 :2: nvarargin
                switch varargin{ivarargin}
                
                    case ('mapControllerRun')
                        if (~islogical(varargin{ivarargin+1}))
                            error('mapControllerRun must be a logical');
                        end
                        mapControllerRun = varargin{ivarargin+1};

                    case ('targetIndicesToPlot')
                        targetIndicesToPlot = varargin{ivarargin+1};
                        % Trim off out of bounds indices
                        targetIndicesToPlot = targetIndicesToPlot(targetIndicesToPlot <= length(obj.mapCorrectedTargetDataStruct) & ...
                                                        targetIndicesToPlot > 0);
                        nTargetIndicesToPlot = length(targetIndicesToPlot);

                    case ('targetKeplerIdsToPlot')
                        targetKeplerIdsToPlot = varargin{ivarargin+1};
                        kicArray = [obj.intermediateMapResults.kic];
                        targetIndicesToPlot = find(ismember([kicArray.keplerId], targetKeplerIdsToPlot));
                        nTargetIndicesToPlot = length(targetIndicesToPlot);

                    case ('figureHandle')
                        setFigureHandle = varargin{ivarargin+1}(1);
                        if (length(varargin{ivarargin+1}) == 2)
                            pdfFigureHandle = varargin{ivarargin+1}(1);
                        end

                    case ('doPlotPdfs')
                        doPlotPdfs = varargin{ivarargin+1};  

                    case ('cadenceTimes')
                        cadenceTimes = varargin{ivarargin+1};

                    otherwise
                        error(['Unknown optional argument: ',varargin{ivarargin}]);
                end
            end

            % Check if we really want to generate the plots
            % If this function is not called from the map controller (i.e. mapControllerRun = false) then this
            % is being called by an external function or the command line. In which case we always want to
            % plot.
            if (mapControllerRun && ~obj.debug.doAnalyzeReducedSetOfTargets)
                return;
            else
                doFiguresSaveState = obj.debug.doFigures;
                obj.debug.doFigures = true;
            end

            lineWidth = 2;

            % Plot MAP and robust fits to light curves
            if (isempty(setFigureHandle))
                fit_plots_fig = obj.debug.create_figure;
            else
                fit_plots_fig = figure(setFigureHandle);
            end

            if (doPlotPdfs)
                if (isempty(cadenceTimes))
                    error('If requesting PDF plots then cadenceTimes must be passed as an optional argument');
                end
                robustFitCoefficients = zeros(length(obj.basisVectors(1,:)), nTargets);
                for iTarget = 1 : nTargets
                    robustFitCoefficients(:,iTarget) = obj.intermediateMapResults(iTarget).robustFitCoefficients;
                end
                % This is needed for the confitional PDC curve
                targetDataStruct = repmat(struct('values', [], 'uncertainties', [], 'gapindicators', []), [nTargets,1]);
                for iTarget = 1 : nTargets
                    targetDataStruct(iTarget).values = obj.intermediateMapResults(iTarget).mapInputFluxValues;
                    targetDataStruct(iTarget).uncertainties = obj.intermediateMapResults(iTarget).mapInputUncertainties;
                    targetDataStruct(iTarget).gapIndicators = obj.mapCorrectedTargetDataStruct(iTarget).gapIndicators;
                end
                % normalize for use with PDFs
                doNanGaps = false;
                doMaskRecovery = true;
                maskWindow = 150; % pdcModuleParameters *not* passed to mapResultsClass! I hope this value never changes!!!
                normTargetDataStruct = mapNormalizeClass.normalize_flux (targetDataStruct, obj.mapParams.fitNormalizationMethod, doNanGaps, ...
                    doMaskRecovery, cadenceTimes, maskWindow);
            end

            for iTargetToAnalyze = 1 : nTargetIndicesToPlot 
                iTarget = targetIndicesToPlot(iTargetToAnalyze);

                % Don't plot gaps (won't be plotted if NaN'd
                targetGaps = obj.mapCorrectedTargetDataStruct(iTarget).gapIndicators;
                % Plot vs cadence index not cadence time
               %timestamps = obj.cadenceTimestamps;
                timestamps = [1:length(obj.cadenceTimestamps)];
                timestamps(targetGaps) = NaN;

                obj.debug.select_figure(fit_plots_fig);
                p1 = subplot(2,1,1);
                mapInputFluxValues = obj.intermediateMapResults(iTarget).mapInputFluxValues;
                mapInputFluxValues(targetGaps) = NaN;
                plot(timestamps, mapInputFluxValues, '-b', 'LineWidth', lineWidth);
                hold on

                % The stored coefficient values are in the normalized basis. So we must denormalize to get the absolute fit
                robustFit = obj.get_fit_from_coefficients (iTarget, 'robust', doNanGaps);
                plot(timestamps, robustFit, '-g', 'LineWidth', lineWidth);

                priorFit = obj.get_fit_from_coefficients (iTarget, 'prior', doNanGaps);

                if (obj.targetsMapAppliedTo(iTarget))
                    plot(timestamps, priorFit, '-c', 'LineWidth', lineWidth);
                    mapFit = obj.get_fit_from_coefficients (iTarget, 'map', doNanGaps);
                    plot(timestamps, mapFit, '-r', 'LineWidth', lineWidth);
                    preamble = '';
                    % Either showing raDecMag or centroid prior
                    if (isfield (obj.intermediateMapResults(iTarget).priorPdfInfo, 'centroidPrior') && ...
                            isfield (obj.intermediateMapResults(iTarget).priorPdfInfo.centroidPrior, 'centroidPriorUsed') && ...
                                                obj.intermediateMapResults(iTarget).priorPdfInfo.centroidPrior.centroidPriorUsed)
                        legend('Raw Flux', 'Robust Fit', 'Centroid Prior Fit', 'MAP Fit', 'Location', 'Best');
                    else
                        legend('Raw Flux', 'Robust Fit', 'raDecMag Prior Fit', 'MAP Fit', 'Location', 'Best');
                    end
                elseif(obj.quickMapPerformed)
                    quickMapFit = obj.get_fit_from_coefficients (iTarget, 'quickMap', doNanGaps);
                    if (obj.intermediateMapResults(iTarget).priorGoodness ~= 0.0)
                        plot(timestamps, priorFit, '-c', 'LineWidth', lineWidth);
                        plot(timestamps, quickMapFit, '-r', 'LineWidth', lineWidth);
                    else
                        % No LC MAP fit, prior Goodness is zero, so reduced robust fit
                        plot(timestamps, quickMapFit, '-m', 'LineWidth', lineWidth);
                    end
                    preamble = '';
                    if (obj.intermediateMapResults(iTarget).priorGoodness ~= 0.0)
                        legend('Raw Flux', 'Robust Fit', 'LC MAP Fit', 'Quick MAP Fit', 'Location', 'Best');
                    else
                        % No LC MAP fit, prior Goodness is zero, so reduced robust fit
                        legend('Raw Flux', 'Robust Fit', 'Reduced Robust Fit', 'Location', 'Best');
                    end
                else
                    % Reduced Robust Fit used instead
                    % If Prior is available then plot it
                    reducedRobustFit = obj.get_fit_from_coefficients (iTarget, 'reducedRobust', doNanGaps);
                    plot(timestamps, reducedRobustFit, '-m', 'LineWidth', lineWidth);
                    % If the prior is a flat line (but non-zero since mean/median flux is there) then don't plot the meaningless prior
                    if (~all(diff(priorFit(~isnan(priorFit))) == 0))
                        plot(timestamps, priorFit, '-c', 'LineWidth', lineWidth);
                        legend('Raw Flux', 'Robust Fit', 'Reduced Robust Fit', 'Prior Fit', 'Location', 'Best');
                    else
                        legend('Raw Flux', 'Robust Fit', 'Reduced Robust Fit', 'Location', 'Best');
                    end
                    preamble = 'MAP not performed! ';
                end
                variability = obj.intermediateMapResults(iTarget).variability;
                keplerId = obj.intermediateMapResults(iTarget).kic.keplerId;
                priorWeight = obj.intermediateMapResults(iTarget).priorWeight;
                title([obj.runLabel, '; ',preamble, 'Raw and Fit Curves; KID = ', num2str(keplerId), '; Tgt Index = ', ...
                            num2str(iTarget), '; Var = ', num2str(variability), '; Prior Goodness = ', ...
                            num2str(obj.intermediateMapResults(iTarget).priorGoodness),...
                            '; W_{pr} = ', num2str(priorWeight)]);
                xlabel('Cadence Index')
                ylabel('Absolute Flux [e- / cadence]');
                grid on;
                hold off;

                p2 = subplot(2,1,2);
                % Both parts of robustResidual is non-normalized, so we need to add back in the median or mean.
                robustResidual = obj.intermediateMapResults(iTarget).mapInputFluxValues - robustFit;
                if (~any(strcmp('normMethod', properties(obj))))
                    error('plot_selected_targets: target do not appear to be normalized, something is wrong!');
                elseif (strcmp(obj.normMethod, 'median'))
                    robustResidual = robustResidual + obj.intermediateMapResults(iTarget).medianFlux;
                elseif (any(strcmp(obj.normMethod, {'mean', 'std', 'sqrtMedian', 'noiseFloor'})))
                    robustResidual = robustResidual + obj.intermediateMapResults(iTarget).meanFlux;
                else
                    error('plot_selected_targets: Unknown normalization method!');
                end
                robustResidual(targetGaps) = NaN;
                plot(timestamps, robustResidual, '-g', 'LineWidth', lineWidth);
                hold on;
                mapCorrectedValues = obj.mapCorrectedTargetDataStruct(iTarget).values;
                mapCorrectedValues(targetGaps) = NaN;
                plot(timestamps, mapCorrectedValues, '-r', 'LineWidth', lineWidth);
                if (obj.targetsMapAppliedTo(iTarget))
                    legend('Robust Residual', 'MAP Residual', 'Location', 'Best');
                elseif(obj.quickMapPerformed)
                    legend('Robust Residual', 'Quick MAP Residual', 'Location', 'Best');
                else
                    legend('Robust Residual', 'Reduced Robust Residual', 'Location', 'Best');
                end
                title('Corrected Flux Time Series');
                xlabel('Cadence Index')
                ylabel('Absolute Flux [e- / cadence]');
                grid on;
                hold off;

                linkaxes([p1 p2],'x');


                % Plot PDFs if requested
                if (doPlotPdfs)
                    pdfFigureHandle = obj.pdf.plot_pdf(iTarget, obj.intermediateMapResults(iTarget).kic.keplerId, ...
                                        obj.basisVectors, obj.mapParams, normTargetDataStruct, robustFitCoefficients, obj.debug, pdfFigureHandle);
                end

                string = ['Displaying MAP Results for target ', num2str(iTargetToAnalyze), ' of ', ...
                            num2str(nTargetIndicesToPlot )];
                if (mapControllerRun)
                    obj.debug.pause(string);
                    filename = ['resultant_plot_keplerID_', num2str(keplerId)];
                    obj.debug.save_figure(fit_plots_fig , component, filename);
                elseif(iTargetToAnalyze ~= nTargetIndicesToPlot)
                    disp(string);
                    pause;
                else
                    disp(string);
                end
            end
            % Restore doFigures state for posterity
            obj.debug.doFigures = doFiguresSaveState ;
        end % plot_selected_targets

        %********************************************************************************
        % function [badPriorRatio] = bad_prior_ratio (obj) 
        %
        %   Calculates the fraction of targets where the prior was bad but still generated. This is based on the values of
        %   mapResultsObject.intermediateMapResults(:).priorGoodness. It ignores targets where map was not attempted.
        %
        %********************************************************************************

        function [badPriorRatio] = bad_prior_ratio (obj) 
            
            component = 'resultantPlots';

            if (~any(obj.targetsMapWasAttempted) || obj.quickMapPerformed)
                % make silent if quick map is performed.
                obj.debug.display(component, 'plot_prior_goodness: MAP was not attempted for any targets so no prior ratio');
                badPriorRatio = NaN;
                return
            end

            % For targets where MAP was not attempted the priorGoodness is set to 0 so they should not be included in the statistics.
            priorGoodnessArray = [obj.intermediateMapResults(obj.targetsMapWasAttempted).priorGoodness];
            % Set targets where prior goodness is below threshold to zero
            priorGoodnessArray(priorGoodnessArray < obj.mapParams.priorWeightGoodnessCutoff) = 0.0;

            % If prior goodness is zero then set to 1, otherwise set to zero, This inverts the
            % prior goodness into a prior badness flag
            badPriorArray = (priorGoodnessArray == 0);
            badPriorRatio = length(find(badPriorArray)) / length(badPriorArray);

        end

        %********************************************************************************
        % function [mapPerformedRatio] = map_performed_ratio (obj)
        %
        %   Calculates the ratio of targets where MAP was performend (instead of reduced robust fit).
        %

        function [mapPerformedRatio] = map_performed_ratio (obj)

            component = 'resultantPlots';

            if (~any(obj.targetsMapAppliedTo) || obj.quickMapPerformed)
                % make silent if quick map is performed.
                obj.debug.display(component, 'plot_prior_goodness: MAP was not attempted for any targets so no true "MAP" performance');
                mapPerformedRatio = NaN;
                return
            end

            mapPerformedRatio = length(find(obj.targetsMapAppliedTo)) / length(obj.targetsMapAppliedTo);

        end

        %********************************************************************************
        % function [] = plot_coefficient_utilization (obj)
        %
        % Plots the utlilazation of each coefficient using the ksdensity "survivor" function.
        %
        % Inputs:
        %   doSavePlots -- [logical (optional)] save plots using debug plotting information
        %

        function [] = plot_coefficient_utilization (obj, doSavePlots)

        component =  'compileResults';

        if (~obj.debug.query_do_plot(component))
            return;
        end

        if (~exist('doSavePlots', 'var'))
            doSavePlots = false;
        end

        % Create matrix of coefficients in normalize basis
        % We only care about the absolute value of the coefficients

        if(obj.quickMapPerformed)
            mapCoeffs    = abs([obj.intermediateMapResults.quickMapFitCoefficients]);
        else
            mapCoeffs    = abs([obj.intermediateMapResults(obj.targetsMapAppliedTo).mapFitCoefficients]);
        end
        robustCoeffs = abs([obj.intermediateMapResults.robustFitCoefficients]);

        % Plot Robust coefficients
        figHandle = obj.plot_pdf_of_coeffs(robustCoeffs, ...
                        'Basis Vector Robust Fit Utilization');
        if (doSavePlots)
            filename = 'robust_coeff_utilization';
            obj.debug.save_figure(figHandle, component, filename);
        end


        if (~all(size(mapCoeffs) == [0 0]))
            % Plot MAP coefficients
            figHandle = obj.plot_pdf_of_coeffs(mapCoeffs, ...
                        'Basis Vector MAP Fit Utilization');

            if (doSavePlots)
                filename = 'map_coeff_utilization';
                obj.debug.save_figure(figHandle, component, filename);
            end
        end

        end

        %********************************************************************************
        % function [] = plot_prior_goodness (obj, doSavePlots)
        %
        % Plots the prior goodness statistics.
        %

        function [] = plot_prior_goodness (obj, doSavePlots)

        component =  'compileResults';

        if (~obj.debug.query_do_plot(component))
            return;
        end

        if (~any(obj.targetsMapWasAttempted) || obj.quickMapPerformed)
            % make silent if quick map is performed.
            obj.debug.display(component, 'plot_prior_goodness: MAP was not attempted for any targets so no Prior Goodness to plot');
            return
        end

        if (~exist('doSavePlots', 'var'))
            doSavePlots = false;
        end

        % For targets where map was not attempted the priorGoodness is set to 0 so they should not be included in the statistics.
        priorGoodnessArray = [obj.intermediateMapResults(obj.targetsMapWasAttempted).priorGoodness];
        
        figHandle = obj.debug.create_figure;

        [f, xi] = ksdensity(priorGoodnessArray , 'function', 'cdf');
        plot(xi, 100*(1-f), '-r');
        grid on;
        title('Prior PDF Goodness Percentiles');
        xlabel('Goodness Value');
        ylabel('Percent at or above [%]');
        axis([0 1 0 100]);
        set(gca, 'YDir', 'reverse');
        
        if (doSavePlots)
            filename = 'prior_pdf_goodness';
            obj.debug.save_figure(figHandle, component, filename);
        end

        end

        %********************************************************************************
        % function [fit] = get_fit_from_coefficients (obj, targetIndexList, fitType, doNanGaps)
        %
        % Returns the fit of type <fitType>.
        %
        % Inputs:
        %   targetIndexList -- [int array] target index in targetDataStruct
        %   fitType     -- [char] fit type name, Options:
        %                   'prior', 'robust', 'reducedRobust', 'map', 'quickMap', 'spike'
        %   doNanGaps   -- NaN any gaps in the data (mainly for plotting purposes)
        %
        % Outputs:
        %   fit         -- [float matrix(nCadences,nTargets)] the fitted curve
        %

        function [fit] = get_fit_from_coefficients (obj, targetIndexList, fitType, doNanGaps)

            % If Map had failed then just return an empty set
            if (obj.mapFailed)
                fit = [];
                return;
            end

            fit = zeros(length(obj.mapCorrectedTargetDataStruct(1).values), length(targetIndexList));

            nBasisVectors = length(obj.basisVectors(1,:));

            switch fitType
                case ('prior')
                    fitCoeffs = [obj.intermediateMapResults(targetIndexList).priorFitCoefficients];
                case ('robust')
                    fitCoeffs = [obj.intermediateMapResults(targetIndexList).robustFitCoefficients];
                case ('spike')
                    fitCoeffs = [obj.intermediateMapResults(targetIndexList).robustSpikeCoefficients];
                case ('reducedRobust')
                    nBasisVectorsForReducedRobustFit = min(size(obj.basisVectors,2), obj.mapParams.svdOrderForReducedRobustFit);
                    fitCoeffs = zeros(nBasisVectorsForReducedRobustFit, length(targetIndexList));
                    for targetIndex = 1 : length(targetIndexList)
                        iTarget = targetIndexList(targetIndex);
                        fitCoeffs(:,targetIndex) = [obj.intermediateMapResults(iTarget).robustFitCoefficients(1:nBasisVectorsForReducedRobustFit)];
                    end
                    nBasisVectors = nBasisVectorsForReducedRobustFit;
                case ('map')
                    fitCoeffs = [obj.intermediateMapResults(targetIndexList).mapFitCoefficients];
                case ('quickMap')
                    fitCoeffs = [obj.intermediateMapResults(targetIndexList).quickMapFitCoefficients];
                otherwise
                    error ('get_fit_from_coefficients: Unknown fit type');
            end

            for targetIndex = 1 : length(targetIndexList)

                iTarget = targetIndexList(targetIndex);
                % The stored coefficient values are in the normalized basis. So we must denormalize to get the absolute fit

                switch fitType
                    case ('spike')
                        normalizedFit = obj.spikeBasisVectors * fitCoeffs(:,targetIndex);
                    otherwise
                        normalizedFit = obj.basisVectors(:,1:nBasisVectors) * fitCoeffs(:,targetIndex);
                end
                fit(:, targetIndex) = mapNormalizeClass.denormalize_value(normalizedFit, obj.intermediateMapResults(iTarget).medianFlux, ...
                        obj.intermediateMapResults(iTarget).meanFlux, obj.intermediateMapResults(iTarget).stdFlux, ...
                        obj.intermediateMapResults(iTarget).noiseFloor, obj.normMethod);

                if (doNanGaps)
                    targetGaps = obj.mapCorrectedTargetDataStruct(iTarget).gapIndicators;
                    fit(targetGaps, targetIndex) = NaN;
                end
            end

        end % get_fit_from_coefficients

    end % Public methods

%*******************************************************************************
    methods (Static = true)

        %********************************************************************************
        % function  obj = construct_from_struct (mapResultsStruct)
        %
        % This will construct the mapResultsObject using the data stored in mapResultsStruct which was saved
        % in the task output directory.
        %

        function obj = construct_from_struct (mapResultsStruct)

            verbosity = true;

            % First create a "naked" mapResultsObject with empty properties
            obj = mapResultsClass();

            % Now populate the properites with those in mapResultsStruct
            %I would LOVE to do this with set_properties_with_struct_values but Matlab decided superclasses
            % cannot change private or protected properties
            % assert_property is used here since new fields added mapResultsClass will not exists in older
            % versions. So, set to default value (just empty set unless there a reason for something else)
            obj = obj.assert_property (mapResultsStruct, 'mapParams', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'runLabel', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'alerts', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'normMethod', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'mapFailed', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'diagS', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'uMatrix', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'vMatrix', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'basisVectors', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'spikeBasisVectors', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'basisVectorEntropy', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'targetsForSvd', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'targetsForGeneratingPriors', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'targetsMapAppliedTo', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'targetsMapWasAttempted', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'medianVariability', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'cadenceTimestamps', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'mapCorrectedTargetDataStruct', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'intermediateMapResults', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'mapBlobStruct', [], verbosity);
            obj = obj.assert_property (mapResultsStruct, 'quickMapPerformed', [], verbosity);

            % Debug properties. debug is an object
            obj.debug = mapDebugClass.construct_from_struct(mapResultsStruct.debug);

            % pdf properties. pdf is an object but may be saved as a struct
           %if (~strcmp(class(mapResultsStruct.pdf), 'mapPdfClass'))
            if (isfield(mapResultsStruct, 'pdf') && ~isempty(mapResultsStruct.pdf))
                obj.pdf = mapPdfClass.construct_from_struct(mapResultsStruct.pdf);
            else
                obj.pdf = [];
            end
                
        end

    end % static methods

%*******************************************************************************
    methods(Access = 'private')

        % We need to only set the values if they exist in mapResultsStruct. Using assert_field converts the
        % object into a struct, so create new function so keep as object
        function obj = assert_property (obj, struct, field, value, verbosity)

            struct = assert_field (struct, field, value, verbosity);

            obj.(field) = struct.(field);

        end

        %*******************************************************************************
        % Helper function for plot_coefficient_utilization
        function [figHandle] = plot_pdf_of_coeffs(obj, coeffs, titleText)

            figHandle = obj.debug.create_figure;
            legendNames = cell(length(coeffs(:,1)), 1);
            obj.debug.select_figure(figHandle);
            fMax = 0;
            set(0,'DefaultAxesLineStyleOrder','-|-.|--|:')
            for iBasis = 1 : length(coeffs(:,1))
                [f, xi] = ksdensity(coeffs(iBasis,:), 'function', 'survivor');
                fMax = max(max(f), fMax);
                plotThesePoints = xi > 0;
                loglog(xi(plotThesePoints),f(plotThesePoints), 'LineWidth', 2.5);
                hold all;
                legendNames{iBasis} = num2str(iBasis);
            end
            % min survivor value is 1 / nTargets plotted
            % (no less than 1 / nTarget can survive)
            if (length(coeffs(1,:)) == 1)
                yMin = 0.99;
            else
                yMin = 1 / length(coeffs(1,:));
            end
            axis([1e-4, max(max(coeffs))*1.5, yMin , 1e0]);
            legend(legendNames);
            xlabel('Absolute Value of Coefficient Value');
            ylabel('Coefficient Survivor Value (i.e. the ratio that exists past this value)');
            title(titleText);

        end

        %*******************************************************************************
        % Function to create blob structure. This contains all the information needed by SC MAP from LC MAP.
        % This blob is also used for forcing MAP to use specific basis vectors and priors for fitting.
        % mapInput is passed so that the cadence times are recorded

        function [] = create_blob_structure (obj, mapInput)

            obj.mapBlobStruct = struct ( ...
                                    'mapFailed',             obj.mapFailed, ...
                                    'kic',                   [obj.intermediateMapResults.kic], ...
                                    'cadenceTimes',          mapInput.cadenceTimes, ...
                                    'targetsMapAppliedTo',   obj.targetsMapAppliedTo, ...
                                    'variability',           [obj.intermediateMapResults.variability], ...
                                    'basisVectors',          obj.basisVectors, ...
                                    'mapFitCoefficients',    [obj.intermediateMapResults.mapFitCoefficients], ...
                                    'gapIndicators',         [obj.mapCorrectedTargetDataStruct.gapIndicators]);

        end % create_blob_structure

        %*******************************************************************************
        %
        % This is to save a smaller structure to be loaded by pdc_create_output_struct. 
        % The main mapResultsObject is huge at >500 MB whereas this reduced struct is <100 MB.

        function [] = create_and_save_short_mapResultsStruct (obj)

            component = 'compileResults';

            % We want to save the lesser singular vectors after the main basis vectors. How many do we save in total (greater+lesser)?
            nLesserBasisVectors = 16;

            nTargets = length(obj.mapCorrectedTargetDataStruct);

            intermediateMapResults = repmat(struct ('priorWeight', [], 'priorGoodness', [], 'priorPdfInfo', [], 'robustFitCoefficients', []), [nTargets,1]);
            if (obj.mapFailed || isempty(obj.uMatrix))
                uMatrixShort = [];
            else
                uMatrixShort = obj.uMatrix(:,1:min(nLesserBasisVectors, length(obj.uMatrix(1,:))));
            end
            shortMapResultsStruct = struct ('mapFailed', obj.mapFailed, 'basisVectors', obj.basisVectors, 'uMatrix', uMatrixShort , ...
                                            'diagS', obj.diagS, 'mapBlobStruct', obj.mapBlobStruct, 'targetsMapAppliedTo', obj.targetsMapAppliedTo, ...
                                            'intermediateMapResults', intermediateMapResults);

            if (~obj.mapFailed)
                for iTarget = 1 : nTargets
                    shortMapResultsStruct.intermediateMapResults(iTarget).priorWeight           = obj.intermediateMapResults(iTarget).priorWeight;
                    shortMapResultsStruct.intermediateMapResults(iTarget).priorGoodness         = obj.intermediateMapResults(iTarget).priorGoodness;
                    shortMapResultsStruct.intermediateMapResults(iTarget).priorPdfInfo          = obj.intermediateMapResults(iTarget).priorPdfInfo;
                    shortMapResultsStruct.intermediateMapResults(iTarget).robustFitCoefficients = obj.intermediateMapResults(iTarget).robustFitCoefficients;
                end
            end

            obj.debug.display(component, 'Saving shortMapResultsStruct to file...');
            filename = ['shortMapResultsStruct_', obj.debug.runLabel];
            structName = ['shortMapResultsStruct_', obj.debug.runLabel];
            eval([structName ' = shortMapResultsStruct;']);
            intelligent_save(filename, structName);
            eval(['clear ', structName]); 
            clear shortMapResultsStruct;
            obj.debug.display(component, 'Finished saving shortMapResultsStruct to file.');
            
        end % create_and_save_short_mapResultsStruct

    end % private methods

end

