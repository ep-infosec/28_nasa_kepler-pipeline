% function spsdBlob = compile_spsd_blob(pdcInputObject,spsdCorrectedFluxObject)
%
%     generates an SPSD data blob for use in SC processing
%
%     INPUTS:
%         pdcInputObject                   - [pdcInputClass]
%         spsdCorrectedFluxObject          - the spsdCorrectedFluxObject as generated by spsd_controller
%
%     OUTPUTS:
%         spsdBlob
%           .longCadenceTimes              - cadenceTimes struct (as from pdcInputObject)
%           .events                        - struct array containing the SPSD events with the subfields:
%             .index                       - index of this target in LC taskfile
%             .keplerId                    - Kepler ID of this target
%             .lcCadences()                - indices for each SPSD in this target in LC
%             .cadenceTimesStart()         - cadence start times for each SPSD (based on cadenceIndex)
%             .cadenceTimesEnd()           - cadence end times for each SPSD (based on cadenceIndex+1)
%             .correctionRecovery{}        - recovery part of the correction
%             .correctionPersistentStep{}  - persistent step part of the correction
%
%     NOTE:
%         The window is +-60 SCs, as assigned in
%             spsdBlob(k+1).cadenceTimesStart
%             spsdBlob(k+1).cadenceTimesEnd
%         This can be changed to a larger window, or could be an input parameter later if needed.
%         Specified in HALFWINDOWWIDTH, and currently set to +-2 LC.
%         This is always valid because SPSDs will not be detected at the very beginning or end of a time series (as
%         confirmed by Rob Morris).
%
%*************************************************************************************************************
% 
% Copyright 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% 
% NASA acknowledges the SETI Institute's primary role in authoring and
% producing the Kepler Data Processing Pipeline under Cooperative
% Agreement Nos. NNA04CC63A, NNX07AD96A, NNX07AD98A, NNX11AI13A,
% NNX11AI14A, NNX13AD01A & NNX13AD16A.
% 
% This file is available under the terms of the NASA Open Source Agreement
% (NOSA). You should have received a copy of this agreement with the
% Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
% 
% No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
% WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
% INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
% WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
% INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
% FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
% TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
% CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
% OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
% OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
% FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
% REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
% AND DISTRIBUTES IT "AS IS."
% 
% Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
% AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
% SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
% THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
% EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
% PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
% SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
% STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
% PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
% REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
% TERMINATION OF THIS AGREEMENT.
%

function spsdBlob = compile_spsd_blob(pdcInputObject,spsdCorrectedFluxObject)

    HALFWINDOWWIDTH = 2; % 2 means 2 LC on each side, so 4 LC in total, resulting in a 120 SC window

    spsdBlob = [];
    
    spsdBlob.longCadenceTimes = pdcInputObject.cadenceTimes;
    
    nTargetsWithSpsds = spsdCorrectedFluxObject.resultsStruct.spsds.count;
    for i = 1:nTargetsWithSpsds
        nSpsds = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.spsdCount;
        spsdBlob.events(i).index = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.index;
        spsdBlob.events(i).keplerId = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.keplerId;
        clear ind;
        for j=1:nSpsds
            ind(j) = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.spsd{j}.spsdCadence;
        end
        [tmp I] = sort(ind);
        for j = 1:length(I)
            spsdBlob.events(i).lcCadences(j) = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.spsd{I(j)}.spsdCadence;
            spsdBlob.events(i).cadenceTimesStart(j) = pdcInputObject.cadenceTimes.startTimestamps(spsdBlob.events(i).lcCadences(j) -HALFWINDOWWIDTH+1);
            spsdBlob.events(i).cadenceTimesEnd(j) = pdcInputObject.cadenceTimes.endTimestamps(spsdBlob.events(i).lcCadences(j) +HALFWINDOWWIDTH);
            spsdBlob.events(i).correctionRecovery{j} = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.spsd{I(j)}.recoveryTerm;
            spsdBlob.events(i).correctionPersistentStep{j} = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.spsd{I(j)}.persistentStep;
        end                
    end
    if (nTargetsWithSpsds==0)
        spsdBlob.events = [];
    end
    
% 
% - old code: spsdBlob generated from outputStruct. outdated and can probably be deleted
%
%     %% detection data    
%     nTargets = length(outputsStruct.targetResultsStruct);
%     for i=1:nTargets
%         if ~isempty(outputsStruct.targetResultsStruct(i).discontinuityIndices)
%             k = length(spsdBlob);
%             spsdBlob(k+1).index = i;
%             spsdBlob(k+1).keplerId = pdcInputObject.targetDataStruct(i).keplerId;
%             % note the +1 here because outputsStruct is -based
%             spsdBlob(k+1).lcCadences = sort(outputsStruct.targetResultsStruct(i).discontinuityIndices) +1;
%             spsdBlob(k+1).cadenceTimesStart = pdcInputObject.cadenceTimes.startTimestamps(spsdBlob(k+1).lcCadences -HALFWINDOWWIDTH+1);
%             % startTimestamps(spsdBlob(k+1).cadences-1 and endTimestamps(spsdBlob(k+1).cadences+2 are valid (see above)
%             spsdBlob(k+1).cadenceTimesEnd = pdcInputObject.cadenceTimes.endTimestamps(spsdBlob(k+1).lcCadences+HALFWINDOWWIDTH);
%             % for each target, sort the events by time. they could be unsorted if multiple Pre-MAP iterations have been
%             % performed. we want the SPSD events to be in chronological order, so that the corrections can be performed
%             % from last to first
%             [~,I] = sort(spsdBlob(k+1).lcCadences);
%             spsdBlob(k+1).lcCadences = spsdBlob(k+1).lcCadences(I);
%             spsdBlob(k+1).cadenceTimesStart = spsdBlob(k+1).cadenceTimesStart(I);
%             spsdBlob(k+1).cadenceTimesEnd = spsdBlob(k+1).cadenceTimesEnd(I);            
%         end
%     end
%        
%     
%     %% and now add the corrections from the spsdCorrectionStruct
%     % TODO: this will not work yet when SPSD detection is iterated in Pre-MAP, which it is not as of 8.2
%     % could be extended later if there is more time for this
%     nSpsdEvents = length(spsdBlob);
%     
%     for i=1:nSpsdEvents
%         spsdBlob(i).correctionRecovery = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.spsd{1}.recoveryTerm;
%         spsdBlob(i).correctionPersistentStep = spsdCorrectedFluxObject.resultsStruct.spsds.targets{i}.spsd{1}.persistentStep;
%     end
%     
    
            
end
