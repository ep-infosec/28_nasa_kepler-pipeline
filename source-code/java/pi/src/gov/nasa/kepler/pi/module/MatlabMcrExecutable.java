/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.pi.module;

import gov.nasa.kepler.hibernate.dbservice.ConfigurationServiceFactory;
import gov.nasa.kepler.hibernate.dbservice.PropertyUtils;
import gov.nasa.kepler.pi.module.io.MatlabBinFileUtils;
import gov.nasa.kepler.services.cmdrunner.NamedPumpStreamHandler;
import gov.nasa.kepler.services.cmdrunner.WriterLogOutputStream;
import gov.nasa.kepler.services.process.ExternalProcess;
import gov.nasa.spiffy.common.metrics.IntervalMetric;
import gov.nasa.spiffy.common.metrics.IntervalMetricKey;
import gov.nasa.spiffy.common.os.OperatingSystemType;
import gov.nasa.spiffy.common.pi.ModuleFatalProcessingException;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.net.InetAddress;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.exec.CommandLine;
import org.apache.commons.exec.DefaultExecutor;
import org.apache.commons.exec.ExecuteWatchdog;
import org.apache.commons.exec.environment.EnvironmentUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This class models an executable generated by the MATLAB compiler (mcc) and
 * uses the MATLAB runtime (mcr).  It encapsulates the setup and execution of an
 * mcr exe and enforces that only one thread will extract the CTF archive.
 * 
 * This class uses {@link ExternalProcess} to launch and monitor
 * the standalone executable.
 * 
 * @author tklaus
 * 
 */
public class MatlabMcrExecutable {
    private static final Log log = LogFactory.getLog(MatlabMcrExecutable.class);

    public static final String BIN_DIR_PROPERTY_NAME = "pi.worker.binDir";
    public static final String MODULE_EXE_MCRROOT_PROPERTY_NAME = "pi.worker.moduleExe.mcrRoot";
    public static final String MODULE_EXE_LIBPATH_PROPERTY_NAME = "pi.worker.moduleExe.libPath";
    public static final String MODULE_EXE_BIN_DIR_PROPERTY_NAME = "pi.worker.moduleExe.binDir";
    public static final String MODULE_EXE_DATA_DIR_PROPERTY_NAME = "pi.worker.moduleExe.dataDir";
    public static final String MODULE_EXE_RETRY_COUNT_PROPERTY_NAME = "pi.worker.moduleExe.retryCount";
    public static final String MODULE_EXE_SAVE_MAT_FILES_PROPERTY_NAME = "pi.worker.moduleExe.saveMatFiles";
    public static final String MATLAB_PROCESS_EXEC_METRIC = "pipeline.module.executeAlgorithm.matlab.all.execTime";
    public static final int MODULE_EXE_RETRY_COUNT_DEFAULT = 1;
    
    private static final String MATLABHOME_ENV_NAME = "MATLABHOME";
    private static final String MCRROOT_ENV_NAME = "MCRROOT";
    private static final String LM_LICENSE_FILE_ENV_NAME = "LM_LICENSE_FILE";
    
    private String binaryName;
    private File workingDir;
    private int timeoutSecs;

    private final OperatingSystemType osType = OperatingSystemType.getInstance();
    
    private String libPath;
    private File binaryDir;
    private int retryCount = 0;
    private boolean logOutput = true;
    
    private static class ExpandCtfLock {}
    private static ExpandCtfLock expandCtfLock = new ExpandCtfLock();

    public MatlabMcrExecutable(String binaryName, File workingDir, int timeoutSecs) throws Exception {
        this.binaryName = binaryName;
        this.workingDir = workingDir;
        this.timeoutSecs = timeoutSecs;

        libPath = PropertyUtils.getProperty(MODULE_EXE_LIBPATH_PROPERTY_NAME);
        String binaryDirString = PropertyUtils.getProperty(MODULE_EXE_BIN_DIR_PROPERTY_NAME);
        binaryDir = new File(binaryDirString);

        Configuration config = ConfigurationServiceFactory.getInstance();
        retryCount = config.getInteger(MODULE_EXE_RETRY_COUNT_PROPERTY_NAME, MODULE_EXE_RETRY_COUNT_DEFAULT);
        
        String hostname = "<unknown>";
        try {
            hostname = InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            log.warn("failed to get hostname", e);
        }

        log.info("osType = " + osType.toString());
        log.info("hostname = " + hostname);
        log.info("binaryDir = " + binaryDir);
        log.info("binaryName = " + binaryName);
        log.info("libPath = " + libPath);
        log.info("retryCount = " + retryCount);
    }

    public static int execAlgorithm(String binaryName, File workingDir, int timeoutSecs, int sequenceNum, boolean logOutput) {
        System.out.println("binaryName=" + binaryName);
        System.out.println("workingDir=" + workingDir);
        System.out.println("sequenceNum=" + sequenceNum);
        System.out.println("timeoutSecs=" + timeoutSecs);

        if(!workingDir.exists() || !workingDir.isDirectory()){
            System.err.println("WORKING_DIR (" + workingDir + ") does not exist or is not a directory");
            System.exit(-1);
        }
        
        int retCode = -1;
        
        try {
            MatlabMcrExecutable matlabExe = new MatlabMcrExecutable(binaryName, workingDir,
                timeoutSecs);
            matlabExe.setLogOutput(logOutput);
            retCode = matlabExe.execAlgorithm(sequenceNum);

            File errorFile = MatlabBinFileUtils.errorFile(workingDir, binaryName, sequenceNum);
            
            if(retCode != 0){
                log.warn("Marking sub-task as failed because retCode = " + retCode);
                markSubTaskFailed(workingDir);
            }

            if(errorFile.exists()){
                log.warn("Marking sub-task as failed because the MATLAB error file exists");
                markSubTaskFailed(workingDir);
            }
        } catch (Exception e) {
            log.warn("Marking sub-task as failed because the MATLAB process failed to execute");
            markSubTaskFailed(workingDir);
        }
        return retCode;
    }

    /**
     * Run a MATLAB process that implements the science algorithm
     * using the standard arguments (workingDir, seqNum, saveMatFlag, exePath)
     * 
     * @param sequenceNum
     * @return
     * @throws Exception
     */
    public int execAlgorithm(int sequenceNum) throws Exception{
        List<String> commandLineArgs = new LinkedList<String>();
        String exePath = workingDir.getCanonicalPath();
        commandLineArgs.add(exePath);
        commandLineArgs.add("" + sequenceNum);

        Configuration config = ConfigurationServiceFactory.getInstance();
        if (config.getBoolean(MODULE_EXE_SAVE_MAT_FILES_PROPERTY_NAME, false)) {
            commandLineArgs.add("1"); // save as .mat files
        } else {
            commandLineArgs.add("0");
        }

        File exe = new File(binaryDir.getPath() + "/" + binaryName);

        commandLineArgs.add(exe.getCanonicalPath());
        commandLineArgs.add("0"); // isChild=false
        commandLineArgs.add("__init__"); // default userData
        
        AlgorithmStateFile stateFile = new AlgorithmStateFile(workingDir);
        stateFile.updateCurrentState(AlgorithmStateFile.TaskState.PROCESSING);
        
        int retCode = -1;
        IntervalMetricKey key = IntervalMetric.start();
        try{
            key = IntervalMetric.start();
            retCode = run(commandLineArgs, "" + sequenceNum);
        }finally{
            IntervalMetric.stop(MATLAB_PROCESS_EXEC_METRIC, key);
        }

        if (retCode == 0) {
            stateFile.updateCurrentState(AlgorithmStateFile.TaskState.COMPLETE);
        }else{
            /*
             * Treat all MATLAB exe failures as fatal. It's possible that they
             * may be transient (like a database connection failure), but those
             * kinds of errors are probably in the minority, and we currently
             * have no way of telling the difference. It would be nice to have a
             * way to differentiate between transient errors and other errors so
             * we can do the right thing here. Lacking that, this solution just
             * requires that the operator manually restart the task (with the
             * PIG) rather than having the infrastructure automatically retry
             * (as is done for transient errors in the Java code)
             */

            stateFile.updateCurrentState(AlgorithmStateFile.TaskState.FAILED);
            throw new ModuleFatalProcessingException("failed to execute external program, retCode = " + retCode);
        }
        
        log.info("MATLAB process completed, retCode=" + retCode);
        
        return retCode;
    }
    
    /**
     * Run an arbitrary MATLAB process with caller-specified arguments.
     * No {@link AlgorithmStateFile} is created and a default logSuffix
     * of "0" is used.
     * 
     * @param commandLineArgs
     * @return
     * @throws Exception
     */
    public int execSimple(List<String> commandLineArgs) throws Exception{
        int retCode = run(commandLineArgs, "0");
        
        log.info("execSimple: retCode = " + retCode);
        
        return retCode;
    }
    
    private int run(List<String> commandLineArgs, String logSuffix) throws Exception {

        /*
         * When a matlab-generated exe runs for the very first time, it expands
         * the foo.ctf file into a foo_mcr directory structure. This logic
         * ensures that only one thread does this so that multiple expander
         * processes don't step on each other.
         */
        synchronized (expandCtfLock) {
            
            File ctfFile = new File(binaryDir, binaryName + ".ctf");
            if(ctfFile.exists()){
                log.debug("checking for _mcr");
                File mcrExe = new File(binaryDir, binaryName);
                String mcrDirName = binaryName + "_mcr";
                File mcrDir = new File(binaryDir, mcrDirName);
                
                if(!mcrDir.exists() || (mcrExe.lastModified() > mcrDir.lastModified())){
                    log.info(mcrDirName + " not found or out of date, invoking exe to extract CTF");
                    runCommandline(null, binaryName + "-ctf", "0");
                    log.debug("done invoking exe to extract CTF");
                }else{
                    log.debug("_mcr already exists");
                }
            }
        }

        log.debug("running with args");
        return runCommandline(commandLineArgs, binaryName + "-", logSuffix);
    }

    private int runCommandline(List<String> commandline, String logPrefix, String logSuffix) throws Exception {
        // File workingDirFile = null;
        FileWriter stdOutWriter = null;
        FileWriter stdErrWriter = null;
        File binary = new File(binaryDir.getPath() + "/" + binaryName);

        try {
            log.info("executing " + binary);

            CommandLine command = new CommandLine(binary.getCanonicalPath());
            for (int i = 0; i < commandline.size(); i++) {
                command.addArgument(commandline.get(i));
            }
            
            log.info("CommandLine: " + command);
            
            stdOutWriter = new FileWriter(new File(workingDir, logPrefix + "stdout-" + logSuffix + ".log"));
            stdErrWriter = new FileWriter(new File(workingDir, logPrefix + "stderr-" + logSuffix + ".log"));

            @SuppressWarnings("unchecked")
            Map<String, String> env = EnvironmentUtils.getProcEnvironment();
            
            updateEnvForConfig(env);

            // make sure DISPLAY is not set, so MATLAB can't pop up windows
            // (which block the exe from exiting)
            env.remove("DISPLAY");
            
            /*
             * 
             * http://www.mathworks.com/support/solutions/en/data/1-D40UP3/index.html
             * 
             * "When running a deployed application, please make sure that the environment 
             * variable MATLABHOME is always set to MCRROOT. If not, the application will 
             * run as though it is running inside MATLAB. Hence, the licensing server will be contacted."
             * 
             */
            Configuration config = ConfigurationServiceFactory.getInstance();
            String mcrRoot = config.getString(MODULE_EXE_MCRROOT_PROPERTY_NAME);
            
            if(mcrRoot != null){
                env.put(MATLABHOME_ENV_NAME, mcrRoot);
                env.put(MCRROOT_ENV_NAME, mcrRoot);
            }else{
                env.put(MATLABHOME_ENV_NAME, "");
                env.put(MCRROOT_ENV_NAME, "");
            }
            
            env.put(osType.getSharedObjectPathEnvVar(), libPath);
            
            // Make sure LM_LICENSE_FILE is set to /dev/null since it otherwise may cause 
            // undesirable access to the MATLAB license server at run time
            env.put(LM_LICENSE_FILE_ENV_NAME, "/dev/null");
            
            int retCode = 0;
            IntervalMetricKey key = IntervalMetric.start();
            
            try{
                DefaultExecutor executor = new DefaultExecutor();

                WriterLogOutputStream stdout = new WriterLogOutputStream(stdOutWriter, logOutput);
                WriterLogOutputStream stderr = new WriterLogOutputStream(stdErrWriter, logOutput);
                NamedPumpStreamHandler outputHandler = new NamedPumpStreamHandler(stdout, stderr);
                outputHandler.setThreadLabel(Thread.currentThread().getName());
                executor.setStreamHandler(outputHandler);
                
                ExecuteWatchdog timeout = new ExecuteWatchdog(timeoutSecs * 1000);
                executor.setWatchdog(timeout);
                
                executor.setWorkingDirectory(workingDir);
                
                retCode = executor.execute(command, env);
            }finally{
                try {
                    stdOutWriter.close();
                } catch (Exception e) {
                }
                try {
                    stdErrWriter.close();
                } catch (Exception e) {
                }
                IntervalMetric.stop("pipeline.module.externalProcess." + binaryName + ".execTime", key);
            }

            return retCode;
        } finally {
            if (stdOutWriter != null) {
                try {
                    stdOutWriter.close();
                } catch (IOException e) {
                    log.warn("failed to close stdOutWriter", e);
                }
            }
            if (stdErrWriter != null) {
                try {
                    stdErrWriter.close();
                } catch (IOException e) {
                    log.warn("failed to close stdErrWriter", e);
                }
            }
        }
    }

    private static void markSubTaskFailed(File workingDir) {
        AlgorithmStateFile subTaskState = new AlgorithmStateFile(workingDir);
        if(subTaskState.currentState() != AlgorithmStateFile.TaskState.FAILED){
            try {
                subTaskState.updateCurrentState(AlgorithmStateFile.TaskState.FAILED);
            } catch (IOException e1) {
                log.error("failed to create .FAILED file for subTask: " + workingDir);
            }
        }
    }
    
    /**
     * Sets the environment variables for the MATLAB process.
     * 
     * Add an env for the path to kepler.properties so that Java code
     * called from MATLAB can find it.
     * 
     * If the override is set, tell the MATLAB process to use the
     * kepler.properties specified by the override, else use the same
     * kepler.properties as this process
     * 
     * @return
     * @throws Exception 
     */
    private void updateEnvForConfig(Map<String, String> env) throws Exception{
        Configuration config = ConfigurationServiceFactory.getInstance();
        String configPath = config.getString(ConfigurationServiceFactory.CONFIG_SERVICE_MATLAB_OVERRIDE_PROPERTIES_PATH_PROP);

        if (configPath == null) {
            File configPropertiesFile = ConfigurationServiceFactory.getConfigPropertiesFile();
            if (configPropertiesFile != null) {
                configPath = configPropertiesFile.getCanonicalPath();
            }
        }

        if (configPath != null) {
            log.info("Setting config " + ConfigurationServiceFactory.CONFIG_SERVICE_PROPERTIES_PATH_ENV + " to "
                + configPath);
            env.put(ConfigurationServiceFactory.CONFIG_SERVICE_PROPERTIES_PATH_ENV, configPath);
        } else {
            log.info("No configPropertiesFile defined, "
                + ConfigurationServiceFactory.CONFIG_SERVICE_PROPERTIES_PATH_ENV
                + " will not be set and java code called from MATLAB will not have access to config properties");
        }

        config = ConfigurationServiceFactory.getInstance();

        if (configPath != null) {
            log.info("Setting config " + ConfigurationServiceFactory.CONFIG_SERVICE_PROPERTIES_PATH_ENV + " to "
                + configPath);
            env.put(ConfigurationServiceFactory.CONFIG_SERVICE_PROPERTIES_PATH_ENV, configPath);
        } else {
            log.info("No configPropertiesFile defined, "
                + ConfigurationServiceFactory.CONFIG_SERVICE_PROPERTIES_PATH_ENV
                + " will not be set and java code called from MATLAB will not have access to config properties");
        }
    }

    private static void usage() {
        System.out.println("exec-matlab BINARY_NAME WORKING_DIR SEQ_NUM TIMEOUT_SECS");
    }

    public boolean isLogOutput() {
        return logOutput;
    }

    public void setLogOutput(boolean logOutput) {
        this.logOutput = logOutput;
    }
    
    /**
     * Command line interface for executing a matlab algorithm.
     * 
     * @param args
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        if (args.length < 4) {
            usage();
            System.exit(-1);
        }
        
        String binaryName = args[0];
        String workingDirStr = args[1];
        String sequenceNumStr = args[2];
        String timeoutSecsStr = args[3];
        File workingDir = new File(workingDirStr);
        int sequenceNum = 0;
        int timeoutSecs = 0;
        
        try {
            sequenceNum = Integer.parseInt(sequenceNumStr);
        } catch (NumberFormatException e) {
            System.err.println("SEQ_NUM must be a number, was '" + sequenceNumStr + "'");
            System.exit(-1);
        }
        
        try {
            timeoutSecs = Integer.parseInt(timeoutSecsStr);
        } catch (NumberFormatException e) {
            System.err.println("TIMEOUT_SECS must be a number, was '" + timeoutSecsStr + "'");
            System.exit(-1);
        }

        int retCode = execAlgorithm(binaryName, workingDir, timeoutSecs, sequenceNum, true);
        
        log.info("MATLAB execution completed, exiting.");
        
        System.exit(retCode);
    }
}
