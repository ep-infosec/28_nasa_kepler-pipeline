/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.etem2;

import static gov.nasa.kepler.common.FitsConstants.*;
import static com.google.common.collect.Lists.newArrayList;
import gov.nasa.kepler.common.FcConstants;
import gov.nasa.kepler.hibernate.gar.CompressionCrud;
import gov.nasa.kepler.hibernate.gar.RequantTable;
import gov.nasa.kepler.hibernate.tad.TargetDefinition;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Base class for Short/Long variants that generate DMC-style cadence FITS files
 * from data generated by ETEM
 * 
 * @author
 * 
 */
abstract public class Etem2Fits {

    private static final Log log = LogFactory.getLog(Etem2Fits.class);

    protected String outputDir;
    protected String pmrfDir;
    protected String inputDir;
    protected String targetListSetName;
    protected int startCadence = 0;
    protected int endCadence = -1;
    protected List<Integer> cadenceGapOffsets;

    /**
     * These fields are used to determine which cadences should have the
     * DCT_PURP=KARF039 MOTION keyword in the primary HDU header. If
     * motionInterval == 0, no keywords will be added
     */
    protected int motionOffset = 0;
    protected int motionInterval = 0;

    protected String runNum;
    protected File runNumDir;
    protected String cadenceType; // "long" or "short"

    protected int numStarPixelsRead = 0;
    protected int numBkgrndPixelsRead = 0;
    protected int numCollateralPixelsRead = 0;
    protected int totalPixelsRead = 0;
    protected int pixelsReadThisCadence = 0;
    protected int numTargetDefs = 0;

    private static Map<Integer, Etem2Metadata> etemMetadataCache = new HashMap<Integer, Etem2Metadata>();

    protected static TargetDefCache targetDefCache = new TargetDefCache();

    protected DataInputStream pixelData;
    protected int pixelValue;

    /**
     * current cadence number being processed
     */
    protected int cadenceNumber = 0;

    protected boolean bigEndian = true;
    protected double cadenceZeroMjd;

    protected int scConfigId;

    protected String masterFitsPath;

    protected double secondsPerShortCadence;

    protected int shortCadencesPerLong;

    protected int compressionId;
    protected int badId;
    protected int bgpId;
    protected int tadId;
    protected int lctId;
    protected int sctId;
    protected int rptId;

    /**
     * True if an ETEM run dir exists for the current mod/out. If false, the
     * FITS file will be filled with MISSING_PIXEL_VALUE
     */
    protected boolean etemDirExists = true;

    /**
     * This ctor is used when processing a specific cadence range, typically by
     * the Etem2FitsPipelineModule
     * 
     * @param outputDir
     * @param inputDir
     * @param ccdModule
     * @param ccdOutput
     * @param observingQuarter
     * @param startCadence
     * @param endCadence
     * @param shortCadencesPerLong
     * @param secondsPerShortCadence
     */
    public Etem2Fits(String outputDir, String inputDir, double cadenceZeroMjd,
        int startCadence, int endCadence, List<Integer> cadenceGapOffsets,
        String targetListSetName, int scConfigId, String masterFitsPath,
        double secondsPerShortCadence, int shortCadencesPerLong,
        int compressionId, int badId, int bgpId, int tadId, int lctId,
        int sctId, int rptId) {
        this.outputDir = outputDir;
        this.inputDir = inputDir;
        this.cadenceZeroMjd = cadenceZeroMjd;
        this.startCadence = startCadence;
        this.endCadence = endCadence;
        this.cadenceGapOffsets = cadenceGapOffsets;
        this.targetListSetName = targetListSetName;
        this.scConfigId = scConfigId;
        this.masterFitsPath = masterFitsPath;
        this.secondsPerShortCadence = secondsPerShortCadence;
        this.shortCadencesPerLong = shortCadencesPerLong;
        this.compressionId = compressionId;
        this.badId = badId;
        this.bgpId = bgpId;
        this.tadId = tadId;
        this.lctId = lctId;
        this.sctId = sctId;
        this.rptId = rptId;

        if (System.getProperty("sun.cpu.endian")
            .equals("little")) {
            bigEndian = false;
        }
    }

    /**
     * 
     * nCadences = PixelCounts.getNCadences() nTargets =
     * TargetCounts.getTargetCount()
     * 
     * for nCadences for nTargets for nTargetsPixels / nCadences (pixels for
     * current target) write pixels to SCT PMRF for nCollateralPixels /
     * nCadences (pixels for current target) write pixels to SCC PMRF
     * 
     * @throws Exception
     */
    abstract void generateFits() throws Exception;

    /**
     * Clear the static caches.
     */
    public synchronized static void clearState() {
        indexedPixelValues = null;
        etemMetadataCache = new HashMap<Integer, Etem2Metadata>();
        targetDefCache = new TargetDefCache();
    }

    protected static Etem2Metadata fetchEtemMetadataFromCache(int channel) {
        log.debug("Etem2Fits.fetch");
        synchronized (etemMetadataCache) {
            return etemMetadataCache.get(channel);
        }
    }

    protected static void setEtemMetadata(int channel, Etem2Metadata data) {
        log.debug("Etem2Fits.setEtemMetadata");
        synchronized (etemMetadataCache) {
            etemMetadataCache.put(channel, data);
        }
    }

    /**
     * @return Does the ETEM output dir exist?
     */
    protected boolean init(int ccdModule, int ccdOutput) throws Exception {

        runNum = inputDir + "/run_" + cadenceType + "_m" + ccdModule + "o"
            + ccdOutput + "s1/";

        log.debug("runNumDir = " + runNum);

        // Do nothing if the runNum directory does not exist.
        runNumDir = new File(runNum);
        if (!runNumDir.exists()) {
            log.debug("runNumDir does not exist: runNumDir = "
                + runNumDir.getAbsolutePath());
            // init not successful.
            return false;
        }

        int channel = FcConstants.getChannelNumber(ccdModule, ccdOutput);

        synchronized (etemMetadataCache) {
            Etem2Metadata etemMetadata = fetchEtemMetadataFromCache(channel);
            if (etemMetadata == null) {
                log.debug("Loading .mat files");

                PixelCounts pixelCounts = new PixelCounts(runNumDir,
                    cadenceType);
                if (log.isDebugEnabled()) {
                    pixelCounts.log();
                }
                etemMetadata = new Etem2Metadata(pixelCounts);
                etemMetadataCache.put(channel, etemMetadata);
            }
        }

        // init successful.
        return true;
    }

    protected void openEtemPixelDataFile() throws IOException {
        pixelData = new DataInputStream(new BufferedInputStream(
            new FileInputStream(new File(runNumDir,
                "ssrOutput/quantizedCadenceData.dat"))));
        // runNum + "ssrOutput/requantizedCadenceData.dat")));
        // runNum + "ssrOutput/scienceCadenceData.dat "
    }

    protected void closeEtemPixelDataFile() throws IOException {
        /*
         * int unreadPixels = 0; while ( true ) { try { readPixel();
         * unreadPixels++; } catch ( Exception e ) { break; } } if ( 0 <
         * unreadPixels ) { log.error("There were " + unreadPixels + " pixels
         * left unread in the input file."); }
         */
        log.debug("closing pixelData");
        pixelData.close();

    }

    protected boolean hasMotion(int cadenceNumber) {
        boolean m = false;

        if (motionInterval > 0) {
            m = cadenceNumber >= motionOffset
                && ((cadenceNumber - motionOffset) % motionInterval == 0);
        }

        return (m);
    }

    /**
     * 
     * @return
     */
    protected int readPixel() throws Exception {
        byte b1 = pixelData.readByte();
        int valueIndex = 0;
        int unsign = b1;
        unsign = unsign << 24;
        unsign = unsign >>> 24;
        valueIndex = unsign;
        valueIndex = valueIndex << 8;
        byte b2 = pixelData.readByte();
        unsign = b2;
        unsign = unsign << 24;
        unsign = unsign >>> 24;
        valueIndex = valueIndex | unsign;
        pixelValue = indexedPixelValues[valueIndex];
        // log.debug("valueIndex=" + valueIndex + ", pixelValue=" + pixelValue);
        return pixelValue;
    }

    protected static int[] indexedPixelValues = null;
    public static int[] meanBlackValues = null;

    public synchronized static void loadRequantizationTable(int compressionId)
        throws Exception {

        if (indexedPixelValues == null) {
            CompressionCrud compressionCrud = new CompressionCrud();
            RequantTable requantTable = compressionCrud.retrieveUplinkedRequantTable(compressionId);
            indexedPixelValues = requantTable.getRequantFluxes();
            // TODO Use mean black values.
            meanBlackValues = requantTable.getMeanBlackValues();
        }

        // TODO remove this:
        // File reqTableMat = new File(path);
        // MatFileReader reqTableReader = new MatFileReader(reqTableMat);
        // MLDouble reqTab = (MLDouble)
        // reqTableReader.getMLArray("requantizationTable");
        // int[] dims = reqTab.getDimensions();
        // indexedPixelValuesCount = dims[0];
        // log.debug("indexedPixelValuesCount=" + indexedPixelValuesCount);
        // indexedPixelValues = new int[indexedPixelValuesCount];
        // for (int i = 0; i < indexedPixelValuesCount; i++) {
        // indexedPixelValues[i] = reqTab.get(i).intValue();
        // }
    }

    protected List<Integer> getRawValueColumn(
        List<TargetDefinition> targetDefinitions) throws Exception {
        int nTargets = targetDefinitions.size();
        int targetIdx = 0;
        log.debug("nTargets=" + nTargets);

        List<Integer> rawValueColumn = newArrayList();

        for (TargetDefinition targetDef : targetDefinitions) {
            if (0 == targetIdx % 100) {
                log.debug("target=" + targetIdx);
            }

            int numOffsets = targetDef.getMask()
                .getOffsets()
                .size();

            for (int i = 0; i < numOffsets; i++) {

                if (etemDirExists) {
                    pixelValue = readPixel();
                } else {
                    pixelValue = MISSING_PIXEL_VALUE;
                }

                rawValueColumn.add(pixelValue);
            }

            numStarPixelsRead++;
            pixelsReadThisCadence++;
            targetIdx++;
        }
        return rawValueColumn;
    }

    /**
     * @return the cadenceZeroMjd
     */
    protected double getCadenceZeroMjd() {
        return cadenceZeroMjd;
    }

    /**
     * @param cadenceZeroMjd the cadenceZeroMjd to set
     */
    protected void setCadenceZeroMjd(double startMjd) {
        this.cadenceZeroMjd = startMjd;
    }

    /**
     * @return the scConfigId
     */
    protected int getScConfigId() {
        return scConfigId;
    }

    /**
     * @param scConfigId the scConfigId to set
     */
    protected void setScConfigId(int scConfigId) {
        this.scConfigId = scConfigId;
    }

    /**
     * @return the motionOffset
     */
    public int getMotionOffset() {
        return motionOffset;
    }

    /**
     * @param motionOffset the motionOffset to set
     */
    public void setMotionOffset(int motionOffset) {
        this.motionOffset = motionOffset;
    }

    /**
     * @return the motionInterval
     */
    public int getMotionInterval() {
        return motionInterval;
    }

    /**
     * @param motionInterval the motionInterval to set
     */
    public void setMotionInterval(int motionInterval) {
        this.motionInterval = motionInterval;
    }

}
