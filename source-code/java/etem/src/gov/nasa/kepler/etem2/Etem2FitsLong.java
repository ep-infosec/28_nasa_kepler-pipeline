/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.etem2;

import static gov.nasa.kepler.common.FitsConstants.*;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.primitives.Ints.toArray;
import gov.nasa.kepler.common.FcConstants;
import gov.nasa.kepler.etem.CollateralCadenceFits;
import gov.nasa.kepler.etem.TargetCadenceFits;
import gov.nasa.kepler.hibernate.cm.TargetListSet;
import gov.nasa.kepler.hibernate.cm.TargetSelectionCrud;
import gov.nasa.kepler.hibernate.dbservice.DatabaseService;
import gov.nasa.kepler.hibernate.dbservice.DatabaseServiceFactory;
import gov.nasa.kepler.hibernate.tad.TargetDefinition;
import gov.nasa.kepler.hibernate.tad.TargetTable;
import gov.nasa.kepler.hibernate.tad.TargetTable.TargetType;
import gov.nasa.spiffy.common.pi.PipelineException;

import java.io.EOFException;
import java.io.IOException;
import java.util.Date;
import java.util.List;

import nom.tam.fits.Header;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;

// import org.apache.log4j.xml.DOMConfigurator;

/**
 * Generates DMC-style cadence FITS files from pixel data generated by ETEM
 * 
 * @author Todd Klaus tklaus@arc.nasa.gov
 * 
 */
public class Etem2FitsLong extends Etem2Fits {
    private static final Log log = LogFactory.getLog(Etem2FitsLong.class);

    /*
     * private String pixelFileDir; private String pmrfDir; private String
     * inputDir; private int ccdModule; private int ccdOutput; private int
     * observingQuarter; private int externalId; private int startCadence = 0;
     * private int endCadence = -555555;
     */

    // private String runNum;
    // private PixelCounts pixelCounts;
    // private TargetCounts targetCounts;
    // private int numStarPixelsRead = 0;
    // private int numBkgrndPixelsRead = 0;
    // private int numCollateralPixelsRead = 0;
    // private int totalPixelsRead = 0;
    // private int pixelsReadThisCadence = 0;
    private boolean requantEnabled = true;

    // used by FitsFfi2FitsLong
    protected List<TargetDefinition> targetDefinitions = null;
    protected List<TargetDefinition> backgroundTargetDefinitions = null;

    // used by FitsFfi2FitsLc
    protected TargetCadenceFits targetPixelData;
    protected TargetCadenceFits bkgrndPixelData;
    protected CollateralCadenceFits ctlPixelData;

    public Etem2FitsLong(String outputDir, String inputDir,
        double cadenceZeroMjd, int startCadence, int endCadence,
        List<Integer> cadenceGapOffsets, String targetListSetName,
        int scConfigId, String masterFitsPath, double secondsPerShortCadence,
        int shortCadencesPerLong, int compressionId, int badId, int bgpId,
        int tadId, int lctId, int sctId, int rptId) {
        super(outputDir, inputDir, cadenceZeroMjd, startCadence, endCadence,
            cadenceGapOffsets, targetListSetName, scConfigId, masterFitsPath,
            secondsPerShortCadence, shortCadencesPerLong, compressionId, badId,
            bgpId, tadId, lctId, sctId, rptId);
        cadenceType = "long";
    }

    /**
     * Called by generatePixelFilesOnly() and generatePixelFilesAndPmrfFiles()
     * 
     * nCadences = PixelCounts.getNCadences() nTargets =
     * TargetCounts.getTargetCount()
     * 
     * for nCadences for nTargets for nTargetsPixels / nCadences (pixels for
     * current target) write pixels to LCM PMRF for nCollateralPixels /
     * nCadences (pixels for current target) write pixels to LCC PMRF
     * 
     * @throws Exception
     */
    public void generateFits() throws Exception {

        // Create masterHeadersCaches.
        List<Header> targetMasterHeaders = TargetCadenceFits.getMasterHeaders(
            masterFitsPath, TargetType.LONG_CADENCE);
        List<Header> backgroundMasterHeaders = TargetCadenceFits.getMasterHeaders(
            masterFitsPath, TargetType.BACKGROUND);
        List<Header> collateralMasterHeaders = CollateralCadenceFits.getMasterHeaders(
            masterFitsPath, TargetType.LONG_CADENCE);

        cadenceNumber = startCadence;

        DatabaseService dbService = DatabaseServiceFactory.getInstance();
        TargetSelectionCrud targetSelectionCrud = new TargetSelectionCrud(
            dbService);

        TargetListSet targetListSet = targetSelectionCrud.retrieveTargetListSet(targetListSetName);

        if (targetListSet == null) {
            throw new PipelineException("No targetListSet found for name: "
                + targetListSetName);
        }

        TargetTable targetTable = targetListSet.getTargetTable();

        if (targetTable == null) {
            throw new PipelineException(
                "No targetTable found for targetListSetName: "
                    + targetListSetName);
        }

        TargetTable backgroundTable = targetListSet.getBackgroundTable();

        if (backgroundTable == null) {
            throw new PipelineException(
                "No backgroundTable found for targetListSetName: "
                    + targetListSetName);
        }

        try {
            while (true) { // for each cadence (until EOF or we reach
                // endCadence)

                int cadenceOffset = cadenceNumber - startCadence;
                if (cadenceGapOffsets == null
                    || !cadenceGapOffsets.contains(cadenceOffset)) {
                    if (cadenceNumber % 100 == 0) {
                        log.info("cadenceNumber " + cadenceNumber);
                    }

                    boolean setMotionKeyword = hasMotion(cadenceNumber);

                    // Long Cadence Pixel Data File
                    targetPixelData = new TargetCadenceFits(outputDir,
                        TargetType.LONG_CADENCE, cadenceNumber, cadenceZeroMjd,
                        targetMasterHeaders, scConfigId,
                        secondsPerShortCadence, shortCadencesPerLong,
                        compressionId, badId, bgpId, tadId, lctId, sctId,
                        rptId, setMotionKeyword);
                    // targetPixelData.setRequant(requantEnabled);
                    targetPixelData.setRequantEnabled(requantEnabled);

                    // Long Cadence Background Pixel Data File
                    bkgrndPixelData = new TargetCadenceFits(outputDir,
                        TargetType.BACKGROUND, cadenceNumber, cadenceZeroMjd,
                        backgroundMasterHeaders, scConfigId,
                        secondsPerShortCadence, shortCadencesPerLong,
                        compressionId, badId, bgpId, tadId, lctId, sctId,
                        rptId, setMotionKeyword);
                    // bkgrndPixelData.setRequant(requantEnabled);
                    bkgrndPixelData.setRequantEnabled(requantEnabled);

                    // Long Cadence Collateral Pixel Data File
                    ctlPixelData = new CollateralCadenceFits(outputDir,
                        TargetType.LONG_CADENCE, cadenceNumber, cadenceZeroMjd,
                        collateralMasterHeaders, scConfigId,
                        secondsPerShortCadence, shortCadencesPerLong,
                        compressionId, badId, bgpId, tadId, lctId, sctId,
                        rptId, setMotionKeyword);
                    // ctlPixelData.setRequant(requantEnabled);

                    // List<TargetDefinition> targetDefinitions = null;

                    for (int ccdModule : FcConstants.modulesList) {
                        for (int ccdOutput : FcConstants.outputsList) {

                            log.debug("Processing (module/output/cadenceNumber) = ("
                                + ccdModule
                                + "/"
                                + ccdOutput
                                + "/"
                                + cadenceNumber + ")");

                            targetDefinitions = targetDefCache.getTargetDefs(
                                targetTable, ccdModule, ccdOutput);
                            backgroundTargetDefinitions = targetDefCache.getBackgroundDefs(
                                backgroundTable, ccdModule, ccdOutput);

                            // if (targetDefinitions == null) {
                            // throw new PipelineException(
                            // "No targetDefinitions found for targetListSetName: "
                            // + targetListSetName + " and mod/out: "
                            // + ccdModule + "/" + ccdOutput);
                            // }
                            //
                            if (targetDefinitions != null
                                && !targetDefinitions.isEmpty()) {

                                pixelsReadThisCadence = 0;
                                Etem2Metadata etemMetadata = null;

                                int channel = FcConstants.getChannelNumber(
                                    ccdModule, ccdOutput);

                                etemDirExists = init(ccdModule, ccdOutput);

                                if (etemDirExists) {
                                    log.debug("processing star pixels");
                                    openEtemPixelDataFile();

                                    etemMetadata = fetchEtemMetadataFromCache(channel);

                                    pixelData.skip(cadenceOffset
                                        * etemMetadata.getPixelCounts()
                                            .getBytesPerCadence());
                                } else {
                                    log.debug("No ETEM run dir found for this mod/out, filling FITS with MISSING_PIXEL_VALUE");
                                }

                                processTargetPixels(targetPixelData,
                                    targetDefinitions, ccdModule, ccdOutput);

                                log.debug("processing background pixels");
                                // List<TargetDefinition>
                                // backgroundTargetDefinitions =
                                // targetDefCache.getBackgroundDefs(
                                // backgroundTable, ccdModule, ccdOutput);

                                if (backgroundTargetDefinitions == null) {
                                    throw new PipelineException(
                                        "No backgroundTargetDefinitions found for targetListSetName: "
                                            + targetListSetName
                                            + " and mod/out: " + ccdModule
                                            + "/" + ccdOutput);
                                }

                                processBackgroundPixels(bkgrndPixelData,
                                    backgroundTargetDefinitions, ccdModule,
                                    ccdOutput);

                                log.debug("processing collateral pixels");
                                processCollateralPixels(ctlPixelData,
                                    etemMetadata, ccdModule, ccdOutput);

                                log.debug("DONE processing (module/output/cadenceNumber) = ("
                                    + ccdModule
                                    + "/"
                                    + ccdOutput
                                    + "/"
                                    + cadenceNumber + ")");

                                if (etemDirExists) {
                                    log.debug("closing pixelData");
                                    pixelData.close();
                                }
                            } else {
                                String msg = "(module/output/cadenceNumber) = ("
                                    + ccdModule
                                    + "/"
                                    + ccdOutput
                                    + "/"
                                    + cadenceNumber + ")";

                                if (cadenceNumber == startCadence) {
                                    log.info("SKIPPING (no target defs) " + msg);
                                }

                                // Make sure to write out an hdu with no rows.
                                int[] emptyIntArray = new int[0];
                                targetPixelData.addColumns(emptyIntArray);
                                bkgrndPixelData.addColumns(emptyIntArray);
                                ctlPixelData.addColumns(emptyIntArray);
                            }
                        }
                    }

                    log.debug("saving FITS");
                    targetPixelData.save();
                    bkgrndPixelData.save();
                    ctlPixelData.save();

                    log.debug("DONE cadenceNumber = " + cadenceNumber);
                    log.debug("cadence " + cadenceNumber + ", total pixels = "
                        + totalPixelsRead);
                } else {
                    log.info("Skipping cadenceNumber " + cadenceNumber
                        + " (gapped)");
                }

                if (cadenceNumber >= endCadence) {
                    log.debug("reached endCadence = " + endCadence
                        + ", end of run");
                    break;
                }
                cadenceNumber++;
            }
        } catch (EOFException e) {
            throw new PipelineException("Caught EOF.  ", e);
        }

        log.debug("cadenceNumber = " + cadenceNumber);
        log.debug("numStarPixelsRead = " + numStarPixelsRead);
        log.debug("numBkgrndPixelsRead = " + numBkgrndPixelsRead);
        log.debug("numCollateralPixelsRead = " + numCollateralPixelsRead);
    }

    /**
     * Read the target (star flux) pixels from the .dat file
     * 
     * @param etemMetadata
     * @param targetDefinitions
     */
    private void processTargetPixels(TargetCadenceFits targetPixelData,
        List<TargetDefinition> targetDefinitions, int ccdModule, int ccdOutput)
        throws Exception {

        List<Integer> rawValueColumn = getRawValueColumn(targetDefinitions);
        numStarPixelsRead += rawValueColumn.size();

        targetPixelData.addColumns(toArray(rawValueColumn));

        log.debug("target pixels read = " + pixelsReadThisCadence);
    }

    /**
     * Read the background pixels from the .dat file
     * 
     * @param etemMetadata
     * @param backgroundTargetDefinitions
     */
    private void processBackgroundPixels(TargetCadenceFits bkgrndPixelData,
        List<TargetDefinition> backgroundTargetDefinitions, int ccdModule,
        int ccdOutput) throws Exception {

        List<Integer> rawValueColumn = getRawValueColumn(backgroundTargetDefinitions);
        numBkgrndPixelsRead += rawValueColumn.size();

        bkgrndPixelData.addColumns(toArray(rawValueColumn));

        log.debug("bkgrnd pixels read = " + numBkgrndPixelsRead);
    }

    /**
     * Collateral Pixels
     * 
     * for each collateral type that was read from lc dat file, we write the
     * pixel value to pixel, and we write the metadata to pixel mapping
     * reference file
     * 
     * @param etemMetadata
     * 
     * @param pixelCounts
     * @throws Exception
     */
    protected void processCollateralPixels(CollateralCadenceFits ctlPixelData,
        Etem2Metadata etemMetadata, int ccdModule, int ccdOutput)
        throws Exception {

        List<Integer> rawValueColumn = newArrayList();

        // leading black
        for (int i = 0; i < FcConstants.CCD_ROWS; i++) {
            if (etemDirExists) {
                pixelValue = readPixel();
            } else {
                pixelValue = MISSING_PIXEL_VALUE;
            }
            rawValueColumn.add(pixelValue);
            numCollateralPixelsRead++;
        }

        // masked smear
        for (int i = 0; i < FcConstants.nColsImaging; i++) {
            if (etemDirExists) {
                pixelValue = readPixel();
            } else {
                pixelValue = MISSING_PIXEL_VALUE;
            }
            rawValueColumn.add(pixelValue);
            numCollateralPixelsRead++;
        }

        // virtual smear
        for (int i = 0; i < FcConstants.nColsImaging; i++) {
            if (etemDirExists) {
                pixelValue = readPixel();
            } else {
                pixelValue = MISSING_PIXEL_VALUE;
            }
            rawValueColumn.add(pixelValue);
            numCollateralPixelsRead++;
        }

        ctlPixelData.addColumns(toArray(rawValueColumn));
    }

    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws Exception {
        Logger logger = Logger.getLogger(Etem2FitsLong.class);
        logger.setLevel(Level.INFO);

        org.apache.log4j.BasicConfigurator.configure();

        // String inDir = "/path/to/soc/etem2/auto/2d/long/";
        // String outDir = "/path/to/soc/etem2/auto/2d/long/fits";
        // String requantizedTablePath =
        // "/path/to/shared/steve/requantizationTable.mat";
        // String inDir = "/path/to/etem2/auto/gsit-5a/30d/long/";
        // String outDir = "/path/to/etem2/auto/gsit-5a/30d/long/fits";
        // String requantizedTablePath =
        // "/path/to/requantizationTable.mat";
        // String targetListSetName = "v1-a-lc"

        String inDir = args[0]; // "/path/to/etem2/auto/gsit-5a/30d/long/";
        String outDir = args[1]; // "/path/to/etem2/auto/gsit-5a/30d/long/fits";
        String requantizedTablePath = args[2]; // "/path/to/requantizationTable.mat";
        int startCadence = Integer.valueOf(args[3]);
        int endCadence = Integer.valueOf(args[4]);
        String targetListSetName = args[5];

        loadRequantizationTable(1);

        Date d1 = new Date();

        Etem2FitsLong etem2Fits = new Etem2FitsLong(outDir, inDir,
            0, // externalId,
            startCadence, endCadence, null, targetListSetName, 1, null, 0, 0,
            1, 1, 1, 1, 1, 1, 1);

        etem2Fits.generateFits();

        Date d2 = new Date();
        long x = (d2.getTime() - d1.getTime()) / 1000;
        log.debug("seconds to process = " + x);
        d1 = d2;
    }

    public boolean isRequantEnabled() {
        return requantEnabled;
    }

    public void setRequantEnabled(boolean requantEnabled) {
        this.requantEnabled = requantEnabled;
    }
}
