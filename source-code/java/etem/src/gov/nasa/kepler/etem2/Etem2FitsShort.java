/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.etem2;

import static gov.nasa.kepler.common.FitsConstants.*;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.primitives.Ints.toArray;
import gov.nasa.kepler.common.FcConstants;
import gov.nasa.kepler.etem.CollateralCadenceFits;
import gov.nasa.kepler.etem.TargetCadenceFits;
import gov.nasa.kepler.hibernate.cm.TargetListSet;
import gov.nasa.kepler.hibernate.cm.TargetSelectionCrud;
import gov.nasa.kepler.hibernate.dbservice.DatabaseService;
import gov.nasa.kepler.hibernate.dbservice.DatabaseServiceFactory;
import gov.nasa.kepler.hibernate.tad.TargetDefinition;
import gov.nasa.kepler.hibernate.tad.TargetTable;
import gov.nasa.kepler.hibernate.tad.TargetTable.TargetType;
import gov.nasa.spiffy.common.pi.PipelineException;

import java.io.EOFException;
import java.io.IOException;
import java.util.Date;
import java.util.List;

import nom.tam.fits.Header;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;

/**
 * Generates DMC-style cadence FITS files from SC pixel data generated by ETEM
 * 
 * @author jgunter@arc.nasa.gov
 * 
 */
public class Etem2FitsShort extends Etem2Fits {
    private static final Log log = LogFactory.getLog(Etem2FitsShort.class);

    /*
     * TODO remove private int blackCount = 0; private int maskedSmearCount = 0;
     * private int virtualSmearCount = 0; private int blackMaskedCount = 0;
     * private int blackVirtualCount = 0;
     */

    public Etem2FitsShort(String outputDir, String inputDir,
        double cadenceZeroMjd, int startCadence, int endCadence,
        List<Integer> cadenceGapOffsets, String targetListSetName,
        int scConfigId, String masterFitsPath, double secondsPerShortCadence,
        int shortCadencesPerLong, int compressionId, int badId, int bgpId,
        int tadId, int lctId, int sctId, int rptId) {

        super(outputDir, inputDir, cadenceZeroMjd, startCadence, endCadence,
            cadenceGapOffsets, targetListSetName, scConfigId, masterFitsPath,
            secondsPerShortCadence, shortCadencesPerLong, compressionId, badId,
            bgpId, tadId, lctId, sctId, rptId);
        cadenceType = "short";
    }

    /**
     * 
     * nCadences = PixelCounts.getNCadences() nTargets =
     * TargetCounts.getTargetCount()
     * 
     * for nCadences for nTargets for nTargetsPixels / nCadences (pixels for
     * current target) write pixels to SCT PMRF for nCollateralPixels /
     * nCadences (pixels for current target) write pixels to SCC PMRF
     * 
     * @throws Exception
     */
    void generateFits() throws Exception {

        // Create masterHeadersCaches.
        List<Header> targetMasterHeaders = TargetCadenceFits.getMasterHeaders(
            masterFitsPath, TargetType.SHORT_CADENCE);
        List<Header> collateralMasterHeaders = CollateralCadenceFits.getMasterHeaders(
            masterFitsPath, TargetType.SHORT_CADENCE);

        ProjectionTracker projTracker = new ProjectionTracker();

        System.out.println("runNum ='" + runNum + "'");

        try {
            for (cadenceNumber = startCadence; cadenceNumber <= endCadence; cadenceNumber++) {

                int cadenceOffset = cadenceNumber - startCadence;
                if (cadenceGapOffsets != null
                    && cadenceGapOffsets.contains(cadenceOffset)) {
                    log.info("Skipping cadenceNumber " + cadenceNumber
                        + " (gapped)");
                    continue;
                }

                if (cadenceNumber % 100 == 0) {
                    log.info("cadenceNumber " + cadenceNumber);
                }
                // Short Cadence Pixel Data File
                TargetCadenceFits targetPixelData = new TargetCadenceFits(
                    outputDir, TargetType.SHORT_CADENCE, cadenceNumber,
                    cadenceZeroMjd, targetMasterHeaders, scConfigId,
                    secondsPerShortCadence, shortCadencesPerLong,
                    compressionId, badId, bgpId, tadId, lctId, sctId, rptId,
                    false);

                // Short Cadence Collateral Pixel Data File
                CollateralCadenceFits ctlPixelData = new CollateralCadenceFits(
                    outputDir, TargetType.SHORT_CADENCE, cadenceNumber,
                    cadenceZeroMjd, collateralMasterHeaders, scConfigId,
                    secondsPerShortCadence, shortCadencesPerLong,
                    compressionId, badId, bgpId, tadId, lctId, sctId, rptId,
                    false);

                DatabaseService dbService = DatabaseServiceFactory.getInstance();
                TargetSelectionCrud targetSelectionCrud = new TargetSelectionCrud(
                    dbService);

                TargetListSet targetListSet = targetSelectionCrud.retrieveTargetListSet(targetListSetName);

                if (targetListSet == null) {
                    throw new PipelineException(
                        "No targetListSet found for name: " + targetListSetName);
                }

                TargetTable targetTable = targetListSet.getTargetTable();

                if (targetTable == null) {
                    throw new PipelineException(
                        "No targetTable found for targetListSetName: "
                            + targetListSetName);
                }

                List<TargetDefinition> targetDefinitions = null;

                for (int ccdModule : FcConstants.modulesList) {
                    for (int ccdOutput : FcConstants.outputsList) {

                        etemDirExists = init(ccdModule, ccdOutput);

                        targetDefinitions = targetDefCache.getTargetDefs(
                            targetTable, ccdModule, ccdOutput);

                        int totalTargetPixelCount = 0;
                        int totalCollateralPixelCount = 0;

                        if (targetDefinitions != null
                            && !targetDefinitions.isEmpty()) {

                            log.debug("processing target and collateral pixels");
                            openEtemPixelDataFile();

                            int channel = FcConstants.getChannelNumber(
                                ccdModule, ccdOutput);

                            Etem2Metadata etemMetadata = fetchEtemMetadataFromCache(channel);
                            PixelCounts pixelCounts = etemMetadata.getPixelCounts();

                            long toSkip = cadenceOffset
                                * pixelCounts.getBytesPerCadence();
                            long skipped = pixelData.skip(toSkip);
                            if (toSkip != skipped) {
                                throw new Exception("skip returned " + skipped
                                    + " instead of " + toSkip);
                            }

                            pixelsReadThisCadence = 0;

                            int nTargets = targetDefinitions.size();
                            int targetIdx = 0;
                            log.debug("nTargets=" + nTargets);

                            List<Integer> targetRawValueColumn = newArrayList();
                            List<Integer> ctlRawValueColumn = newArrayList();

                            for (TargetDefinition targetDef : targetDefinitions) {
                                int targetPixelCount = projTracker.getScTargetPixelCount(targetDef);
                                totalTargetPixelCount += targetPixelCount;
                                for (int i = 0; i < targetPixelCount; i++) {
                                    pixelValue = getPixelValue();
                                    targetRawValueColumn.add(pixelValue);
                                }

                                int collateralPixelCount = projTracker.getScCollateralPixelCount(targetDef);
                                totalCollateralPixelCount += collateralPixelCount;
                                for (int i = 0; i < collateralPixelCount; i++) {
                                    pixelValue = getPixelValue();
                                    ctlRawValueColumn.add(pixelValue);
                                }

                                if (0 == targetIdx % 100) {
                                    log.debug("For target #" + targetIdx
                                        + ": targetPixelCount="
                                        + targetPixelCount
                                        + ", collateralPixelCount="
                                        + collateralPixelCount);
                                }
                                targetIdx++;
                            }

                            targetPixelData.addColumns(toArray(targetRawValueColumn));
                            ctlPixelData.addColumns(toArray(ctlRawValueColumn));

                            closeEtemPixelDataFile();
                        } else {
                            String msg = "(module/output/cadenceNumber) = ("
                                + ccdModule + "/" + ccdOutput + "/"
                                + cadenceNumber + ")";

                            if (cadenceNumber == startCadence) {
                                log.info("SKIPPING (no target defs) " + msg);
                            }

                            // Make sure to write out an hdu with no rows.
                            int[] emptyIntArray = new int[0];
                            targetPixelData.addColumns(emptyIntArray);
                            ctlPixelData.addColumns(emptyIntArray);
                        }

                        log.debug("mod/out " + ccdModule + "/" + ccdOutput
                            + ", totalTargetPixelCount="
                            + totalTargetPixelCount
                            + ", totalCollateralPixelCount="
                            + totalCollateralPixelCount);
                    }
                }

                log.debug("saving FITS");
                targetPixelData.save();
                ctlPixelData.save();

                log.debug("DONE cadenceNumber = " + cadenceNumber);
                log.debug("cadence " + cadenceNumber + ", total pixels = "
                    + totalPixelsRead);
            }
            log.debug("reached endCadence = " + endCadence + ", end of run");
        } catch (EOFException e) {
            throw new PipelineException("hit end of input data during cadence "
                + cadenceNumber + " before finishing endCadence " + endCadence
                + ", end of run  ", e);
        }

        log.debug("cadenceNumber = " + cadenceNumber);
        log.debug("numStarPixelsRead = " + numStarPixelsRead);
        log.debug("numBkgrndPixelsRead = " + numBkgrndPixelsRead);
        log.debug("numCollateralPixelsRead = " + numCollateralPixelsRead);
    }

    /**
     * Read the next target (star flux) pixel or collateral pixel from the .dat
     * file
     * 
     * @param etemMetadata
     * @param targetDefinitions
     */
    private int getPixelValue() throws Exception {
        int pixelValue = MISSING_PIXEL_VALUE;
        if (etemDirExists) {
            pixelValue = readPixel();
        }
        return pixelValue;
    }

    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws Exception {
        Logger logger = Logger.getLogger(Etem2FitsShort.class);
        logger.setLevel(Level.DEBUG);

        org.apache.log4j.BasicConfigurator.configure();

        String inDir = args[0]; // "/path/to/etem2/auto/2d/short/";
        String outDir = args[1]; // "/path/to/etem2/auto/2d/short/fits";
        String requantizedTablePath = args[2]; // "/path/to/requantizationTable.mat";
        int startCadence = Integer.valueOf(args[3]);
        int endCadence = Integer.valueOf(args[4]);
        String targetListSetName = args[5]; // "v1-a-sc"

        // loadRequantizationTable(1);

        Date d1 = new Date();

        // for (int ccdModule : FcConstants.modulesList) {
        // for (int ccdOutput : FcConstants.outputsList) {
        // log.debug("@@@@@@@@@ m" + ccdModule + "o" + ccdOutput);

        Etem2FitsShort etem2Fits = new Etem2FitsShort(outDir, inDir, 0, // cadenceZeroMjd,
            // startCadence, endCadence,
            0, 1, null, targetListSetName, 1, // scConfigId
            "/path/to/trunk-data/dmc/master-fits/v1/", // masterFitsPath
            // "/path/to/java/systest/master-fits/", // masterFitsPath
            59.78304, // secondsPerShortCadence
            30, // shortCadencesPerLong
            1, // compressionId
            1, // badId
            1, // bgpId
            1, // tadId
            1, // lctId
            1, // sctId
            1); // rptId

        etem2Fits.generateFits();

        Date d2 = new Date();
        long x = (d2.getTime() - d1.getTime()) / 1000;
        log.debug("seconds to process = " + x);
        d1 = d2;
        // }
        // }
    }
}
