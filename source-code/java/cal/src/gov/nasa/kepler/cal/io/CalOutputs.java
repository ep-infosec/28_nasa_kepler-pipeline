/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.cal.io;

import gov.nasa.kepler.hibernate.cal.BlackAlgorithm;
import gov.nasa.kepler.mc.ModuleAlert;
import gov.nasa.spiffy.common.persistable.Persistable;
import gov.nasa.spiffy.common.persistable.ProxyIgnoreStatics;

import java.util.ArrayList;
import java.util.List;

/**
 * Outputs for the cal pipeline module.
 * 
 * @author Sean McCauliff
 * @author Forrest Girouard
 * @author Bill Wohler
 * @author Jason Brittain
 */
@ProxyIgnoreStatics
public class CalOutputs implements Persistable {

    private String blackAlgorithmApplied;
    
    /**
     * Calibrated per-pixel time series data for evey pixel in the visible region
     * including target and background pixels.  There may be zero or more pixels.
     */
    private List<CalOutputPixelTimeSeries> targetAndBackgroundPixels = new ArrayList<CalOutputPixelTimeSeries>();

    /** Calibrated collateral pixels. */
    private CalibratedCollateralPixels calibratedCollateralPixels = new CalibratedCollateralPixels();

    /** Cosmic rays and outliers detected in the collateral pixels. */
    private CosmicRayEvents cosmicRayEvents = new CosmicRayEvents();

    /** Metrics on the detected cosmic rays and outliers. [CAL4, CAL4.CAL.1]*/
    private CalCosmicRayMetrics cosmicRayMetrics = new CalCosmicRayMetrics();
    
    /** Undershoot metrics. [252.CAL.1] */
    private List<CalTargetMetricsTimeSeries> ldeUndershootMetrics = new ArrayList<CalTargetMetricsTimeSeries>();

    /** Metrics about the black pixels. [252.CAL.1] */
    private List<CalTargetMetricsTimeSeries> twoDBlackMetrics = new ArrayList<CalTargetMetricsTimeSeries>();

    private CollateralMetrics collateralMetrics = new CollateralMetrics();
    
    /**
     * Compression efficiency achievable when assumptions match reality
     *  perfectly.  [CAL3.CAL.3]
     */
    private CalCompressionTimeSeries theoreticalCompressionEfficiency = 
        new CalCompressionTimeSeries();

    /**
     * Actual compression efficiency achieved with real data.  [CAL3.CAL.2]
     */
    private CalCompressionTimeSeries achievedCompressionEfficiency = 
        new CalCompressionTimeSeries();
    
    /**
     * Non-fatal warnings generated by cal.
     */
    private List<ModuleAlert> alerts = new ArrayList<ModuleAlert>();
    
    /**
     * The name of a binary .mat file containing the transformations needed 
     * to reconstruct the uncertainty covariance matrix.   This may be the 
     * empty string to indicate that it has not been produced. [143.CAL.1]
     */
    private String uncertaintyBlobFileName = "";

    /** The name of a binary .mat file containing the 1D black model fit.  This
     * may or may not be produced in which case it will be the empty string.
     */
    private String oneDBlackFitBlobFileName = "";
    
    /**
     * The name of the binary .mat file containing smear information.  This
     * may or may not be produced in which case it will be the empty string.
     */
    private String smearBlobFileName = "";
    
    private EmbeddedPipelineInfo pipelineInfoStruct;
    
    
    ////////////////////////////////////
    
    public CalOutputs() {}
    

    public List<CalOutputPixelTimeSeries> getTargetAndBackgroundPixels() {
        return targetAndBackgroundPixels;
    }

    public CalibratedCollateralPixels getCalibratedCollateralPixels() {
        return calibratedCollateralPixels;
    }

    public CosmicRayEvents getCosmicRayEvents() {
        return cosmicRayEvents;
    }

    public CalCosmicRayMetrics getCosmicRayMetrics() {
        return cosmicRayMetrics;
    }

    public List<CalTargetMetricsTimeSeries> getLdeUndershootMetrics() {
        return ldeUndershootMetrics;
    }

    public List<CalTargetMetricsTimeSeries> getTwoDBlackMetrics() {
        return twoDBlackMetrics;
    }

    public CollateralMetrics getCollateralMetrics() {
        return collateralMetrics;
    }

    public CalCompressionTimeSeries getTheoreticalCompressionEfficiency() {
        return theoreticalCompressionEfficiency;
    }

    public CalCompressionTimeSeries getAchievedCompressionEfficiency() {
        return achievedCompressionEfficiency;
    }

    public List<ModuleAlert> getAlerts() {
        return alerts;
    }

    public String getUncertaintyBlobFileName() {
        return uncertaintyBlobFileName;
    }

    public String getOneDBlackFitBlobFileName() {
        return oneDBlackFitBlobFileName;
    }
    
    public EmbeddedPipelineInfo getPipelineInfoStruct() {
        return pipelineInfoStruct;
    }
    
    public EmbeddedPipelineInfo pipelineInfoStruct() {
       return pipelineInfoStruct;
    }

    /** This is used for testing purposes only. */
    public void setTargetAndBackgroundPixels(List<CalOutputPixelTimeSeries> list) {
        this.targetAndBackgroundPixels = list;
    }

    /** This is used for testing purposes only. */
    public void setUncertaintyBlobFileName(String name) {
        this.uncertaintyBlobFileName = name;
    }

    public BlackAlgorithm blackAlgorithmApplied() {
        return BlackAlgorithm.fromPipelineName(blackAlgorithmApplied);
    }

    public String smearBlobFileName() {
        return smearBlobFileName;
    }


    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime
                * result
                + ((achievedCompressionEfficiency == null) ? 0
                        : achievedCompressionEfficiency.hashCode());
        result = prime * result + ((alerts == null) ? 0 : alerts.hashCode());
        result = prime
                * result
                + ((blackAlgorithmApplied == null) ? 0 : blackAlgorithmApplied
                        .hashCode());
        result = prime
                * result
                + ((calibratedCollateralPixels == null) ? 0
                        : calibratedCollateralPixels.hashCode());
        result = prime
                * result
                + ((collateralMetrics == null) ? 0 : collateralMetrics
                        .hashCode());
        result = prime * result
                + ((cosmicRayEvents == null) ? 0 : cosmicRayEvents.hashCode());
        result = prime
                * result
                + ((cosmicRayMetrics == null) ? 0 : cosmicRayMetrics.hashCode());
        result = prime
                * result
                + ((ldeUndershootMetrics == null) ? 0 : ldeUndershootMetrics
                        .hashCode());
        result = prime
                * result
                + ((oneDBlackFitBlobFileName == null) ? 0
                        : oneDBlackFitBlobFileName.hashCode());
        result = prime
                * result
                + ((pipelineInfoStruct == null) ? 0 : pipelineInfoStruct
                        .hashCode());
        result = prime
                * result
                + ((smearBlobFileName == null) ? 0 : smearBlobFileName
                        .hashCode());
        result = prime
                * result
                + ((targetAndBackgroundPixels == null) ? 0
                        : targetAndBackgroundPixels.hashCode());
        result = prime
                * result
                + ((theoreticalCompressionEfficiency == null) ? 0
                        : theoreticalCompressionEfficiency.hashCode());
        result = prime
                * result
                + ((twoDBlackMetrics == null) ? 0 : twoDBlackMetrics.hashCode());
        result = prime
                * result
                + ((uncertaintyBlobFileName == null) ? 0
                        : uncertaintyBlobFileName.hashCode());
        return result;
    }


    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        CalOutputs other = (CalOutputs) obj;
        if (achievedCompressionEfficiency == null) {
            if (other.achievedCompressionEfficiency != null)
                return false;
        } else if (!achievedCompressionEfficiency
                .equals(other.achievedCompressionEfficiency))
            return false;
        if (alerts == null) {
            if (other.alerts != null)
                return false;
        } else if (!alerts.equals(other.alerts))
            return false;
        if (blackAlgorithmApplied == null) {
            if (other.blackAlgorithmApplied != null)
                return false;
        } else if (!blackAlgorithmApplied.equals(other.blackAlgorithmApplied))
            return false;
        if (calibratedCollateralPixels == null) {
            if (other.calibratedCollateralPixels != null)
                return false;
        } else if (!calibratedCollateralPixels
                .equals(other.calibratedCollateralPixels))
            return false;
        if (collateralMetrics == null) {
            if (other.collateralMetrics != null)
                return false;
        } else if (!collateralMetrics.equals(other.collateralMetrics))
            return false;
        if (cosmicRayEvents == null) {
            if (other.cosmicRayEvents != null)
                return false;
        } else if (!cosmicRayEvents.equals(other.cosmicRayEvents))
            return false;
        if (cosmicRayMetrics == null) {
            if (other.cosmicRayMetrics != null)
                return false;
        } else if (!cosmicRayMetrics.equals(other.cosmicRayMetrics))
            return false;
        if (ldeUndershootMetrics == null) {
            if (other.ldeUndershootMetrics != null)
                return false;
        } else if (!ldeUndershootMetrics.equals(other.ldeUndershootMetrics))
            return false;
        if (oneDBlackFitBlobFileName == null) {
            if (other.oneDBlackFitBlobFileName != null)
                return false;
        } else if (!oneDBlackFitBlobFileName
                .equals(other.oneDBlackFitBlobFileName))
            return false;
        if (pipelineInfoStruct == null) {
            if (other.pipelineInfoStruct != null)
                return false;
        } else if (!pipelineInfoStruct.equals(other.pipelineInfoStruct))
            return false;
        if (smearBlobFileName == null) {
            if (other.smearBlobFileName != null)
                return false;
        } else if (!smearBlobFileName.equals(other.smearBlobFileName))
            return false;
        if (targetAndBackgroundPixels == null) {
            if (other.targetAndBackgroundPixels != null)
                return false;
        } else if (!targetAndBackgroundPixels
                .equals(other.targetAndBackgroundPixels))
            return false;
        if (theoreticalCompressionEfficiency == null) {
            if (other.theoreticalCompressionEfficiency != null)
                return false;
        } else if (!theoreticalCompressionEfficiency
                .equals(other.theoreticalCompressionEfficiency))
            return false;
        if (twoDBlackMetrics == null) {
            if (other.twoDBlackMetrics != null)
                return false;
        } else if (!twoDBlackMetrics.equals(other.twoDBlackMetrics))
            return false;
        if (uncertaintyBlobFileName == null) {
            if (other.uncertaintyBlobFileName != null)
                return false;
        } else if (!uncertaintyBlobFileName
                .equals(other.uncertaintyBlobFileName))
            return false;
        return true;
    }
    
    
}
