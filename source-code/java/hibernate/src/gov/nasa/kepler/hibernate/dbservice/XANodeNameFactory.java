/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.hibernate.dbservice;


import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.*;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Generates the node name used to identify this process in the cluster.
 * 
 * @author Sean McCauliff
 *
 */
public class XANodeNameFactory {
    private static final Log log = LogFactory.getLog(XANodeNameFactory.class);
    
    /** This will be prefixed to all the Xids generated by the TM.
     * The value of this property can not be more than 64 bytes long and it
     * must be alphanumeric.
     */
    public static final String TM_NODE_ID_PROPERTY = 
        "com.arjuna.ats.arjuna.xa.nodeIdentifier";
    
    private static final int MAX_NODE_NAME_LEN = 64;
    
    private static volatile XANodeNameFactory instance;
    
    public static boolean isFactorySet() {
        return instance != null;
    }
    
    public static XANodeNameFactory instance() {
        if (instance == null) {
            throw new NullPointerException("XANodeNameFactory instance has not been set.");
        }
        return instance;
    }
    
    public static void setInstance(XANodeNameFactory newInstance) {
        if (newInstance == null) {
            throw new NullPointerException("XaNodeNameFactory instance may not be set to null");
        }
        instance = newInstance;
    
    }
    
    private final String processName;
    
    public XANodeNameFactory(String processName) {
        if (processName == null || processName.length() == 0) {
            throw new IllegalArgumentException("Process name may not be null or empty.");
        }
        this.processName = processName;
    }
    
    public String generateNodeName() {
        String machineName = machineName();
        if (machineName.length() > 32) {
            machineName = machineName.substring(0, 32);
        }
        StringBuilder bldr = new StringBuilder();
        bldr.append(machineName).append(processName);
        if (bldr.length() > MAX_NODE_NAME_LEN) {
            bldr.setLength(MAX_NODE_NAME_LEN);
        }
        return bldr.toString();
    }
    
    private static String machineName() {
        Configuration config = ConfigurationServiceFactory.getInstance();
        if (config.containsKey(TM_NODE_ID_PROPERTY)) {
            return config.getString(TM_NODE_ID_PROPERTY);
        }
        
        try {
            InetAddress localHost = InetAddress.getLocalHost();
            String localHostName = localHost.getHostName();
            if (!localHostName.equals("localhost")) {
                if (localHostName.indexOf('.') != -1) {
                    return localHostName.substring(0, localHostName.indexOf('.'));
                }
                return localHostName;
            }
        } catch (UnknownHostException e) {
            log.warn("Failed to find local host name.", e);
        }
        
        return nicName();

    }
    
    public static String nicName() {
        try {
            Enumeration<NetworkInterface> ifaces = 
                NetworkInterface.getNetworkInterfaces();
            List<byte[]> macs = new ArrayList<byte[]>();
            while (ifaces.hasMoreElements()) {
                NetworkInterface iface = ifaces.nextElement();
                if (iface.isLoopback()) {
                    continue;
                }
                if (iface.isVirtual()) {
                    continue;
                }
                if (iface.getHardwareAddress() == null) {
                    continue;
                }
                macs.add(iface.getHardwareAddress());
            }
            
            if (macs.size() == 0) {
                throw new IllegalStateException("Failed to find network interfaces.");
            }
            
            Collections.sort(macs, new Comparator<byte[]>() {

                @Override
                public int compare(byte[] o1, byte[] o2) {
                    int diff = o1.length - o2.length;
                    if (diff != 0) {
                        return diff;
                    }
                    
                    for (int i=0; i < o1.length; i++) {
                        diff = o1[i] - o2[i];
                        if (diff != 0) {
                            return diff;
                        }
                    }
                    return 0;
                }
            });
            
            return macToString(macs.get(0));
        } catch (SocketException e) {
            throw new IllegalStateException("Failed to find network interfaces.", e);
        }
       
    }
    
    private static String macToString(byte[] mac) {
        StringBuilder bldr = new StringBuilder(16);
        for (int i=0; i < mac.length; i++) {
            bldr.append(String.format("%02x", mac[i]));
            bldr.append(':');
        }
        bldr.setLength(bldr.length() - 1 );
        return bldr.toString();
    }
    
}
