/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.hibernate.tad;

import gov.nasa.kepler.common.FcConstants;
import gov.nasa.kepler.hibernate.pi.PipelineTask;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinTable;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import org.apache.commons.lang.builder.ToStringBuilder;
import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.CascadeType;
import org.hibernate.annotations.CollectionOfElements;
import org.hibernate.annotations.IndexColumn;

/**
 * Used to report the results of a TAD pipeline run. This class is meant to be
 * read by MR.
 * 
 * @author Miles Cote
 */
@Entity
@Table(name = "TAD_TAD_REPORT")
public class TadReport {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO, generator = "sg")
    @SequenceGenerator(name = "sg", sequenceName = "TAD_TAD_REPORT_SEQ")
    @Column(nullable = false)
    private long id;

    /**
     * The {@link PipelineTask} of the TadValPipelineModule that produced this
     * report. Not included in the report.
     */
    @OneToOne(fetch = FetchType.LAZY)
    private PipelineTask pipelineTask;

    /**
     * The number of targets selected by the CM user, after removing duplicates
     * and requested exclusions. Most likely, this will be less than the number
     * of {@link TargetDefinition}s sent to the spacecraft.
     */
    private int mergedTargetCount;

    /**
     * The number of targets that TAD COA deemed inappropriate for photometry.
     */
    private int rejectedByCoaTargetCount;

    /**
     * The number of {@link Mask}s in the {@link MaskTable} used by this
     * {@link TargetTable}. This is the number of aperture definitions that
     * will be sent to the spacecraft.
     */
    private int totalMaskCount;
    
    private int usedMaskCount;

    /**
     * The number of supermasks generated by RPTS. Nominally, there is one
     * background, black, and smear mask per module/output.
     */
    private int supermaskCount;

    /**
     * The total number of pixels sent to the spacecraft divided by the total
     * number of {@link TargetDefinition}s sent to the spacecraft.
     */
    private float averagePixelsPerTargetDef;

    /**
     * The number of custom targets selected by the CM user that did not have an
     * {@link Aperture}. These targets are not sent to the spacecraft, which is
     * an error. This should always be zero.
     */
    @Column(name = "CSTM_TRGS_NO_APT_CNT")
    private int customTargetsWithNoApertureCount;

    /**
     * The number of targets for which the selected {@link Mask}(s) did not
     * completely cover the {@link Aperture}.
     */
    @Column(name = "MSKS_SMLR_THN_APRTR_CNT")
    private int targetsWithMasksSmallerThanOptimalApertureCount;

    /**
     * Contains counts of various types of targets and pixels.
     */
    @OneToOne
    @Cascade(CascadeType.ALL)
    private TargetDefinitionAndPixelCounts targetDefinitionAndPixelCounts = new TargetDefinitionAndPixelCounts();

    /**
     * A set of the signal processing chains for which all module/outputs had
     * zero {@link TargetDefinition}s.
     */
    @CollectionOfElements
    @IndexColumn(name = "IDX")
    @JoinTable(name = "TAD_REP_MSSG_SIG_PROC_CHAINS")
    private Set<Integer> missingSignalProcessingChains = new HashSet<Integer>();
    
    /**
     * A list of errors for the user.
     */
    @CollectionOfElements
    @IndexColumn(name = "IDX")
    private List<String> errors = new ArrayList<String>();

    /**
     * A list of warnings for the user.
     */
    @CollectionOfElements
    @IndexColumn(name = "IDX")
    private List<String> warnings = new ArrayList<String>();

    /**
     * A list of module/output specific reports.
     */
    @OneToMany
    @IndexColumn(name = "IDX")
    @Cascade(CascadeType.ALL)
    @JoinTable(name = "TAD_TAD_REP_TMOR")
    private List<TadModOutReport> modOutReports = new ArrayList<TadModOutReport>();

    /**
     * A list of bins indicating how many targets fell into a range of the
     * metric badPixels / totalPixelsInOptimalApertrue.
     */
    @CollectionOfElements
    @IndexColumn(name = "IDX")
    @JoinTable(name = "TAD_REP_BAD_PIX_RATES")
    private List<BadPixelRateBin> badPixelRateBins = new ArrayList<BadPixelRateBin>();

    public TadReport() {
        modOutReports = new ArrayList<TadModOutReport>();
        for (int ccdModule : FcConstants.modulesList) {
            for (int ccdOutput : FcConstants.outputsList) {
                modOutReports.add(new TadModOutReport(ccdModule, ccdOutput));
            }
        }

        badPixelRateBins = new ArrayList<BadPixelRateBin>();
        badPixelRateBins.add(new BadPixelRateBin(-.1f, 0f));
        badPixelRateBins.add(new BadPixelRateBin(0f, .1f));
        badPixelRateBins.add(new BadPixelRateBin(.1f, .2f));
        badPixelRateBins.add(new BadPixelRateBin(.2f, .3f));
        badPixelRateBins.add(new BadPixelRateBin(.3f, .4f));
        badPixelRateBins.add(new BadPixelRateBin(.4f, .5f));
        badPixelRateBins.add(new BadPixelRateBin(.5f, .6f));
        badPixelRateBins.add(new BadPixelRateBin(.6f, .7f));
        badPixelRateBins.add(new BadPixelRateBin(.7f, .8f));
        badPixelRateBins.add(new BadPixelRateBin(.8f, .9f));
        badPixelRateBins.add(new BadPixelRateBin(.9f, 1f));
    }

    @Override
    public String toString() {
        return new ToStringBuilder(this).append("id", id)
            .append("pipelineTask", pipelineTask.getId())
            .append("mergeTargetCount", mergedTargetCount)
            .append("rejectedByCoaTargetCount", rejectedByCoaTargetCount)
            .append("totalMaskCount", totalMaskCount)
            .append("supermaskCount", supermaskCount)
            .append("averagePixelsPerTargetDef", averagePixelsPerTargetDef)
            .append("customTargetsWithNoApertureCount",
                customTargetsWithNoApertureCount)
            .append("targetsWithMasksSmallerThanOptimalApertureCount",
                targetsWithMasksSmallerThanOptimalApertureCount)
            .append("targetAndPixelCounts", targetDefinitionAndPixelCounts)
            .append("missingSignalProcessingChains",
                missingSignalProcessingChains)
            .append(modOutReports.size() + " modOutReports")
            .toString();
    }

    public TadModOutReport getModuleOutputSummary(int ccdModule, int ccdOutput) {
        return modOutReports.get(FcConstants.getChannelNumber(ccdModule,
            ccdOutput) - 1);
    }

    public List<TadModOutReport> getModOutReports() {
        return modOutReports;
    }

    public void setModOutReports(List<TadModOutReport> moduleOutputSummaries) {
        this.modOutReports = moduleOutputSummaries;
    }

    public int getMergedTargetCount() {
        return mergedTargetCount;
    }

    public void setMergedTargetCount(int mergedTargetCount) {
        this.mergedTargetCount = mergedTargetCount;
    }

    public float getAveragePixelsPerTargetDef() {
        return averagePixelsPerTargetDef;
    }

    public void setAveragePixelsPerTargetDef(float averagePixelsPerTarget) {
        this.averagePixelsPerTargetDef = averagePixelsPerTarget;
    }

    public int getRejectedByCoaTargetCount() {
        return rejectedByCoaTargetCount;
    }

    public void setRejectedByCoaTargetCount(int rejectedByCoaTargetCount) {
        this.rejectedByCoaTargetCount = rejectedByCoaTargetCount;
    }

    public int getTotalMaskCount() {
        return totalMaskCount;
    }

    public void setTotalMaskCount(int totalMaskCount) {
        this.totalMaskCount = totalMaskCount;
    }

    public int getUsedMaskCount() {
        return usedMaskCount;
    }

    public void setUsedMaskCount(int usedMaskCount) {
        this.usedMaskCount = usedMaskCount;
    }

    public PipelineTask getPipelineTask() {
        return pipelineTask;
    }

    public void setPipelineTask(PipelineTask pipelineTask) {
        this.pipelineTask = pipelineTask;
    }

    public TargetDefinitionAndPixelCounts getTargetDefinitionAndPixelCounts() {
        return targetDefinitionAndPixelCounts;
    }

    public void setTargetDefinitionAndPixelCounts(
        TargetDefinitionAndPixelCounts ccdRegionPixelCounts) {
        this.targetDefinitionAndPixelCounts = ccdRegionPixelCounts;
    }

    public int getTargetsWithMasksSmallerThanOptimalApertureCount() {
        return targetsWithMasksSmallerThanOptimalApertureCount;
    }

    public void setTargetsWithMasksSmallerThanOptimalApertureCount(
        int numTargetsWithMasksSmallerThanOptimalAperture) {
        this.targetsWithMasksSmallerThanOptimalApertureCount = numTargetsWithMasksSmallerThanOptimalAperture;
    }

    public List<String> getWarnings() {
        return warnings;
    }

    public void setWarnings(List<String> warnings) {
        this.warnings = warnings;
    }

    public int getSupermaskCount() {
        return supermaskCount;
    }

    public void setSupermaskCount(int masksGeneratedByRptsCount) {
        this.supermaskCount = masksGeneratedByRptsCount;
    }

    public int getCustomTargetsWithNoApertureCount() {
        return customTargetsWithNoApertureCount;
    }

    public void setCustomTargetsWithNoApertureCount(
        int customTargetsWithNoApertureCount) {
        this.customTargetsWithNoApertureCount = customTargetsWithNoApertureCount;
    }

    public Set<Integer> getMissingSignalProcessingChains() {
        return missingSignalProcessingChains;
    }

    public void setMissingSignalProcessingChains(
        Set<Integer> signalProcessingChainsUsed) {
        this.missingSignalProcessingChains = signalProcessingChainsUsed;
    }

    public List<BadPixelRateBin> getBadPixelRateBins() {
        return badPixelRateBins;
    }

    public void setBadPixelRateBins(List<BadPixelRateBin> badPixelRateBins) {
        this.badPixelRateBins = badPixelRateBins;
    }

    public List<String> getErrors() {
        return errors;
    }

    public void setErrors(List<String> errors) {
        this.errors = errors;
    }

}
