/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.ar.exporter.dv;

import java.io.File;
import java.io.IOException;
import java.util.*;

import nom.tam.fits.FitsException;

import gov.nasa.kepler.ar.exporter.FileNameFormatter;
import gov.nasa.kepler.common.pi.FluxTypeParameters.FluxType;
import gov.nasa.kepler.fs.api.FileStoreClient;
import gov.nasa.kepler.fs.api.FsId;
import gov.nasa.kepler.fs.api.FsIdSet;
import gov.nasa.kepler.fs.api.TimeSeriesBatch;
import static gov.nasa.kepler.mc.fs.DvFsIdFactory.*;
import gov.nasa.kepler.hibernate.dv.DvCrud;
import gov.nasa.kepler.hibernate.dv.DvCrud.DvPlanetSummary;
import gov.nasa.kepler.hibernate.pi.PipelineInstance;
import gov.nasa.kepler.hibernate.pi.PipelineInstanceCrud;
import gov.nasa.kepler.mc.dr.MjdToCadence;
import gov.nasa.kepler.mc.dr.MjdToCadence.TimestampSeries;
import gov.nasa.kepler.mc.fs.DvFsIdFactory;
import gov.nasa.spiffy.common.intervals.SimpleInterval;

/**
 * Exports time series generated by data validation.
 * 
 * @author Sean McCauliff
 *
 */
public class DvTimeSeriesExporter {

    private final static float MISSING_DATA_FILL = Float.NaN;
    private final DvCrud dvCrud;
    private final FileStoreClient fsClient;
    private final File outputDir;
    private final MjdToCadence mjdToCadence;
    private final PipelineInstanceCrud pipelineInstanceCrud;
    
    public DvTimeSeriesExporter(DvCrud dvCrud, FileStoreClient fsClient, 
        File outputDir, MjdToCadence mjdToCadence, 
        PipelineInstanceCrud pipelineInstanceCrud) {

        this.dvCrud = dvCrud;
        this.fsClient = fsClient;
        this.outputDir = outputDir;
        this.mjdToCadence = mjdToCadence;
        this.pipelineInstanceCrud = pipelineInstanceCrud;
    }
    
    public void export(int minKeplerId, int maxKeplerId, 
            long pipelineInstanceId, FluxType fluxType) throws FitsException, IOException {
        List<DvPlanetSummary> systems = 
                dvCrud.retrievePlanetSummaryByPipelineInstanceId(pipelineInstanceId, minKeplerId, maxKeplerId);
        Set<Long> pipelineInstanceIds= new HashSet<Long>();
        for (DvPlanetSummary system : systems) {
            pipelineInstanceIds.add(system.pipelineInstanceId);
        }
        
        Set<FsId> singleEventIds = 
            fsClient.queryIds2(DvFsIdFactory.createSingleEventStatisticsQuery(fluxType,
                pipelineInstanceIds, minKeplerId, maxKeplerId));
        Map<Integer, List<FsId>> singleEventIdsPerSystem =
           new HashMap<Integer, List<FsId>>();
        for (FsId sevId : singleEventIds) {
            SingleEventParse parse = DvFsIdFactory.parseSingleEventStatisticsFsId(sevId);
            List<FsId> idsPerSystem = singleEventIdsPerSystem.get(parse.keplerId);
            if (idsPerSystem == null) {
                idsPerSystem = new ArrayList<FsId>(2);
                singleEventIdsPerSystem.put(parse.keplerId, idsPerSystem);
            }
            idsPerSystem.add(sevId);
        }
        
        List<PlanetarySystemTimeSeries> planetarySystems = 
            new ArrayList<PlanetarySystemTimeSeries>(systems.size());
        for (DvPlanetSummary summary : systems) {
            List<FsId> singleEventIdsForSystem = singleEventIdsPerSystem.get(summary.keplerId);
            if (singleEventIdsForSystem == null || singleEventIdsForSystem.size() == 0) {
                throw new IllegalStateException("Missing single event statistic" +
                        " FsIds for solar system with Kepler id " + summary.keplerId);
            }
            PlanetarySystemTimeSeries planetarySystem = 
                new PlanetarySystemTimeSeries(summary, singleEventIdsForSystem, fluxType);
            planetarySystems.add(planetarySystem);
        }
        
        Map<SimpleInterval, FsIdSet> idSetsByCadenceInterval = 
            new HashMap<SimpleInterval, FsIdSet>();
        Map<SimpleInterval, List<PlanetarySystemTimeSeries>> planetarySytemsByCadenceInterval =
            new HashMap<SimpleInterval, List<PlanetarySystemTimeSeries>>();
        
        for (PlanetarySystemTimeSeries planetarySystem : planetarySystems) {
            FsIdSet idSet = idSetsByCadenceInterval.get(planetarySystem.cadenceInterval());
            List<PlanetarySystemTimeSeries> systemList =  planetarySytemsByCadenceInterval.get(planetarySystem.cadenceInterval());
            if (idSet == null) {
                idSet = new FsIdSet(planetarySystem.startCadence(), planetarySystem.endCadence(), new HashSet<FsId>());
                idSetsByCadenceInterval.put(planetarySystem.cadenceInterval(), idSet);
                systemList = new ArrayList<PlanetarySystemTimeSeries>();
                planetarySytemsByCadenceInterval.put(planetarySystem.cadenceInterval(), systemList);
                
            }
            planetarySystem.addIds(idSet.ids());
            systemList.add(planetarySystem);
        }
        
        List<TimeSeriesBatch> timeSeriesBatches =
            fsClient.readTimeSeriesBatch(new ArrayList<FsIdSet>(idSetsByCadenceInterval.values()), true);
        
        Map<SimpleInterval, TimeSeriesBatch> batchByCadenceInterval 
            = new HashMap<SimpleInterval, TimeSeriesBatch>();
        for (TimeSeriesBatch batch : timeSeriesBatches) {
            batchByCadenceInterval.put(batch.cadenceInterval(), batch);
        }
        
        FileNameFormatter fnameFormatter = new FileNameFormatter();
        for (SimpleInterval interval : batchByCadenceInterval.keySet()) {
            TimestampSeries cadenceTimes = 
                mjdToCadence.cadenceTimes((int)interval.start(), (int)interval.end());
            
            TimeSeriesBatch timeSeries = batchByCadenceInterval.get(interval);
            for (PlanetarySystemTimeSeries planetarySystem : planetarySytemsByCadenceInterval.get(interval)) {
                DvTimeSeriesFitsFile dvFff = 
                    planetarySystem.toFluxFitsFile(timeSeries.timeSeries(), 
                        cadenceTimes, MISSING_DATA_FILL);
                PipelineInstance pipelineInstance = pipelineInstanceCrud.retrieve(planetarySystem.pipelineInstanceId());
                Date instEnd = pipelineInstance.getEndProcessingTime();
                String fname = fnameFormatter.dataValidationTimeSeriesName(planetarySystem.keplerId(), instEnd);
                File outputFile = new File(outputDir, fname);
                dvFff.export(outputFile);
            }
        }
    }   
    
}
