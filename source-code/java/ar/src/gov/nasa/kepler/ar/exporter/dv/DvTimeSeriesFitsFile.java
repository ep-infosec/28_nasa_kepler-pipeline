/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.ar.exporter.dv;

import gnu.trove.TFloatArrayList;
import gov.nasa.kepler.ar.exporter.FitsFileCreationTimeFormat;
import static gov.nasa.kepler.common.FitsUtils.*;

import java.io.*;
import java.util.Arrays;
import java.util.Date;

import nom.tam.fits.*;
import nom.tam.util.Cursor;

import static gov.nasa.kepler.common.FitsConstants.*;

/**
 * The flux time series and associated time series generated by DV are exported
 * by this class.
 * 
 * This is used for the DV time series version 1 export.
 * 
 * @author Sean McCauliff
 *
 */
class DvTimeSeriesFitsFile {

    private final float FILL = Float.NaN;
    
    //private static final String ALL_ROBUST_WEIGHT_PLANET = "all_robust_weight_pl";
    private static final String INIT_FLUX_PLANET = "init_flux_pl";
    private static final String MODEL_FIT_LIGHT_CURVE = "model_lc_pl";
    private static final String SOC_PIPELINE_TASK_ID = "STID";
    private static final String NPLANETS = "NPLANETS";
    //suffix with N
    private static final String TRIAL_TRANSIT_PULSE = "TTPULS";
    
    private double mjdStart = Double.NaN;
    private double mjdEnd = Double.NaN;
    
    private float[/* planet number index*/][] initialFlux;
    private float[/*planet number index */][] initialFluxUncertaintiy;
    private float[/* planet number index*/][] modelLightCurve;
    
    private float[] trialTransitPulse;
    private float[/* trail transit pulse index*/][] singleEventNormalized;
    private float[/* trial transit pulse index*/][] singleEventCorrelated;
    
    private float[] residualTimeSeries;
    private float[] residualTimeSeriesUncertaintiy;
    
    private double[] time;
    
    private int[] cadences;
    
    private int keplerId = -1;

    private long pipelineTaskId =-1L;
    
    private int[] planetNumbers;
    
    DvTimeSeriesFitsFile() {
    }
    
    
    void export(File outputFile) throws FitsException, IOException {
        
        Header primaryHeader = createPrimaryHeader(outputFile);
        BinaryTable dataTable = createBinaryTable();
        Header dataHeader = createExtensionHeader(dataTable);
        
        BasicHDU primaryHdu = Fits.makeHDU(primaryHeader);
        BinaryTableHDU dataHdu = new BinaryTableHDU(dataHeader, dataTable);
        
        Fits fits = new Fits();
        fits.addHDU(primaryHdu);
        fits.addHDU(dataHdu);
        
        DataOutputStream dout = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(outputFile), 1024*512));
        fits.write(dout);
        dout.close();
    }
    
    private static Object identityNotNull(Object o, String fieldName) {
        if (o != null) {
            return o;
        }
        throw new NullPointerException(fieldName + " can not be null");
    }
    
    private BinaryTable createBinaryTable() throws FitsException {
        
        int nDataColumns = 2 /* times */ + 2 /* residual */ + planetNumbers.length * 3 +
            trialTransitPulse.length * 2;
        Object[] data = new Object[nDataColumns];
        data[0] = identityNotNull(time, "time");;
        data[1] = identityNotNull(cadences, "cadences");
        data[2] = identityNotNull(residualTimeSeries, "residualTimeSeries");
        data[3] = identityNotNull(residualTimeSeriesUncertaintiy, "residualTimeSeriesUncert");
        int columnIndex = 4;
        for (int planeti=0; planeti < planetNumbers.length; planeti++) {
            int planetNo = planetNumbers[planeti];
            data[columnIndex++] = identityNotNull(initialFlux[planeti], "init flux " + planetNo);
            data[columnIndex++] = identityNotNull(initialFluxUncertaintiy[planeti], "init flux uncert " + planetNo);
        }
        
        for (int pulsei=0; pulsei < trialTransitPulse.length; pulsei++) {
            data[columnIndex++] = identityNotNull(singleEventCorrelated[pulsei], "single event corr " + pulsei);
            data[columnIndex++] = identityNotNull(singleEventNormalized[pulsei], "single event norm " + pulsei);
        }
        for (int planeti=0; planeti < planetNumbers.length; planeti++) {
            data[columnIndex++] = identityNotNull(modelLightCurve[planeti], "model light curve " + planeti);
        }

        BinaryTable fitsBinaryData = 
            (BinaryTable) BinaryTableHDU.encapsulate(data);
        return fitsBinaryData;
    }
    
    private Header createPrimaryHeader(File outputFile) throws FitsException {
        FitsFileCreationTimeFormat creationTime = new FitsFileCreationTimeFormat();
        String creationTimeStr = creationTime.format(new Date());
        Header primaryHeader = new Header();
        primaryHeader.setSimple(true);
        primaryHeader.setBitpix(8);
        primaryHeader.setNaxes(0);
        primaryHeader.addValue(NEXTEND_KW, 1, NEXTEND_COMMENT);
        primaryHeader.addValue(TELESCOP_KW, TELESCOP_VALUE, TELESCOP_COMMENT);
        primaryHeader.addValue(INSTRUME_KW, INSTRUME_VALUE, INSTRUME_COMMENT);
        
        primaryHeader.addValue(DATE_KW, creationTimeStr, DATE_COMMENT);
        primaryHeader.addValue(ORIGIN_KW, ORIGIN_VALUE, ORIGIN_COMMENT);
        primaryHeader.addValue(FILENAME_KW, outputFile.getName(), "name of this file");
        primaryHeader.addValue(KEPLERID_KW, keplerId, "Kepler ID of this target");
        
        return primaryHeader;
    }
    
    @SuppressWarnings("deprecation")
    private Header createExtensionHeader(BinaryTable binaryTable) throws FitsException {
        Header xHeader = manufactureBinaryTableHeader(binaryTable);
        xHeader.addValue(INHERT_KW, INHERIT_VALUE, INHERIT_COMMENT);
        xHeader.addValue(SOC_PIPELINE_TASK_ID, pipelineTaskId, 
            "The Kepler SOC pipeline task id that generated this data");
        xHeader.insertComment("Light curve times");
        xHeader.addValue(LC_START_KW, mjdStart, "start of time series MJD [s]");
        xHeader.addValue(LC_END_KW, mjdEnd, "end of time series MJD [s]");
        xHeader.insertComment("Trial transit pulse");
        for (int i=0; i < trialTransitPulse.length; i++) {
            xHeader.addValue(TRIAL_TRANSIT_PULSE + (i + 1), trialTransitPulse[i], "Trial transit pulse in hours");
        }
        xHeader.addValue(NPLANETS, planetNumbers.length, "The number of planets found in this system");
        int colNumber = 1;
        addColumn(xHeader, colNumber, TIME_TCOLUMN, 
            TIME_TCOLUMN_COMMENT, 
            "1D", TIME_TCOLUMN_DISPLAY_HINT, TIME_TCOLUMN_UNIT, FILL);
        
        colNumber++;
        
        xHeader.addValue("TTYPE" + colNumber, OLD_CADENCE_NUMBER, nameComment(colNumber, "cadence number"));
        xHeader.addValue(TFORM_KW + colNumber, "1J", "data type for field: one 32bit int");
        xHeader.addValue("TDISP" + colNumber, "I16.0", displayComment(colNumber));
        
        xHeader.insertComment("Missing values will be represented as NaN");
        xHeader.insertComment("Residual flux");
        addColumn(xHeader, ++colNumber, "residual_flux", 
            "unfilled normalized flux after transits removed","1E", 
            "E13.7",
            "dimensionless [e-/e-]", FILL);
        
        addColumn(xHeader, ++colNumber, "residual_flux_err",
            "uncertainty in residual_flux",
            "1E", "E13.7",
            "sd", FILL);
        
        xHeader.insertComment("Flux used to fit planet N");
        for (int planeti=0; planeti < planetNumbers.length; planeti++) {
            int planetNo = planetNumbers[planeti];
            addColumn(xHeader, ++colNumber, INIT_FLUX_PLANET + planetNo, 
                "unfilled, initial, normalized flux for planet " + planetNo, 
                "1E", "E13.7", "dimensionless", FILL);
            addColumn(xHeader, ++colNumber, "init_flux_pl" + planetNo + "_err",
                "uncertainty in initial flux", "1E", "E13.7", "sd", FILL);
        }

        
        xHeader.insertComment("Single event statistics");
        for (int i=0; i < trialTransitPulse.length; i++) {
            String pulse = String.format("%04.1f", trialTransitPulse[i]);
            pulse = pulse.replace('.', '_');
            addColumn(xHeader, ++colNumber, "single_evt_stat_corr_" + pulse,
                "single event statistic correlation, unfilled",
                "1E", "E13.7", "?", FILL);
            addColumn(xHeader, ++colNumber, "single_evt_stat_norm_" + pulse,
                "single event statistic normalized, unfilled",
                "1E", "E13.7", "?", FILL);
        }
        xHeader.insertComment("Per planet model light curves.");
        for (int planeti=0; planeti < planetNumbers.length; planeti++) {
            int planetNo = planetNumbers[planeti];
            addColumn(xHeader, ++colNumber, MODEL_FIT_LIGHT_CURVE + planetNo,
                "model light curve planet " + planetNo,
                "1E", "E13.7", "dimensionless", FILL);
        }
        
        return xHeader;
    }
    
    static DvTimeSeriesFitsFile read(File inputFile) throws FitsException, IOException {
        Fits inputFits = new Fits(inputFile);
        BasicHDU primaryHdu = inputFits.readHDU();
        Header primaryHeader = primaryHdu.getHeader();
        int keplerId = primaryHeader.getIntValue(KEPLERID_KW);
        String fileName = primaryHeader.getStringValue(FILENAME_KW);
        if (!fileName.equals(inputFile.getName())) {
            throw new IllegalArgumentException("File \\" + inputFile.getName() +
                "\" has non matching name keyword \"" + 
                fileName + "\".");
        }
        
        BinaryTableHDU dataHdu = (BinaryTableHDU) inputFits.readHDU();
        Header dataHeader = dataHdu.getHeader();
        int nPlanets = dataHeader.getIntValue(NPLANETS);
        int[] planetNumbers = new int[nPlanets];
        Cursor dataHeaderCursor = dataHeader.iterator();
        int planetNoIndex=0;
        while (dataHeaderCursor.hasNext()) {
            HeaderCard headerCard = (HeaderCard) dataHeaderCursor.next();
            if (headerCard.getKey().startsWith("TTYPE") && 
                headerCard.getValue().startsWith(INIT_FLUX_PLANET)) {
                String planetNoStr = headerCard.getValue().substring(INIT_FLUX_PLANET.length());
                //Could be better.
                if (planetNoStr.endsWith("_err")) {
                    continue;
                }
                planetNumbers[planetNoIndex++] = Integer.parseInt(planetNoStr);
            }
        }
        Arrays.sort(planetNumbers);
        
        double start = dataHeader.getDoubleValue(LC_START_KW);
        double end = dataHeader.getDoubleValue(LC_END_KW);
        long pipelineTaskId = dataHeader.getLongValue(SOC_PIPELINE_TASK_ID);
        
        TFloatArrayList trialTransitPulse = new TFloatArrayList();
        for (int i=1; i < 100; i++) {
            float ttpulse = dataHeader.getFloatValue(TRIAL_TRANSIT_PULSE + i, -1.0f);
            if (ttpulse == -1.0f) {
                break;
            }
            trialTransitPulse.add(ttpulse);
        }
        if (trialTransitPulse.size() == 0) {
            throw new IllegalStateException("Does not contain trial transit pulse information.");
        }
        
        int columnIndex=0;
        double[] time = (double[]) dataHdu.getColumn(columnIndex++);
        int[] cadences = (int[]) dataHdu.getColumn(columnIndex++);
        float[] residual = (float[]) dataHdu.getColumn(columnIndex++);
        float[] residualUncert = (float[])dataHdu.getColumn(columnIndex++);
        
        
        float[][] initFlux = new float[nPlanets][];
        float[][] initFluxUncert = new float[nPlanets][];
        float[][] modelLightCurve = new float[nPlanets][];
        
        for (int planeti=0; planeti < nPlanets; planeti++) {
            initFlux[planeti] = (float[]) dataHdu.getColumn(columnIndex++);
            initFluxUncert[planeti] = (float[]) dataHdu.getColumn(columnIndex++);
        }

        
        float[][] sevNormalized = new float[trialTransitPulse.size()][];
        float[][] sevCorrelated = new float[trialTransitPulse.size()][];
        
        for (int pulsei=0; pulsei < trialTransitPulse.size(); pulsei++) {
            sevCorrelated[pulsei] = (float[]) dataHdu.getColumn(columnIndex++);
            sevNormalized[pulsei] = (float[]) dataHdu.getColumn(columnIndex++);
        }
        for (int planeti=0; planeti < nPlanets; planeti++) {
            modelLightCurve[planeti] = (float[]) dataHdu.getColumn(columnIndex++);
        }
        
        DvTimeSeriesFitsFile dvFlux = new DvTimeSeriesFitsFile();
        dvFlux.setCadences(cadences);
        dvFlux.setInitialFlux(initFlux);
        dvFlux.setInitialFluxUncertaintiy(initFluxUncert);
        dvFlux.setKeplerId(keplerId);
        dvFlux.setMjdEnd(end);
        dvFlux.setMjdStart(start);
        dvFlux.setPlanetNumbers(planetNumbers);
        dvFlux.setPipelineTaskId(pipelineTaskId);
        dvFlux.setResidualTimeSeries(residual);
        dvFlux.setResidualTimeSeriesUncertaintiy(residualUncert);
        dvFlux.setSingleEventCorrelated(sevCorrelated);
        dvFlux.setSingleEventNormalized(sevNormalized);
        dvFlux.setTime(time);
        dvFlux.setTrialTransitPulse(trialTransitPulse.toNativeArray());
        dvFlux.setModelLightCurve(modelLightCurve);
        
        return dvFlux;
    }


    public double getMjdStart() {
        return mjdStart;
    }


    public void setMjdStart(double mjdStart) {
        this.mjdStart = mjdStart;
    }


    public double getMjdEnd() {
        return mjdEnd;
    }


    public void setMjdEnd(double mjdEnd) {
        this.mjdEnd = mjdEnd;
    }


    public float[][] getInitialFlux() {
        return initialFlux;
    }


    public void setInitialFlux(float[][] initialFlux) {
        this.initialFlux = initialFlux;
    }


    public float[][] getInitialFluxUncertaintiy() {
        return initialFluxUncertaintiy;
    }


    public void setInitialFluxUncertaintiy(float[][] initialFluxUncertaintiy) {
        this.initialFluxUncertaintiy = initialFluxUncertaintiy;
    }

    public float[] getTrialTransitPulse() {
        return trialTransitPulse;
    }


    public void setTrialTransitPulse(float[] trialTransitPulse) {
        this.trialTransitPulse = trialTransitPulse;
    }


    public float[][] getSingleEventNormalized() {
        return singleEventNormalized;
    }


    public void setSingleEventNormalized(float[][] singleEventNormalized) {
        this.singleEventNormalized = singleEventNormalized;
    }


    public float[][] getSingleEventCorrelated() {
        return singleEventCorrelated;
    }


    public void setSingleEventCorrelated(float[][] singleEventCorrelated) {
        this.singleEventCorrelated = singleEventCorrelated;
    }


    public float[] getResidualTimeSeries() {
        return residualTimeSeries;
    }


    public void setResidualTimeSeries(float[] residualTimeSeries) {
        this.residualTimeSeries = residualTimeSeries;
    }


    public float[] getResidualTimeSeriesUncertaintiy() {
        return residualTimeSeriesUncertaintiy;
    }


    public void setResidualTimeSeriesUncertaintiy(
        float[] residualTimeSeriesUncertaintiy) {
        this.residualTimeSeriesUncertaintiy = residualTimeSeriesUncertaintiy;
    }


    public double[] getTime() {
        return time;
    }


    public void setTime(double[] time) {
        this.time = time;
    }


    public int[] getCadences() {
        return cadences;
    }


    public void setCadences(int[] cadences) {
        this.cadences = cadences;
    }


    public int getKeplerId() {
        return keplerId;
    }


    public void setKeplerId(int keplerId) {
        this.keplerId = keplerId;
    }


    public long getPipelineTaskId() {
        return pipelineTaskId;
    }


    public void setPipelineTaskId(long pipelineTaskId) {
        this.pipelineTaskId = pipelineTaskId;
    }


    public int[] getPlanetNumbers() {
        return planetNumbers;
    }


    public void setPlanetNumbers(int[] planetNumbers) {
        this.planetNumbers = planetNumbers;
    }


    public float[][] getModelLightCurve() {
        return modelLightCurve;
    }


    public void setModelLightCurve(float[][] modelLightCurve) {
        this.modelLightCurve = modelLightCurve;
    }

    //Hey, this is actually not completely automatically generated. Remember to
    //use Arrays.deepHashCode for multi-dimensional arrays of primitives
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + Arrays.hashCode(cadences);
        result = prime * result + Arrays.deepHashCode(initialFlux);
        result = prime * result + Arrays.deepHashCode(initialFluxUncertaintiy);
        result = prime * result + keplerId;
        long temp;
        temp = Double.doubleToLongBits(mjdEnd);
        result = prime * result + (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(mjdStart);
        result = prime * result + (int) (temp ^ (temp >>> 32));
        result = prime * result + Arrays.deepHashCode(modelLightCurve);
        result = prime * result
            + (int) (pipelineTaskId ^ (pipelineTaskId >>> 32));
        result = prime * result + Arrays.hashCode(planetNumbers);
        result = prime * result + Arrays.hashCode(residualTimeSeries);
        result = prime * result
            + Arrays.hashCode(residualTimeSeriesUncertaintiy);
        result = prime * result + Arrays.deepHashCode(singleEventCorrelated);
        result = prime * result + Arrays.deepHashCode(singleEventNormalized);
        result = prime * result + Arrays.hashCode(time);
        result = prime * result + Arrays.hashCode(trialTransitPulse);
        return result;
    }

    
    //Hey, this is actually not completely automatically generated. Remember to
    //use Arrays.deepEquals for multi-dimensional arrays of primitives
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        DvTimeSeriesFitsFile other = (DvTimeSeriesFitsFile) obj;
        if (!Arrays.equals(cadences, other.cadences))
            return false;
        if (!Arrays.deepEquals(initialFlux, other.initialFlux))
            return false;
        if (!Arrays.deepEquals(initialFluxUncertaintiy,
            other.initialFluxUncertaintiy))
            return false;
        if (keplerId != other.keplerId)
            return false;
        if (Double.doubleToLongBits(mjdEnd) != Double.doubleToLongBits(other.mjdEnd))
            return false;
        if (Double.doubleToLongBits(mjdStart) != Double.doubleToLongBits(other.mjdStart))
            return false;
        if (!Arrays.deepEquals(modelLightCurve, other.modelLightCurve))
            return false;
        if (pipelineTaskId != other.pipelineTaskId)
            return false;
        if (!Arrays.equals(planetNumbers, other.planetNumbers))
            return false;
        if (!Arrays.equals(residualTimeSeries, other.residualTimeSeries))
            return false;
        if (!Arrays.equals(residualTimeSeriesUncertaintiy,
            other.residualTimeSeriesUncertaintiy))
            return false;
        if (!Arrays.deepEquals(singleEventCorrelated, other.singleEventCorrelated))
            return false;
        if (!Arrays.deepEquals(singleEventNormalized, other.singleEventNormalized))
            return false;
        if (!Arrays.equals(time, other.time))
            return false;
        if (!Arrays.equals(trialTransitPulse, other.trialTransitPulse))
            return false;
        return true;
    }


    //Hey, this is actually not completely automatically generated. Remember to
    //use Arrays.deepToString for multi-dimensional arrays of primitives
    @Override
    public String toString() {
        return "DvTimeSeriesFitsFile [mjdStart=" + mjdStart + ", mjdEnd="
            + mjdEnd + ", initialFlux=" + Arrays.deepToString(initialFlux)
            + ", initialFluxUncertaintiy="
            + Arrays.deepToString(initialFluxUncertaintiy) + ", modelLightCurve="
            + Arrays.deepToString(modelLightCurve) + ", trialTransitPulse="
            + Arrays.toString(trialTransitPulse) + ", singleEventNormalized="
            + Arrays.deepToString(singleEventNormalized)
            + ", singleEventCorrelated="
            + Arrays.deepToString(singleEventCorrelated) + ", residualTimeSeries="
            + Arrays.toString(residualTimeSeries)
            + ", residualTimeSeriesUncertaintiy="
            + Arrays.toString(residualTimeSeriesUncertaintiy) + ", time="
            + Arrays.toString(time) + ", cadences=" + Arrays.toString(cadences)
            + ", keplerId=" + keplerId + ", pipelineTaskId=" + pipelineTaskId
            + ", planetNumbers=" + Arrays.toString(planetNumbers) + "]";
    }


   

}
