/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

package gov.nasa.kepler.fs.server.scheduler;

import gov.nasa.kepler.fs.api.FileStoreException;

import java.io.IOException;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.ArrayList;

import org.apache.commons.math3.random.MersenneTwister;
import org.apache.commons.math3.random.RandomGenerator;

import com.google.common.collect.Lists;

/**  
 *  Orders FsIds into chunks which should be accessed sequentially.
 *  
 * @author Sean McCauliff
 *
 */
public class Scheduler {
    
    private final static Comparator<FsIdLocation> comparator = new Comparator<FsIdLocation>() {
        @Override
        public int compare(FsIdLocation loc1, FsIdLocation loc2) {
            int diff = loc1.fileLocation() -  loc2.fileLocation();
            if (diff != 0) {
                return diff;
            }
   
            long ldiff = loc1.offsetInFile() - loc2.offsetInFile();
            if (ldiff < 0) {
                return -1;
            } else if (ldiff > 0) {
                return 1;
            }
            return 0;
        }
    };
    
    /**
     * This was generated by doing: 
     * dd if=/dev/urandom of=rand.64bit bs=8 count=1
     * cat rand.64bit | perl -e ' read(<STDIN>, $b, 8); $i64 = unpack("q", $b); print "$i64\n"; '
     */
    private static final long RANDOM_SEED = -645072628869982130L;
    
    /**
     * This is used to advance the sequence of reads by a random number so
     * threads reading the same set of FsIds don't step on each other.
     */
    private static final RandomGenerator globalRand = 
        new SynchronizedRandomGenerator(new MersenneTwister(RANDOM_SEED));
    
    private final FsIdLocationFactory locationFactory;
    private final RandomGenerator offsetGenerator;
    
    public Scheduler(FsIdLocationFactory locationFactory) {
        this(locationFactory, globalRand);
    }
    
    Scheduler(FsIdLocationFactory locationFactory, RandomGenerator rand) {
        this.locationFactory = locationFactory;
        this.offsetGenerator = rand;
    }
    
    /**
     * FsIds in the same list should be access in the order listed.  FsIds in different lists can be accessed
     * in different orders.
     * @param ids zero or more ids.
     * @param orderStart The absolute order number for the first FsId in the list.
     * @return A non-null schedule which includes all the ids mentioned in the ids parameter.
     * @throws IOException 
     * @throws InterruptedException 
     */
    public List<List<FsIdOrder>> accessOrder(List<FsIdOrder> ids, int orderStart) throws FileStoreException, IOException, InterruptedException {
        if (ids.size() == 0) {
            return Collections.emptyList();
        }
        List<FsIdLocation> locations = locationFactory.locationFor(ids);
        
        Collections.sort(locations, comparator);
        
        List<List<FsIdOrder>> schedule = new ArrayList<List<FsIdOrder>>();
        int lastFileLocation = locations.get(0).fileLocation() - 1;
        List<FsIdOrder> currentBatch = null;
        for (FsIdLocation sortedLocation : locations) {
            if (lastFileLocation != sortedLocation.fileLocation()) {
                currentBatch = new ArrayList<FsIdOrder>();
                schedule.add(currentBatch);
                lastFileLocation = sortedLocation.fileLocation();
            }
            currentBatch.add(sortedLocation);
        }
        
        if (schedule.isEmpty()) {
            return schedule;
        }
        List<List<FsIdOrder>> offsetSchedule = Lists.newArrayListWithExpectedSize(schedule.size());
        int offset = offsetGenerator.nextInt(schedule.size());
        offsetSchedule.addAll(schedule.subList(offset, schedule.size()));
        offsetSchedule.addAll(schedule.subList(0, offset));
        return offsetSchedule;
    }
}
