/*
 * Copyright 2017 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 * 
 * This file is available under the terms of the NASA Open Source Agreement
 * (NOSA). You should have received a copy of this agreement with the
 * Kepler source code; see the file NASA-OPEN-SOURCE-AGREEMENT.doc.
 * 
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
 * TO THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 * 
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT. IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW. RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 */

group TimeSeriesTemplates;

//  See stringtemplate.org
//
// classPrefix - Int
// smallType - int
// seriesName - iname
// readMethod - readInt
// writeMethod - writeInt
// isFloat - either "true" or "false"
// parseStringMethod - Integer.parseInt
// enumTypeName - IntType
TimeSeriesTemplate(classPrefix, smallType, seriesName, readMethod, writeMethod, isFloat, parseStringMethod, enumTypeName) ::= <<

package gov.nasa.kepler.fs.api;

import gov.nasa.kepler.io.DataInputStream;
import gov.nasa.kepler.io.DataOutputStream;

import gov.nasa.spiffy.common.intervals.SimpleInterval;
import gov.nasa.spiffy.common.intervals.TaggedInterval;
import gov.nasa.spiffy.common.persistable.ProxyIgnoreStatics;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.lang.builder.ToStringBuilder;

/**
 *  This file is automatically generated from StringTemplate.stg
 *  This is a TimeSeries of semi-contiguous data that holds the primitive type
 *  <smallType>.
 *
 * @author Sean McCauliff
 * @author Jay Gunter
 * 
 */

@ProxyIgnoreStatics
public class <classPrefix>TimeSeries extends TimeSeries {

    private static final <smallType>[] ZERO_DATA = new <smallType>[0];

    private <smallType>[] <seriesName>;

    /**
     * @param <seriesName> The length of this array is always endCadence -
     * startCadence + 1 Even if none of the series are valid.
     * @param id
     * @param startCadence
     * @param endCadence
     * @param validCadences
     * @param originators
     */
    public <classPrefix>TimeSeries(FsId id, <smallType>[] <seriesName>, int startCadence,
        int endCadence, List\<SimpleInterval\> validCadences,
        List\<TaggedInterval\> originators, boolean exists) {

        super(id, startCadence, endCadence, validCadences, originators, exists);

        this.<seriesName> = <seriesName>;
        this.isFloat = <isFloat>;

        if (<seriesName>.length != cadenceLength()
            && startCadence != NOT_EXIST_CADENCE
            && endCadence != NOT_EXIST_CADENCE) {
            throw new IllegalArgumentException("<seriesName> length "
                + <seriesName>.length + " does not match cadence length "
                + cadenceLength() + " for FsId \"" + id + "\".");
        }

    }

    /**
     * @param <seriesName> The length of this array is always endCadence -
     * startCadence + 1 Even if none of the series are valid.
     * @param id
     * @param startCadence
     * @param endCadence
     * @param gaps
     * @param moduleId
     */
    public <classPrefix>TimeSeries(FsId id, <smallType>[] <seriesName>, int startCadence,
        int endCadence, boolean[] gaps, long moduleId, boolean exists) {

        super(id, startCadence, endCadence, gaps, moduleId, exists);

        this.<seriesName> = <seriesName>;
        this.isFloat = <isFloat>;

        if (<seriesName>.length != cadenceLength()
            && startCadence != NOT_EXIST_CADENCE
            && endCadence != NOT_EXIST_CADENCE) {
            throw new IllegalArgumentException("<seriesName> length "
                + <seriesName>.length + " does not match cadence length "
                + cadenceLength() + " for FsId \"" + id + "\".");
        }
    }

    /**
     * @param <seriesName> The length of this array is always endCadence -
     * startCadence + 1 Even if none of the series are valid.
     * @param id
     * @param startCadence
     * @param endCadence
     * @param gaps  Gap indices.
     * @param moduleId
     */
    public <classPrefix>TimeSeries(FsId id, <smallType>[] <seriesName>, int startCadence,
        int endCadence, int[] gaps, long moduleId, boolean exists) {

        super(id, startCadence, endCadence, gaps, moduleId, exists);

        this.<seriesName> = <seriesName>;
        this.isFloat = <isFloat>;

        if (<seriesName>.length != cadenceLength()
            && startCadence != NOT_EXIST_CADENCE
            && endCadence != NOT_EXIST_CADENCE) {
            throw new IllegalArgumentException("<seriesName> length "
                + <seriesName>.length + " does not match cadence length "
                + cadenceLength() + " for FsId \"" + id + "\".");
        }
    }
    /**
     * Construct a time series where exists == true.
     * 
     * @param id
     * @param <seriesName>
     * @param startCadence
     * @param endCadence
     * @param validCadences
     * @param originators
     */
    public <classPrefix>TimeSeries(FsId id, <smallType>[] <seriesName>, int startCadence,
        int endCadence, List\<SimpleInterval\> validCadences,
        List\<TaggedInterval> originators) {
        this(id, <seriesName>, startCadence, endCadence, validCadences, originators,
            true);
    }

    /**
     * Construct a time series where exists == true.
     * 
     * @param id
     * @param <seriesName>
     * @param startCadence
     * @param endCadence
     * @param gaps
     * @param moduleId
     */
    public <classPrefix>TimeSeries(FsId id, <smallType>[] <seriesName>, int startCadence,
        int endCadence, boolean[] gaps, long moduleId) {
        this(id, <seriesName>, startCadence, endCadence, gaps, moduleId, true);
    }

    /**
     * Construct a time series where exists == true.
     * 
     * @param id
     * @param <seriesName>
     * @param startCadence
     * @param endCadence
     * @param gaps  gap indices.
     * @param moduleId
     */
    public <classPrefix>TimeSeries(FsId id, <smallType>[] <seriesName>, int startCadence,
        int endCadence, int[] gaps, long moduleId) {
        this(id, <seriesName>, startCadence, endCadence, gaps, moduleId, true);
    }

    /**
     * Don't use this method.
     */
    public <classPrefix>TimeSeries() {

    }

    public <smallType>[] <seriesName>() {
        return <seriesName>;
    }

    
    public void fillGaps(<smallType> fillValue) {

        if (validCadences.size() == 0) {
            Arrays.fill(<seriesName>, 0, <seriesName>.length, fillValue);
            return;
        }

        int prevEnd = startCadence - 1;
        for (SimpleInterval v : validCadences) {
            int stop = ((int) v.start()) - startCadence;
            int start = prevEnd - startCadence + 1;
            Arrays.fill(<seriesName>, start, stop, fillValue);
            prevEnd = (int) v.end();
        }

        // Post fill.
        if (endCadence > prevEnd) {
            int stop = endCadence - startCadence + 1;
            int start = prevEnd - startCadence + 1;
            Arrays.fill(<seriesName>, start, stop, fillValue);
        }
    }

    /**
     * @see gov.nasa.kepler.fs.api.TimeSeries#appendValue(java.lang.StringBuffer,
     * int)
     */
    @Override
    protected void appendValue(StringBuffer writer, int index) {
        writer.append(<seriesName>[index]);
    }

    @Override
    public TimeSeriesDataType dataType() {
        return TimeSeriesDataType.<enumTypeName>;
    }

    @Override
    public Object series() {
        return <seriesName>;
    }
    
    @Override
    public boolean equals(Object o) {
        if (!super.equals(o)) {
            return false;
        }

        if (!(o instanceof <classPrefix>TimeSeries)) {
            return false;
        }

        <classPrefix>TimeSeries other = (<classPrefix>TimeSeries) o;
        return Arrays.equals(this.<seriesName>, other.<seriesName>);
    }

    @Override
    public int hashCode() {
        int superHashCode = super.hashCode();
        int ourHashCode = Arrays.hashCode(<seriesName>) ^ superHashCode;
        return ourHashCode;
    }

    @Override
    public void transferTo(DataOutputStream dout) throws IOException {
        super.transferTo(dout);

        // Don't write gaps.
        if (!exists()) {
            return;
        }

        for (SimpleInterval v : validCadences()) {
            int di = ((int) v.start()) - startCadence;
            for (int i = (int) v.start(); i \<= v.end(); i++, di++) {
                dout.<writeMethod>(<seriesName>[di]);
            }
        }

    }

    static class <classPrefix>TimeSeriesParser extends TimeSeriesParser {

        @Override
        void addData(Object data, int index, String value) {
            ((<smallType>[]) data)[index] = <parseStringMethod>(value);
        }

        @Override
        TimeSeries buildTimeSeries(FsId id, Object data, int startCadence,
            int endCadence, List\<SimpleInterval\> valid,
            List\<TaggedInterval> originators, boolean exists) {

            return new <classPrefix>TimeSeries(id, (<smallType>[]) data, startCadence,
                endCadence, valid, originators, exists);
        }

        @Override
        Object newData(int size) {
            return new <smallType>[size];
        }

        @Override
        String type() {
            return TimeSeriesDataType.<enumTypeName>.typeName();
        }

        @Override
        TimeSeries buildTimeSeries(FsId id, int startCadence, int endCadence,
            List\<SimpleInterval\> valid, List\<TaggedInterval> originators,
            boolean exists, DataInputStream din) throws IOException {

            int size = endCadence - startCadence + 1;

            if (!exists) {
                if (startCadence == NOT_EXIST_CADENCE) {
                    return new <classPrefix>TimeSeries(id, ZERO_DATA, startCadence,
                        endCadence, valid, originators, exists);
                } else {
                    return new <classPrefix>TimeSeries(id, new <smallType>[size], startCadence,
                        endCadence, valid, originators, exists);
                }
            }

            // Don't read in data that is not there.
            <smallType>[] data = new <smallType>[size];
            int di = 0;
            for (SimpleInterval v : valid) {
                int start = (int) v.start();
                int end = (int) v.end();
                di = start - startCadence;
                for (int i = start; i \<= end; i++, di++) {
                    data[di] = din.<readMethod>();
                }
            }

            return new <classPrefix>TimeSeries(id, data, startCadence, endCadence, valid,
                originators, exists);
        }

    }


   
    @Override
    public String toString() {
        return new ToStringBuilder(this).appendSuper(super.toString())
            .append("<seriesName>.hashCode", <seriesName>.hashCode())
            .toString();
    }
}

>>

//  FloatType("float", FileStoreConstants.FLOAT_TYPE, Float.SIZE),
//    IntType("int", FileStoreConstants.INT_TYPE, Integer.SIZE);

/**
 * types.constructor = "FloatType("float", FileStoreConstants.FLOAT_TYPE, Float.SIZE),"
 * types.typeName = "IntType" the name of enum
 * types.smallType = "int"
 */
TimeSeriesDataTypeTemplate(types) ::= <<
package gov.nasa.kepler.fs.api;

import gov.nasa.spiffy.common.lang.MathUtils;
import gov.nasa.kepler.io.*;

/**
 * The data type stored in a time series.
 * This enum has been automatically generated from StringTemplate.stg.
 *
 * @author Sean McCauliff
 *
 */
public enum TimeSeriesDataType {

    <trunc(types:enumConstructorTemplate())>
    <last(types:lastEnumConstructorTemplate())>;

    
    private final String typeName;
    private final byte typeByte;
    private final int sizeOf;
    private final int bitShift;
    
    private TimeSeriesDataType(String typeName, byte typeByte, int sizeOf) {
        this.typeName = typeName;
        this.typeByte = typeByte;
        this.sizeOf = sizeOf;
        this.bitShift = MathUtils.log2(sizeOf) - 1;
    }
    
    public String typeName() { return typeName; }
    
    public byte typeByte() { return typeByte; }

    /**
     * 
     * @return  The number of bytes an individual point uses.
     */
    public int sizeOf() { return sizeOf; }
    
    /**
     * The number of bits to shift when translating addresses.
     * @return
     */
    public int bitShift() { return bitShift; }
    
    public long byteStartCadenceToStartCadence(long byteCadenceAddress) {
        return byteCadenceAddress \>\> bitShift;
    }
    
    public long startCadenceToByteStartCadence(long dataTypeCadenceAddress) {
        return dataTypeCadenceAddress \<\< bitShift;
    }
    
    public long byteEndCadenceToEndCadence(long byteCadenceAddress) {
        return byteCadenceAddress \>\> bitShift;
    }
    
    public long endCadenceToByteEndCadence(long dataTypeCadenceAddress) {
        return (dataTypeCadenceAddress + 1 \<\< bitShift) -1;
    }
    
    /**
     * Converts from a byte array to the native array of this data type.
     * @param byteArray
     * @return the native array of the same length.  If byteArray is null then
     *  this will also be null.
     */
    public Object fromByteArray(byte[] byteArray) {
        if (byteArray == null) return null;
        
        switch (this) {
        <types:fromByteArrayCallTemplate()>
             default:
                throw new IllegalStateException("Unimplemented conversion.");
        }
    }
    
    /**
     * Converts from a native array to a byte array.
     * @param nativeArray  The native array of one of the supported primitive types.
     * @param nativeStartIndex The index in the nativeArray to start from.
     * @param nNativeElements The number of native elements to copy into the
     *  dest buffer.
     * @param destStart The byte to start from in the dest buffer
     * @param dest The destination byte buffer.
     */
     public void toByteArray(Object nativeArray, int nativeStartIndex, 
                             int nNativeElements, byte[] dest, int destStart) {
         
         switch (this) {
         <types:toByteArrayCallTemplate()>
         default:
             throw new IllegalStateException("Unimplemented conversion.");
         }
     }
    
    
    public static TimeSeriesDataType valueOf(byte typeByte) {
        for (TimeSeriesDataType dt : TimeSeriesDataType.values()) {
            if (dt.typeByte == typeByte) {
                return dt;
            }
        }

        throw new IllegalArgumentException("Unrecognized type byte " + typeByte);
    }
    
    public static TimeSeriesDataType valueOfTypeString(String typeString) {
        for (TimeSeriesDataType dt : TimeSeriesDataType.values()) {
            if (dt.typeName.equals(typeString)) {
                return dt;
            }
        }
        
        throw new IllegalArgumentException("Unrecognized type string \"" + typeString + "\".");
    }
    
    <types:fromByteArrayImplementationTemplate()>
    
    <types:toByteArrayImplementationTemplate()>
}
>>


enumConstructorTemplate() ::= <<
    <it.enumConstructor>,
    
>>

//This ones does not have a comma at the end
lastEnumConstructorTemplate() ::= <<
    <it.enumConstructor>
    
>>

fromByteArrayCallTemplate() ::= <<
    case <it.enumTypeName>: return <it.enumTypeName>FromByteArray(byteArray);

>>

fromByteArrayImplementationTemplate() ::= <<

    private <it.smallType>[] <it.enumTypeName>FromByteArray(byte[] byteArray) {
        try {
            WrappedByteArrayInputStream bin = new WrappedByteArrayInputStream(byteArray);
            DataInputStream din = new DataInputStream(bin);
            <it.smallType>[] data = new <it.smallType>[byteArray.length \>\> this.bitShift];
            for (int i=0; i \< data.length; i++) {
                data[i] = din.<it.readMethod>();
            }
            return data;
        } catch (java.io.IOException ioe) {
             throw new IllegalStateException("IOException when such an exception is not possible.", ioe);
        }
    }
     
>>


toByteArrayCallTemplate() ::= <<
    case <it.enumTypeName>: <it.enumTypeName>ToByteArray(nativeArray, nativeStartIndex, nNativeElements, dest, destStart); break;

>>

toByteArrayImplementationTemplate() ::= <<

    private void <it.enumTypeName>ToByteArray(Object nativeArray,
                             int nativeStartIndex, 
                             int nNativeElements, byte[] dest, int destStart) {
        try {
            <it.smallType>[] data = (<it.smallType>[]) nativeArray;
            WrappedByteArrayOutputStream bout = new WrappedByteArrayOutputStream(dest, destStart);
            DataOutputStream dout = new DataOutputStream(bout);
            final int stopIndex = nativeStartIndex + nNativeElements;
            for (int ni=nativeStartIndex; ni \< stopIndex; ni++) {
                dout.<it.writeMethod>(data[ni]);
            }
        } catch (java.io.IOException ioe) {
             throw new IllegalStateException("IOException when such an exception is not possible.", ioe);
        }
    }
    
>>
